// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_Config
#include <hxinc/nape/Config.h>
#endif
#ifndef INCLUDED_nape_dynamics_Arbiter
#include <hxinc/nape/dynamics/Arbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_FluidArbiter
#include <hxinc/nape/dynamics/FluidArbiter.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Arbiter
#include <hxinc/zpp_nape/dynamics/ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_FluidArbiter
#include <hxinc/zpp_nape/dynamics/ZPP_FluidArbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_FluidProperties
#include <hxinc/zpp_nape/phys/ZPP_FluidProperties.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Circle
#include <hxinc/zpp_nape/shape/ZPP_Circle.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Edge
#include <hxinc/zpp_nape/shape/ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Polygon
#include <hxinc/zpp_nape/shape/ZPP_Polygon.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <hxinc/zpp_nape/shape/ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_AABBPair
#include <hxinc/zpp_nape/space/ZPP_AABBPair.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Arbiter
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Edge
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Arbiter
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Edge
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_PubPool
#include <hxinc/zpp_nape/util/ZPP_PubPool.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_446_new,"zpp_nape.dynamics.ZPP_FluidArbiter","new",0xb3e8b5cf,"zpp_nape.dynamics.ZPP_FluidArbiter.new","zpp_nape/dynamics/Arbiter.hx",446,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_476_alloc,"zpp_nape.dynamics.ZPP_FluidArbiter","alloc",0x904003a4,"zpp_nape.dynamics.ZPP_FluidArbiter.alloc","zpp_nape/dynamics/Arbiter.hx",476,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_488_free,"zpp_nape.dynamics.ZPP_FluidArbiter","free",0xb276785d,"zpp_nape.dynamics.ZPP_FluidArbiter.free","zpp_nape/dynamics/Arbiter.hx",488,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_518_position_validate,"zpp_nape.dynamics.ZPP_FluidArbiter","position_validate",0xcbea33db,"zpp_nape.dynamics.ZPP_FluidArbiter.position_validate","zpp_nape/dynamics/Arbiter.hx",518,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_544_position_invalidate,"zpp_nape.dynamics.ZPP_FluidArbiter","position_invalidate",0xe7039800,"zpp_nape.dynamics.ZPP_FluidArbiter.position_invalidate","zpp_nape/dynamics/Arbiter.hx",544,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_566_getposition,"zpp_nape.dynamics.ZPP_FluidArbiter","getposition",0xe86b13ae,"zpp_nape.dynamics.ZPP_FluidArbiter.getposition","zpp_nape/dynamics/Arbiter.hx",566,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_601_assign,"zpp_nape.dynamics.ZPP_FluidArbiter","assign",0xb42d3020,"zpp_nape.dynamics.ZPP_FluidArbiter.assign","zpp_nape/dynamics/Arbiter.hx",601,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_647_retire,"zpp_nape.dynamics.ZPP_FluidArbiter","retire",0x714b738c,"zpp_nape.dynamics.ZPP_FluidArbiter.retire","zpp_nape/dynamics/Arbiter.hx",647,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_671_makemutable,"zpp_nape.dynamics.ZPP_FluidArbiter","makemutable",0xcf2febe7,"zpp_nape.dynamics.ZPP_FluidArbiter.makemutable","zpp_nape/dynamics/Arbiter.hx",671,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_677_makeimmutable,"zpp_nape.dynamics.ZPP_FluidArbiter","makeimmutable",0x0892e6c3,"zpp_nape.dynamics.ZPP_FluidArbiter.makeimmutable","zpp_nape/dynamics/Arbiter.hx",677,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_683_inject,"zpp_nape.dynamics.ZPP_FluidArbiter","inject",0x00113482,"zpp_nape.dynamics.ZPP_FluidArbiter.inject","zpp_nape/dynamics/Arbiter.hx",683,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_709_preStep,"zpp_nape.dynamics.ZPP_FluidArbiter","preStep",0xdea689fe,"zpp_nape.dynamics.ZPP_FluidArbiter.preStep","zpp_nape/dynamics/Arbiter.hx",709,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_1268_warmStart,"zpp_nape.dynamics.ZPP_FluidArbiter","warmStart",0x40a04a8c,"zpp_nape.dynamics.ZPP_FluidArbiter.warmStart","zpp_nape/dynamics/Arbiter.hx",1268,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_1303_applyImpulseVel,"zpp_nape.dynamics.ZPP_FluidArbiter","applyImpulseVel",0x4f9f97a5,"zpp_nape.dynamics.ZPP_FluidArbiter.applyImpulseVel","zpp_nape/dynamics/Arbiter.hx",1303,0x26846f2e)
HX_LOCAL_STACK_FRAME(_hx_pos_55ad567f8bfbf8c4_449_boot,"zpp_nape.dynamics.ZPP_FluidArbiter","boot",0xafcf5fe3,"zpp_nape.dynamics.ZPP_FluidArbiter.boot","zpp_nape/dynamics/Arbiter.hx",449,0x26846f2e)
namespace zpp_nape{
namespace dynamics{

void ZPP_FluidArbiter_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_446_new)
HXLINE( 706)		this->pre_dt = ((Float)0.0);
HXLINE( 668)		this->_hx_mutable = false;
HXLINE( 565)		this->wrap_position = null();
HXLINE( 517)		this->buoyy = ((Float)0.0);
HXLINE( 516)		this->buoyx = ((Float)0.0);
HXLINE( 515)		this->ny = ((Float)0.0);
HXLINE( 514)		this->nx = ((Float)0.0);
HXLINE( 513)		this->lgamma = ((Float)0.0);
HXLINE( 512)		this->dampy = ((Float)0.0);
HXLINE( 511)		this->dampx = ((Float)0.0);
HXLINE( 510)		this->vMassc = ((Float)0.0);
HXLINE( 509)		this->vMassb = ((Float)0.0);
HXLINE( 508)		this->vMassa = ((Float)0.0);
HXLINE( 507)		this->agamma = ((Float)0.0);
HXLINE( 506)		this->adamp = ((Float)0.0);
HXLINE( 505)		this->wMass = ((Float)0.0);
HXLINE( 504)		this->nodrag = false;
HXLINE( 503)		this->r2y = ((Float)0.0);
HXLINE( 502)		this->r2x = ((Float)0.0);
HXLINE( 501)		this->r1y = ((Float)0.0);
HXLINE( 500)		this->r1x = ((Float)0.0);
HXLINE( 499)		this->overlap = ((Float)0.0);
HXLINE( 498)		this->centroidy = ((Float)0.0);
HXLINE( 497)		this->centroidx = ((Float)0.0);
HXLINE( 448)		this->next = null();
HXLINE( 447)		this->outer_zn = null();
HXLINE( 574)		super::__construct();
HXLINE( 575)		this->type = ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID;
HXLINE( 576)		this->fluidarb = hx::ObjectPtr<OBJ_>(this);
HXLINE( 577)		{
HXLINE( 578)			this->buoyx = ( (Float)(0) );
HXLINE( 579)			this->buoyy = ( (Float)(0) );
            		}
HXLINE( 597)		this->pre_dt = ((Float)-1.0);
            	}

Dynamic ZPP_FluidArbiter_obj::__CreateEmpty() { return new ZPP_FluidArbiter_obj; }

void *ZPP_FluidArbiter_obj::_hx_vtable = 0;

Dynamic ZPP_FluidArbiter_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ZPP_FluidArbiter_obj > _hx_result = new ZPP_FluidArbiter_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ZPP_FluidArbiter_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x0719aa23) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x0719aa23;
	} else {
		return inClassId==(int)0x18020685;
	}
}

void ZPP_FluidArbiter_obj::alloc(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_476_alloc)
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,alloc,(void))

void ZPP_FluidArbiter_obj::free(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_488_free)
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,free,(void))

void ZPP_FluidArbiter_obj::position_validate(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_518_position_validate)
HXLINE( 520)		if (!(this->active)) {
HXLINE( 520)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 522)		{
HXLINE( 523)			this->wrap_position->zpp_inner->x = this->centroidx;
HXLINE( 524)			this->wrap_position->zpp_inner->y = this->centroidy;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,position_validate,(void))

void ZPP_FluidArbiter_obj::position_invalidate( ::zpp_nape::geom::ZPP_Vec2 x){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_544_position_invalidate)
HXLINE( 545)		this->centroidx = x->x;
HXLINE( 546)		this->centroidy = x->y;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_FluidArbiter_obj,position_invalidate,(void))

void ZPP_FluidArbiter_obj::getposition(){
            	HX_GC_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_566_getposition)
HXLINE( 567)		Float x = ( (Float)(0) );
HXDLIN( 567)		Float y = ( (Float)(0) );
HXDLIN( 567)		bool _hx_tmp;
HXDLIN( 567)		if ((x == x)) {
HXLINE( 567)			_hx_tmp = (y != y);
            		}
            		else {
HXLINE( 567)			_hx_tmp = true;
            		}
HXDLIN( 567)		if (_hx_tmp) {
HXLINE( 567)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN( 567)		 ::nape::geom::Vec2 ret;
HXDLIN( 567)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE( 567)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE( 567)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN( 567)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN( 567)			ret->zpp_pool = null();
HXDLIN( 567)			ret->zpp_disp = false;
HXDLIN( 567)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 567)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN( 567)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE( 567)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN( 567)			{
HXLINE( 567)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE( 567)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 567)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 567)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN( 567)					ret1->next = null();
            				}
HXDLIN( 567)				ret1->weak = false;
            			}
HXDLIN( 567)			ret1->_immutable = false;
HXDLIN( 567)			{
HXLINE( 567)				ret1->x = x;
HXDLIN( 567)				ret1->y = y;
            			}
HXDLIN( 567)			ret->zpp_inner = ret1;
HXDLIN( 567)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE( 567)			bool _hx_tmp1;
HXDLIN( 567)			if (hx::IsNotNull( ret )) {
HXLINE( 567)				_hx_tmp1 = ret->zpp_disp;
            			}
            			else {
HXLINE( 567)				_hx_tmp1 = false;
            			}
HXDLIN( 567)			if (_hx_tmp1) {
HXLINE( 567)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 567)			{
HXLINE( 567)				 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN( 567)				if (_this->_immutable) {
HXLINE( 567)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 567)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 567)					_this->_isimmutable();
            				}
            			}
HXDLIN( 567)			bool _hx_tmp2;
HXDLIN( 567)			if ((x == x)) {
HXLINE( 567)				_hx_tmp2 = (y != y);
            			}
            			else {
HXLINE( 567)				_hx_tmp2 = true;
            			}
HXDLIN( 567)			if (_hx_tmp2) {
HXLINE( 567)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN( 567)			bool _hx_tmp3;
HXDLIN( 567)			bool _hx_tmp4;
HXDLIN( 567)			if (hx::IsNotNull( ret )) {
HXLINE( 567)				_hx_tmp4 = ret->zpp_disp;
            			}
            			else {
HXLINE( 567)				_hx_tmp4 = false;
            			}
HXDLIN( 567)			if (_hx_tmp4) {
HXLINE( 567)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 567)			{
HXLINE( 567)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN( 567)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 567)					_this1->_validate();
            				}
            			}
HXDLIN( 567)			if ((ret->zpp_inner->x == x)) {
HXLINE( 567)				bool _hx_tmp5;
HXDLIN( 567)				if (hx::IsNotNull( ret )) {
HXLINE( 567)					_hx_tmp5 = ret->zpp_disp;
            				}
            				else {
HXLINE( 567)					_hx_tmp5 = false;
            				}
HXDLIN( 567)				if (_hx_tmp5) {
HXLINE( 567)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 567)				{
HXLINE( 567)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN( 567)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 567)						_this2->_validate();
            					}
            				}
HXDLIN( 567)				_hx_tmp3 = (ret->zpp_inner->y == y);
            			}
            			else {
HXLINE( 567)				_hx_tmp3 = false;
            			}
HXDLIN( 567)			if (!(_hx_tmp3)) {
HXLINE( 567)				{
HXLINE( 567)					ret->zpp_inner->x = x;
HXDLIN( 567)					ret->zpp_inner->y = y;
            				}
HXDLIN( 567)				{
HXLINE( 567)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN( 567)					if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE( 567)						_this3->_invalidate(_this3);
            					}
            				}
            			}
            		}
HXDLIN( 567)		ret->zpp_inner->weak = false;
HXDLIN( 567)		this->wrap_position = ret;
HXLINE( 568)		this->wrap_position->zpp_inner->_inuse = true;
HXLINE( 569)		this->wrap_position->zpp_inner->_immutable = !(this->_hx_mutable);
HXLINE( 570)		this->wrap_position->zpp_inner->_validate = this->position_validate_dyn();
HXLINE( 571)		this->wrap_position->zpp_inner->_invalidate = this->position_invalidate_dyn();
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,getposition,(void))

void ZPP_FluidArbiter_obj::assign( ::zpp_nape::shape::ZPP_Shape s1, ::zpp_nape::shape::ZPP_Shape s2,int id,int di){
            	HX_GC_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_601_assign)
HXLINE( 602)		{
HXLINE( 602)			this->b1 = s1->body;
HXDLIN( 602)			this->ws1 = s1;
HXDLIN( 602)			this->b2 = s2->body;
HXDLIN( 602)			this->ws2 = s2;
HXDLIN( 602)			this->id = id;
HXDLIN( 602)			this->di = di;
HXDLIN( 602)			{
HXLINE( 602)				 ::zpp_nape::util::ZNPList_ZPP_Arbiter _this = this->b1->arbiters;
HXDLIN( 602)				 ::zpp_nape::util::ZNPNode_ZPP_Arbiter ret;
HXDLIN( 602)				if (hx::IsNull( ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool )) {
HXLINE( 602)					ret =  ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 602)					ret = ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool;
HXDLIN( 602)					::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool = ret->next;
HXDLIN( 602)					ret->next = null();
            				}
HXDLIN( 602)				ret->elt = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 602)				 ::zpp_nape::util::ZNPNode_ZPP_Arbiter temp = ret;
HXDLIN( 602)				temp->next = _this->head;
HXDLIN( 602)				_this->head = temp;
HXDLIN( 602)				_this->modified = true;
HXDLIN( 602)				_this->length++;
            			}
HXDLIN( 602)			{
HXLINE( 602)				 ::zpp_nape::util::ZNPList_ZPP_Arbiter _this1 = this->b2->arbiters;
HXDLIN( 602)				 ::zpp_nape::util::ZNPNode_ZPP_Arbiter ret1;
HXDLIN( 602)				if (hx::IsNull( ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool )) {
HXLINE( 602)					ret1 =  ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 602)					ret1 = ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool;
HXDLIN( 602)					::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool = ret1->next;
HXDLIN( 602)					ret1->next = null();
            				}
HXDLIN( 602)				ret1->elt = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 602)				 ::zpp_nape::util::ZNPNode_ZPP_Arbiter temp1 = ret1;
HXDLIN( 602)				temp1->next = _this1->head;
HXDLIN( 602)				_this1->head = temp1;
HXDLIN( 602)				_this1->modified = true;
HXDLIN( 602)				_this1->length++;
            			}
HXDLIN( 602)			this->active = true;
HXDLIN( 602)			this->present = 0;
HXDLIN( 602)			this->cleared = false;
HXDLIN( 602)			this->sleeping = false;
HXDLIN( 602)			this->fresh = false;
HXDLIN( 602)			this->presentable = false;
            		}
HXLINE( 603)		{
HXLINE( 604)			this->nx = ( (Float)(0) );
HXLINE( 605)			this->ny = ( (Float)(1) );
            		}
HXLINE( 623)		{
HXLINE( 624)			this->dampx = ( (Float)(0) );
HXLINE( 625)			this->dampy = ( (Float)(0) );
            		}
HXLINE( 643)		this->adamp = ((Float)0.0);
            	}


HX_DEFINE_DYNAMIC_FUNC4(ZPP_FluidArbiter_obj,assign,(void))

void ZPP_FluidArbiter_obj::retire(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_647_retire)
HXLINE( 648)		{
HXLINE( 648)			if (!(this->cleared)) {
HXLINE( 648)				{
HXLINE( 648)					 ::zpp_nape::util::ZNPList_ZPP_Arbiter _this = this->b1->arbiters;
HXDLIN( 648)					{
HXLINE( 648)						 ::zpp_nape::util::ZNPNode_ZPP_Arbiter pre = null();
HXDLIN( 648)						 ::zpp_nape::util::ZNPNode_ZPP_Arbiter cur = _this->head;
HXDLIN( 648)						bool ret = false;
HXDLIN( 648)						while(hx::IsNotNull( cur )){
HXLINE( 648)							if (hx::IsEq( cur->elt,hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 648)								{
HXLINE( 648)									 ::zpp_nape::util::ZNPNode_ZPP_Arbiter old;
HXDLIN( 648)									 ::zpp_nape::util::ZNPNode_ZPP_Arbiter ret1;
HXDLIN( 648)									if (hx::IsNull( pre )) {
HXLINE( 648)										old = _this->head;
HXDLIN( 648)										ret1 = old->next;
HXDLIN( 648)										_this->head = ret1;
HXDLIN( 648)										if (hx::IsNull( _this->head )) {
HXLINE( 648)											_this->pushmod = true;
            										}
            									}
            									else {
HXLINE( 648)										old = pre->next;
HXDLIN( 648)										ret1 = old->next;
HXDLIN( 648)										pre->next = ret1;
HXDLIN( 648)										if (hx::IsNull( ret1 )) {
HXLINE( 648)											_this->pushmod = true;
            										}
            									}
HXDLIN( 648)									{
HXLINE( 648)										 ::zpp_nape::util::ZNPNode_ZPP_Arbiter o = old;
HXDLIN( 648)										o->elt = null();
HXDLIN( 648)										o->next = ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool;
HXDLIN( 648)										::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool = o;
            									}
HXDLIN( 648)									_this->modified = true;
HXDLIN( 648)									_this->length--;
HXDLIN( 648)									_this->pushmod = true;
            								}
HXDLIN( 648)								ret = true;
HXDLIN( 648)								goto _hx_goto_7;
            							}
HXDLIN( 648)							pre = cur;
HXDLIN( 648)							cur = cur->next;
            						}
            						_hx_goto_7:;
            					}
            				}
HXDLIN( 648)				{
HXLINE( 648)					 ::zpp_nape::util::ZNPList_ZPP_Arbiter _this1 = this->b2->arbiters;
HXDLIN( 648)					{
HXLINE( 648)						 ::zpp_nape::util::ZNPNode_ZPP_Arbiter pre1 = null();
HXDLIN( 648)						 ::zpp_nape::util::ZNPNode_ZPP_Arbiter cur1 = _this1->head;
HXDLIN( 648)						bool ret2 = false;
HXDLIN( 648)						while(hx::IsNotNull( cur1 )){
HXLINE( 648)							if (hx::IsEq( cur1->elt,hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 648)								{
HXLINE( 648)									 ::zpp_nape::util::ZNPNode_ZPP_Arbiter old1;
HXDLIN( 648)									 ::zpp_nape::util::ZNPNode_ZPP_Arbiter ret3;
HXDLIN( 648)									if (hx::IsNull( pre1 )) {
HXLINE( 648)										old1 = _this1->head;
HXDLIN( 648)										ret3 = old1->next;
HXDLIN( 648)										_this1->head = ret3;
HXDLIN( 648)										if (hx::IsNull( _this1->head )) {
HXLINE( 648)											_this1->pushmod = true;
            										}
            									}
            									else {
HXLINE( 648)										old1 = pre1->next;
HXDLIN( 648)										ret3 = old1->next;
HXDLIN( 648)										pre1->next = ret3;
HXDLIN( 648)										if (hx::IsNull( ret3 )) {
HXLINE( 648)											_this1->pushmod = true;
            										}
            									}
HXDLIN( 648)									{
HXLINE( 648)										 ::zpp_nape::util::ZNPNode_ZPP_Arbiter o1 = old1;
HXDLIN( 648)										o1->elt = null();
HXDLIN( 648)										o1->next = ::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool;
HXDLIN( 648)										::zpp_nape::util::ZNPNode_ZPP_Arbiter_obj::zpp_pool = o1;
            									}
HXDLIN( 648)									_this1->modified = true;
HXDLIN( 648)									_this1->length--;
HXDLIN( 648)									_this1->pushmod = true;
            								}
HXDLIN( 648)								ret2 = true;
HXDLIN( 648)								goto _hx_goto_8;
            							}
HXDLIN( 648)							pre1 = cur1;
HXDLIN( 648)							cur1 = cur1->next;
            						}
            						_hx_goto_8:;
            					}
            				}
HXDLIN( 648)				if (hx::IsNotNull( this->pair )) {
HXLINE( 648)					this->pair->arb = null();
HXDLIN( 648)					this->pair = null();
            				}
            			}
HXDLIN( 648)			this->b1 = (this->b2 = null());
HXDLIN( 648)			this->active = false;
HXDLIN( 648)			this->intchange = false;
            		}
HXLINE( 649)		{
HXLINE( 650)			 ::zpp_nape::dynamics::ZPP_FluidArbiter o2 = hx::ObjectPtr<OBJ_>(this);
HXLINE( 660)			o2->next = ::zpp_nape::dynamics::ZPP_FluidArbiter_obj::zpp_pool;
HXLINE( 661)			::zpp_nape::dynamics::ZPP_FluidArbiter_obj::zpp_pool = o2;
            		}
HXLINE( 666)		this->pre_dt = ((Float)-1.0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,retire,(void))

void ZPP_FluidArbiter_obj::makemutable(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_671_makemutable)
HXLINE( 672)		this->_hx_mutable = true;
HXLINE( 673)		if (hx::IsNotNull( this->wrap_position )) {
HXLINE( 673)			this->wrap_position->zpp_inner->_immutable = false;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,makemutable,(void))

void ZPP_FluidArbiter_obj::makeimmutable(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_677_makeimmutable)
HXLINE( 678)		this->_hx_mutable = false;
HXLINE( 679)		if (hx::IsNotNull( this->wrap_position )) {
HXLINE( 679)			this->wrap_position->zpp_inner->_immutable = true;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,makeimmutable,(void))

void ZPP_FluidArbiter_obj::inject(Float area,Float cx,Float cy){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_683_inject)
HXLINE( 684)		this->overlap = area;
HXLINE( 685)		{
HXLINE( 686)			this->centroidx = cx;
HXLINE( 687)			this->centroidy = cy;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(ZPP_FluidArbiter_obj,inject,(void))

void ZPP_FluidArbiter_obj::preStep( ::zpp_nape::space::ZPP_Space s,Float dt){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_709_preStep)
HXLINE( 710)		if ((this->pre_dt == ((Float)-1.0))) {
HXLINE( 710)			this->pre_dt = dt;
            		}
HXLINE( 711)		Float dtratio = (dt / this->pre_dt);
HXLINE( 712)		this->pre_dt = dt;
HXLINE( 713)		{
HXLINE( 714)			this->r1x = (this->centroidx - this->b1->posx);
HXLINE( 715)			this->r1y = (this->centroidy - this->b1->posy);
            		}
HXLINE( 717)		{
HXLINE( 718)			this->r2x = (this->centroidx - this->b2->posx);
HXLINE( 719)			this->r2y = (this->centroidy - this->b2->posy);
            		}
HXLINE( 721)		Float g1x = ((Float)0.0);
HXLINE( 722)		Float g1y = ((Float)0.0);
HXLINE( 723)		bool _hx_tmp;
HXDLIN( 723)		if (this->ws1->fluidEnabled) {
HXLINE( 723)			_hx_tmp = hx::IsNotNull( this->ws1->fluidProperties->wrap_gravity );
            		}
            		else {
HXLINE( 723)			_hx_tmp = false;
            		}
HXDLIN( 723)		if (_hx_tmp) {
HXLINE( 724)			g1x = this->ws1->fluidProperties->gravityx;
HXLINE( 725)			g1y = this->ws1->fluidProperties->gravityy;
            		}
            		else {
HXLINE( 744)			g1x = s->gravityx;
HXLINE( 745)			g1y = s->gravityy;
            		}
HXLINE( 763)		Float g2x = ((Float)0.0);
HXLINE( 764)		Float g2y = ((Float)0.0);
HXLINE( 765)		bool _hx_tmp1;
HXDLIN( 765)		if (this->ws2->fluidEnabled) {
HXLINE( 765)			_hx_tmp1 = hx::IsNotNull( this->ws2->fluidProperties->wrap_gravity );
            		}
            		else {
HXLINE( 765)			_hx_tmp1 = false;
            		}
HXDLIN( 765)		if (_hx_tmp1) {
HXLINE( 766)			g2x = this->ws2->fluidProperties->gravityx;
HXLINE( 767)			g2y = this->ws2->fluidProperties->gravityy;
            		}
            		else {
HXLINE( 786)			g2x = s->gravityx;
HXLINE( 787)			g2y = s->gravityy;
            		}
HXLINE( 805)		Float buoyx = ( (Float)(0) );
HXLINE( 806)		Float buoyy = ( (Float)(0) );
HXLINE( 823)		bool _hx_tmp2;
HXDLIN( 823)		if (this->ws1->fluidEnabled) {
HXLINE( 823)			_hx_tmp2 = this->ws2->fluidEnabled;
            		}
            		else {
HXLINE( 823)			_hx_tmp2 = false;
            		}
HXDLIN( 823)		if (_hx_tmp2) {
HXLINE( 824)			Float mass1 = (this->overlap * this->ws1->fluidProperties->density);
HXLINE( 825)			Float mass2 = (this->overlap * this->ws2->fluidProperties->density);
HXLINE( 826)			if ((mass1 > mass2)) {
HXLINE( 827)				Float t = (mass1 + mass2);
HXLINE( 836)				buoyx = (buoyx - (g1x * t));
HXLINE( 837)				buoyy = (buoyy - (g1y * t));
            			}
            			else {
HXLINE( 839)				if ((mass1 < mass2)) {
HXLINE( 840)					Float t1 = (mass1 + mass2);
HXLINE( 849)					buoyx = (buoyx + (g2x * t1));
HXLINE( 850)					buoyy = (buoyy + (g2y * t1));
            				}
            				else {
HXLINE( 853)					Float gx = ((Float)0.0);
HXLINE( 854)					Float gy = ((Float)0.0);
HXLINE( 855)					{
HXLINE( 856)						gx = (g1x + g2x);
HXLINE( 857)						gy = (g1y + g2y);
            					}
HXLINE( 859)					{
HXLINE( 860)						Float t2 = ((Float)0.5);
HXLINE( 869)						gx = (gx * t2);
HXLINE( 870)						gy = (gy * t2);
            					}
HXLINE( 872)					if ((((this->ws1->worldCOMx * gx) + (this->ws1->worldCOMy * gy)) > ((this->ws2->worldCOMx * gx) + (this->ws2->worldCOMy * gy)))) {
HXLINE( 873)						Float t3 = (mass1 + mass2);
HXLINE( 882)						buoyx = (buoyx - (gx * t3));
HXLINE( 883)						buoyy = (buoyy - (gy * t3));
            					}
            					else {
HXLINE( 886)						Float t4 = (mass1 + mass2);
HXLINE( 895)						buoyx = (buoyx + (gx * t4));
HXLINE( 896)						buoyy = (buoyy + (gy * t4));
            					}
            				}
            			}
            		}
            		else {
HXLINE( 900)			if (this->ws1->fluidEnabled) {
HXLINE( 901)				Float mass = (this->overlap * this->ws1->fluidProperties->density);
HXLINE( 902)				{
HXLINE( 903)					Float t5 = mass;
HXLINE( 912)					buoyx = (buoyx - (g1x * t5));
HXLINE( 913)					buoyy = (buoyy - (g1y * t5));
            				}
            			}
            			else {
HXLINE( 916)				if (this->ws2->fluidEnabled) {
HXLINE( 917)					Float mass3 = (this->overlap * this->ws2->fluidProperties->density);
HXLINE( 918)					{
HXLINE( 919)						Float t6 = mass3;
HXLINE( 928)						buoyx = (buoyx + (g2x * t6));
HXLINE( 929)						buoyy = (buoyy + (g2y * t6));
            					}
            				}
            			}
            		}
HXLINE( 932)		{
HXLINE( 933)			Float t7 = dt;
HXLINE( 942)			buoyx = (buoyx * t7);
HXLINE( 943)			buoyy = (buoyy * t7);
            		}
HXLINE( 945)		{
HXLINE( 946)			this->buoyx = buoyx;
HXLINE( 947)			this->buoyy = buoyy;
            		}
HXLINE( 965)		if ((this->b1->type == 2)) {
HXLINE( 966)			{
HXLINE( 967)				Float t8 = this->b1->imass;
HXLINE( 976)				 ::zpp_nape::phys::ZPP_Body _hx_tmp3 = this->b1;
HXDLIN( 976)				_hx_tmp3->velx = (_hx_tmp3->velx - (buoyx * t8));
HXLINE( 977)				 ::zpp_nape::phys::ZPP_Body _hx_tmp4 = this->b1;
HXDLIN( 977)				_hx_tmp4->vely = (_hx_tmp4->vely - (buoyy * t8));
            			}
HXLINE( 979)			 ::zpp_nape::phys::ZPP_Body _hx_tmp5 = this->b1;
HXDLIN( 979)			_hx_tmp5->angvel = (_hx_tmp5->angvel - (((buoyy * this->r1x) - (buoyx * this->r1y)) * this->b1->iinertia));
            		}
HXLINE( 981)		if ((this->b2->type == 2)) {
HXLINE( 982)			{
HXLINE( 983)				Float t9 = this->b2->imass;
HXLINE( 992)				 ::zpp_nape::phys::ZPP_Body _hx_tmp6 = this->b2;
HXDLIN( 992)				_hx_tmp6->velx = (_hx_tmp6->velx + (buoyx * t9));
HXLINE( 993)				 ::zpp_nape::phys::ZPP_Body _hx_tmp7 = this->b2;
HXDLIN( 993)				_hx_tmp7->vely = (_hx_tmp7->vely + (buoyy * t9));
            			}
HXLINE( 995)			 ::zpp_nape::phys::ZPP_Body _hx_tmp8 = this->b2;
HXDLIN( 995)			_hx_tmp8->angvel = (_hx_tmp8->angvel + (((buoyy * this->r2x) - (buoyx * this->r2y)) * this->b2->iinertia));
            		}
HXLINE( 997)		bool _hx_tmp9;
HXDLIN( 997)		bool _hx_tmp10;
HXDLIN( 997)		if (!(!(this->ws1->fluidEnabled))) {
HXLINE( 997)			_hx_tmp10 = (this->ws1->fluidProperties->viscosity == 0);
            		}
            		else {
HXLINE( 997)			_hx_tmp10 = true;
            		}
HXDLIN( 997)		if (_hx_tmp10) {
HXLINE( 997)			if (!(!(this->ws2->fluidEnabled))) {
HXLINE( 997)				_hx_tmp9 = (this->ws2->fluidProperties->viscosity == 0);
            			}
            			else {
HXLINE( 997)				_hx_tmp9 = true;
            			}
            		}
            		else {
HXLINE( 997)			_hx_tmp9 = false;
            		}
HXDLIN( 997)		if (_hx_tmp9) {
HXLINE( 998)			this->nodrag = true;
HXLINE( 999)			{
HXLINE(1000)				this->dampx = ( (Float)(0) );
HXLINE(1001)				this->dampy = ( (Float)(0) );
            			}
HXLINE(1019)			this->adamp = ( (Float)(0) );
            		}
            		else {
HXLINE(1022)			this->nodrag = false;
HXLINE(1023)			Float tViscosity = ((Float)0.0);
HXLINE(1024)			if (this->ws1->fluidEnabled) {
HXLINE(1025)				this->ws2->validate_angDrag();
HXLINE(1026)				tViscosity = (tViscosity + (((this->ws1->fluidProperties->viscosity * this->ws2->angDrag) * this->overlap) / this->ws2->area));
            			}
HXLINE(1028)			if (this->ws2->fluidEnabled) {
HXLINE(1029)				this->ws1->validate_angDrag();
HXLINE(1030)				tViscosity = (tViscosity + (((this->ws2->fluidProperties->viscosity * this->ws1->angDrag) * this->overlap) / this->ws1->area));
            			}
HXLINE(1032)			if ((tViscosity != 0)) {
HXLINE(1033)				Float iSum = (this->b1->sinertia + this->b2->sinertia);
HXLINE(1034)				if ((iSum != 0)) {
HXLINE(1034)					this->wMass = (( (Float)(1) ) / iSum);
            				}
            				else {
HXLINE(1035)					this->wMass = ((Float)0.0);
            				}
HXLINE(1037)				tViscosity = (tViscosity * ((Float)0.0004));
HXLINE(1038)				 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp11 = hx::ObjectPtr<OBJ_>(this);
HXLINE(1039)				Float omega = ((( (Float)(2) ) * ::Math_obj::PI) * tViscosity);
HXLINE(1040)				this->agamma = (( (Float)(1) ) / ((dt * omega) * (2 + (omega * dt))));
HXLINE(1041)				Float ig = (( (Float)(1) ) / (1 + this->agamma));
HXLINE(1036)				Float biasCoef = (((dt * omega) * omega) * this->agamma);
HXLINE(1043)				 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp12 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1043)				_hx_tmp12->agamma = (_hx_tmp12->agamma * ig);
HXLINE(1038)				_hx_tmp11->wMass = (_hx_tmp11->wMass * ig);
            			}
            			else {
HXLINE(1048)				this->wMass = ((Float)0.0);
HXLINE(1049)				this->agamma = ((Float)0.0);
            			}
HXLINE(1051)			Float vrnx = (((this->b2->velx + this->b2->kinvelx) - (this->r2y * (this->b2->angvel + this->b2->kinangvel))) - ((this->b1->velx + this->b1->kinvelx) - (this->r1y * (this->b2->angvel + this->b2->kinangvel))));
HXLINE(1052)			Float vrny = (((this->b2->vely + this->b2->kinvely) + (this->r2x * (this->b2->angvel + this->b2->kinangvel))) - ((this->b1->vely + this->b1->kinvely) + (this->r1x * (this->b1->angvel + this->b1->kinangvel))));
HXLINE(1069)			if (!((((vrnx * vrnx) + (vrny * vrny)) < (::nape::Config_obj::epsilon * ::nape::Config_obj::epsilon)))) {
HXLINE(1071)				{
HXLINE(1072)					Float d = ((vrnx * vrnx) + (vrny * vrny));
HXLINE(1081)					Float imag = (((Float)1.0) / ::Math_obj::sqrt(d));
HXLINE(1082)					{
HXLINE(1083)						Float t10 = imag;
HXLINE(1092)						vrnx = (vrnx * t10);
HXLINE(1093)						vrny = (vrny * t10);
            					}
            				}
HXLINE(1096)				{
HXLINE(1097)					this->nx = vrnx;
HXLINE(1098)					this->ny = vrny;
            				}
            			}
HXLINE(1117)			Float tViscosity1 = ((Float)0.0);
HXLINE(1118)			if (this->ws1->fluidEnabled) {
HXLINE(1119)				Float f = ((-(this->ws1->fluidProperties->viscosity) * this->overlap) / this->ws2->area);
HXLINE(1120)				if ((this->ws2->type == 0)) {
HXLINE(1120)					tViscosity1 = (tViscosity1 - (((f * this->ws2->circle->radius) * ::nape::Config_obj::fluidLinearDrag) / ((( (Float)(2) ) * this->ws2->circle->radius) * ::Math_obj::PI)));
            				}
            				else {
HXLINE(1122)					 ::zpp_nape::shape::ZPP_Polygon poly = this->ws2->polygon;
HXLINE(1123)					Float bord = ((Float)0.0);
HXLINE(1124)					Float acc = ((Float)0.0);
HXLINE(1125)					{
HXLINE(1126)						 ::zpp_nape::util::ZNPNode_ZPP_Edge cx_ite = poly->edges->head;
HXLINE(1127)						while(hx::IsNotNull( cx_ite )){
HXLINE(1128)							 ::zpp_nape::shape::ZPP_Edge ex = cx_ite->elt;
HXLINE(1129)							{
HXLINE(1130)								bord = (bord + ex->length);
HXLINE(1131)								Float fact = ((f * ex->length) * ((ex->gnormx * this->nx) + (ex->gnormy * this->ny)));
HXLINE(1132)								if ((fact > 0)) {
HXLINE(1132)									fact = (fact * -(::nape::Config_obj::fluidVacuumDrag));
HXDLIN(1132)									fact = fact;
            								}
HXLINE(1133)								acc = (acc - ((fact * ((Float)0.5)) * ::nape::Config_obj::fluidLinearDrag));
            							}
HXLINE(1135)							cx_ite = cx_ite->next;
            						}
            					}
HXLINE(1138)					tViscosity1 = (tViscosity1 + (acc / bord));
            				}
            			}
HXLINE(1141)			if (this->ws2->fluidEnabled) {
HXLINE(1142)				Float f1 = ((-(this->ws2->fluidProperties->viscosity) * this->overlap) / this->ws1->area);
HXLINE(1143)				if ((this->ws1->type == 0)) {
HXLINE(1143)					tViscosity1 = (tViscosity1 - (((f1 * this->ws1->circle->radius) * ::nape::Config_obj::fluidLinearDrag) / ((( (Float)(2) ) * this->ws1->circle->radius) * ::Math_obj::PI)));
            				}
            				else {
HXLINE(1145)					 ::zpp_nape::shape::ZPP_Polygon poly1 = this->ws1->polygon;
HXLINE(1146)					Float bord1 = ((Float)0.0);
HXLINE(1147)					Float acc1 = ((Float)0.0);
HXLINE(1148)					{
HXLINE(1149)						 ::zpp_nape::util::ZNPNode_ZPP_Edge cx_ite1 = poly1->edges->head;
HXLINE(1150)						while(hx::IsNotNull( cx_ite1 )){
HXLINE(1151)							 ::zpp_nape::shape::ZPP_Edge ex1 = cx_ite1->elt;
HXLINE(1152)							{
HXLINE(1153)								bord1 = (bord1 + ex1->length);
HXLINE(1154)								Float fact1 = ((f1 * ex1->length) * ((ex1->gnormx * this->nx) + (ex1->gnormy * this->ny)));
HXLINE(1155)								if ((fact1 > 0)) {
HXLINE(1155)									fact1 = (fact1 * -(::nape::Config_obj::fluidVacuumDrag));
HXDLIN(1155)									fact1 = fact1;
            								}
HXLINE(1156)								acc1 = (acc1 - ((fact1 * ((Float)0.5)) * ::nape::Config_obj::fluidLinearDrag));
            							}
HXLINE(1158)							cx_ite1 = cx_ite1->next;
            						}
            					}
HXLINE(1161)					tViscosity1 = (tViscosity1 + (acc1 / bord1));
            				}
            			}
HXLINE(1164)			if ((tViscosity1 != 0)) {
HXLINE(1165)				Float m = (this->b1->smass + this->b2->smass);
HXLINE(1166)				Float Ka = ((Float)0.0);
HXLINE(1167)				Float Kb = ((Float)0.0);
HXLINE(1168)				Float Kc = ((Float)0.0);
HXLINE(1169)				{
HXLINE(1170)					Ka = m;
HXLINE(1171)					Kb = ( (Float)(0) );
HXLINE(1172)					Kc = m;
            				}
HXLINE(1174)				if ((this->b1->sinertia != 0)) {
HXLINE(1175)					Float X = (this->r1x * this->b1->sinertia);
HXLINE(1176)					Float Y = (this->r1y * this->b1->sinertia);
HXLINE(1177)					{
HXLINE(1178)						Ka = (Ka + (Y * this->r1y));
HXLINE(1179)						Kb = (Kb + (-(Y) * this->r1x));
HXLINE(1180)						Kc = (Kc + (X * this->r1x));
            					}
            				}
HXLINE(1183)				if ((this->b2->sinertia != 0)) {
HXLINE(1184)					Float X1 = (this->r2x * this->b2->sinertia);
HXLINE(1185)					Float Y1 = (this->r2y * this->b2->sinertia);
HXLINE(1186)					{
HXLINE(1187)						Ka = (Ka + (Y1 * this->r2y));
HXLINE(1188)						Kb = (Kb + (-(Y1) * this->r2x));
HXLINE(1189)						Kc = (Kc + (X1 * this->r2x));
            					}
            				}
HXLINE(1192)				{
HXLINE(1193)					Float det = ((Ka * Kc) - (Kb * Kb));
HXLINE(1194)					if ((det != det)) {
HXLINE(1195)						Kc = ( (Float)(0) );
HXDLIN(1195)						Kb = Kc;
HXDLIN(1195)						Ka = Kb;
            					}
            					else {
HXLINE(1198)						if ((det == 0)) {
HXLINE(1199)							int flag = 0;
HXLINE(1200)							if ((Ka != 0)) {
HXLINE(1200)								Ka = (( (Float)(1) ) / Ka);
            							}
            							else {
HXLINE(1202)								Ka = ( (Float)(0) );
HXLINE(1203)								flag = (flag | 1);
            							}
HXLINE(1205)							if ((Kc != 0)) {
HXLINE(1205)								Kc = (( (Float)(1) ) / Kc);
            							}
            							else {
HXLINE(1207)								Kc = ( (Float)(0) );
HXLINE(1208)								flag = (flag | 2);
            							}
HXLINE(1210)							Kb = ( (Float)(0) );
            						}
            						else {
HXLINE(1214)							det = (( (Float)(1) ) / det);
HXLINE(1215)							Float t11 = (Kc * det);
HXLINE(1216)							Kc = (Ka * det);
HXLINE(1217)							Ka = t11;
HXLINE(1218)							Kb = (Kb * -(det));
            						}
            					}
            				}
HXLINE(1222)				{
HXLINE(1223)					this->vMassa = Ka;
HXLINE(1224)					this->vMassb = Kb;
HXLINE(1225)					this->vMassc = Kc;
            				}
HXLINE(1227)				Float biasCoef1;
HXLINE(1228)				{
HXLINE(1230)					Float omega1 = ((( (Float)(2) ) * ::Math_obj::PI) * tViscosity1);
HXLINE(1231)					this->lgamma = (( (Float)(1) ) / ((dt * omega1) * (2 + (omega1 * dt))));
HXLINE(1232)					Float ig1 = (( (Float)(1) ) / (1 + this->lgamma));
HXLINE(1233)					biasCoef1 = (((dt * omega1) * omega1) * this->lgamma);
HXLINE(1234)					 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp13 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1234)					_hx_tmp13->lgamma = (_hx_tmp13->lgamma * ig1);
HXLINE(1229)					Float X2 = ig1;
HXLINE(1237)					 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp14 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1237)					_hx_tmp14->vMassa = (_hx_tmp14->vMassa * X2);
HXLINE(1238)					 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp15 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1238)					_hx_tmp15->vMassb = (_hx_tmp15->vMassb * X2);
HXLINE(1239)					 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp16 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1239)					_hx_tmp16->vMassc = (_hx_tmp16->vMassc * X2);
            				}
            			}
            			else {
HXLINE(1243)				{
HXLINE(1244)					this->vMassa = ( (Float)(0) );
HXLINE(1245)					this->vMassb = ( (Float)(0) );
HXLINE(1246)					this->vMassc = ( (Float)(0) );
            				}
HXLINE(1248)				this->lgamma = ((Float)0.0);
            			}
            		}
HXLINE(1251)		{
HXLINE(1252)			Float t12 = dtratio;
HXLINE(1261)			 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp17 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1261)			_hx_tmp17->dampx = (_hx_tmp17->dampx * t12);
HXLINE(1262)			 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp18 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1262)			_hx_tmp18->dampy = (_hx_tmp18->dampy * t12);
            		}
HXLINE(1264)		 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp19 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1264)		_hx_tmp19->adamp = (_hx_tmp19->adamp * dtratio);
            	}


HX_DEFINE_DYNAMIC_FUNC2(ZPP_FluidArbiter_obj,preStep,(void))

void ZPP_FluidArbiter_obj::warmStart(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_1268_warmStart)
HXLINE(1269)		{
HXLINE(1270)			Float t = this->b1->imass;
HXLINE(1279)			 ::zpp_nape::phys::ZPP_Body _hx_tmp = this->b1;
HXDLIN(1279)			_hx_tmp->velx = (_hx_tmp->velx - (this->dampx * t));
HXLINE(1280)			 ::zpp_nape::phys::ZPP_Body _hx_tmp1 = this->b1;
HXDLIN(1280)			_hx_tmp1->vely = (_hx_tmp1->vely - (this->dampy * t));
            		}
HXLINE(1282)		{
HXLINE(1283)			Float t1 = this->b2->imass;
HXLINE(1292)			 ::zpp_nape::phys::ZPP_Body _hx_tmp2 = this->b2;
HXDLIN(1292)			_hx_tmp2->velx = (_hx_tmp2->velx + (this->dampx * t1));
HXLINE(1293)			 ::zpp_nape::phys::ZPP_Body _hx_tmp3 = this->b2;
HXDLIN(1293)			_hx_tmp3->vely = (_hx_tmp3->vely + (this->dampy * t1));
            		}
HXLINE(1295)		 ::zpp_nape::phys::ZPP_Body _hx_tmp4 = this->b1;
HXDLIN(1295)		_hx_tmp4->angvel = (_hx_tmp4->angvel - (this->b1->iinertia * ((this->dampy * this->r1x) - (this->dampx * this->r1y))));
HXLINE(1296)		 ::zpp_nape::phys::ZPP_Body _hx_tmp5 = this->b2;
HXDLIN(1296)		_hx_tmp5->angvel = (_hx_tmp5->angvel + (this->b2->iinertia * ((this->dampy * this->r2x) - (this->dampx * this->r2y))));
HXLINE(1297)		 ::zpp_nape::phys::ZPP_Body _hx_tmp6 = this->b1;
HXDLIN(1297)		_hx_tmp6->angvel = (_hx_tmp6->angvel - (this->adamp * this->b1->iinertia));
HXLINE(1298)		 ::zpp_nape::phys::ZPP_Body _hx_tmp7 = this->b2;
HXDLIN(1298)		_hx_tmp7->angvel = (_hx_tmp7->angvel + (this->adamp * this->b2->iinertia));
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,warmStart,(void))

void ZPP_FluidArbiter_obj::applyImpulseVel(){
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_1303_applyImpulseVel)
HXDLIN(1303)		if (!(this->nodrag)) {
HXLINE(1304)			Float w1 = (this->b1->angvel + this->b1->kinangvel);
HXLINE(1305)			Float w2 = (this->b2->angvel + this->b2->kinangvel);
HXLINE(1306)			Float jx = (((this->b1->velx + this->b1->kinvelx) - (this->r1y * w1)) - ((this->b2->velx + this->b2->kinvelx) - (this->r2y * w2)));
HXLINE(1307)			Float jy = (((this->b1->vely + this->b1->kinvely) + (this->r1x * w1)) - ((this->b2->vely + this->b2->kinvely) + (this->r2x * w2)));
HXLINE(1324)			{
HXLINE(1325)				Float t = ((this->vMassa * jx) + (this->vMassb * jy));
HXLINE(1326)				jy = ((this->vMassb * jx) + (this->vMassc * jy));
HXLINE(1327)				jx = t;
            			}
HXLINE(1329)			{
HXLINE(1330)				Float t1 = this->lgamma;
HXLINE(1339)				jx = (jx - (this->dampx * t1));
HXLINE(1340)				jy = (jy - (this->dampy * t1));
            			}
HXLINE(1342)			{
HXLINE(1343)				Float t2 = ((Float)1.0);
HXLINE(1352)				 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1352)				_hx_tmp->dampx = (_hx_tmp->dampx + (jx * t2));
HXLINE(1353)				 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1353)				_hx_tmp1->dampy = (_hx_tmp1->dampy + (jy * t2));
            			}
HXLINE(1355)			{
HXLINE(1356)				Float t3 = this->b1->imass;
HXLINE(1365)				 ::zpp_nape::phys::ZPP_Body _hx_tmp2 = this->b1;
HXDLIN(1365)				_hx_tmp2->velx = (_hx_tmp2->velx - (jx * t3));
HXLINE(1366)				 ::zpp_nape::phys::ZPP_Body _hx_tmp3 = this->b1;
HXDLIN(1366)				_hx_tmp3->vely = (_hx_tmp3->vely - (jy * t3));
            			}
HXLINE(1368)			{
HXLINE(1369)				Float t4 = this->b2->imass;
HXLINE(1378)				 ::zpp_nape::phys::ZPP_Body _hx_tmp4 = this->b2;
HXDLIN(1378)				_hx_tmp4->velx = (_hx_tmp4->velx + (jx * t4));
HXLINE(1379)				 ::zpp_nape::phys::ZPP_Body _hx_tmp5 = this->b2;
HXDLIN(1379)				_hx_tmp5->vely = (_hx_tmp5->vely + (jy * t4));
            			}
HXLINE(1381)			 ::zpp_nape::phys::ZPP_Body _hx_tmp6 = this->b1;
HXDLIN(1381)			_hx_tmp6->angvel = (_hx_tmp6->angvel - (this->b1->iinertia * ((jy * this->r1x) - (jx * this->r1y))));
HXLINE(1382)			 ::zpp_nape::phys::ZPP_Body _hx_tmp7 = this->b2;
HXDLIN(1382)			_hx_tmp7->angvel = (_hx_tmp7->angvel + (this->b2->iinertia * ((jy * this->r2x) - (jx * this->r2y))));
HXLINE(1383)			Float j_damp = (((w1 - w2) * this->wMass) - (this->adamp * this->agamma));
HXLINE(1384)			 ::zpp_nape::dynamics::ZPP_FluidArbiter _hx_tmp8 = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1384)			_hx_tmp8->adamp = (_hx_tmp8->adamp + j_damp);
HXLINE(1385)			 ::zpp_nape::phys::ZPP_Body _hx_tmp9 = this->b1;
HXDLIN(1385)			_hx_tmp9->angvel = (_hx_tmp9->angvel - (j_damp * this->b1->iinertia));
HXLINE(1386)			 ::zpp_nape::phys::ZPP_Body _hx_tmp10 = this->b2;
HXDLIN(1386)			_hx_tmp10->angvel = (_hx_tmp10->angvel + (j_damp * this->b2->iinertia));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_FluidArbiter_obj,applyImpulseVel,(void))

 ::zpp_nape::dynamics::ZPP_FluidArbiter ZPP_FluidArbiter_obj::zpp_pool;


hx::ObjectPtr< ZPP_FluidArbiter_obj > ZPP_FluidArbiter_obj::__new() {
	hx::ObjectPtr< ZPP_FluidArbiter_obj > __this = new ZPP_FluidArbiter_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< ZPP_FluidArbiter_obj > ZPP_FluidArbiter_obj::__alloc(hx::Ctx *_hx_ctx) {
	ZPP_FluidArbiter_obj *__this = (ZPP_FluidArbiter_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ZPP_FluidArbiter_obj), true, "zpp_nape.dynamics.ZPP_FluidArbiter"));
	*(void **)__this = ZPP_FluidArbiter_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ZPP_FluidArbiter_obj::ZPP_FluidArbiter_obj()
{
}

void ZPP_FluidArbiter_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ZPP_FluidArbiter);
	HX_MARK_MEMBER_NAME(outer_zn,"outer_zn");
	HX_MARK_MEMBER_NAME(next,"next");
	HX_MARK_MEMBER_NAME(centroidx,"centroidx");
	HX_MARK_MEMBER_NAME(centroidy,"centroidy");
	HX_MARK_MEMBER_NAME(overlap,"overlap");
	HX_MARK_MEMBER_NAME(r1x,"r1x");
	HX_MARK_MEMBER_NAME(r1y,"r1y");
	HX_MARK_MEMBER_NAME(r2x,"r2x");
	HX_MARK_MEMBER_NAME(r2y,"r2y");
	HX_MARK_MEMBER_NAME(nodrag,"nodrag");
	HX_MARK_MEMBER_NAME(wMass,"wMass");
	HX_MARK_MEMBER_NAME(adamp,"adamp");
	HX_MARK_MEMBER_NAME(agamma,"agamma");
	HX_MARK_MEMBER_NAME(vMassa,"vMassa");
	HX_MARK_MEMBER_NAME(vMassb,"vMassb");
	HX_MARK_MEMBER_NAME(vMassc,"vMassc");
	HX_MARK_MEMBER_NAME(dampx,"dampx");
	HX_MARK_MEMBER_NAME(dampy,"dampy");
	HX_MARK_MEMBER_NAME(lgamma,"lgamma");
	HX_MARK_MEMBER_NAME(nx,"nx");
	HX_MARK_MEMBER_NAME(ny,"ny");
	HX_MARK_MEMBER_NAME(buoyx,"buoyx");
	HX_MARK_MEMBER_NAME(buoyy,"buoyy");
	HX_MARK_MEMBER_NAME(wrap_position,"wrap_position");
	HX_MARK_MEMBER_NAME(_hx_mutable,"mutable");
	HX_MARK_MEMBER_NAME(pre_dt,"pre_dt");
	 ::zpp_nape::dynamics::ZPP_Arbiter_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ZPP_FluidArbiter_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(outer_zn,"outer_zn");
	HX_VISIT_MEMBER_NAME(next,"next");
	HX_VISIT_MEMBER_NAME(centroidx,"centroidx");
	HX_VISIT_MEMBER_NAME(centroidy,"centroidy");
	HX_VISIT_MEMBER_NAME(overlap,"overlap");
	HX_VISIT_MEMBER_NAME(r1x,"r1x");
	HX_VISIT_MEMBER_NAME(r1y,"r1y");
	HX_VISIT_MEMBER_NAME(r2x,"r2x");
	HX_VISIT_MEMBER_NAME(r2y,"r2y");
	HX_VISIT_MEMBER_NAME(nodrag,"nodrag");
	HX_VISIT_MEMBER_NAME(wMass,"wMass");
	HX_VISIT_MEMBER_NAME(adamp,"adamp");
	HX_VISIT_MEMBER_NAME(agamma,"agamma");
	HX_VISIT_MEMBER_NAME(vMassa,"vMassa");
	HX_VISIT_MEMBER_NAME(vMassb,"vMassb");
	HX_VISIT_MEMBER_NAME(vMassc,"vMassc");
	HX_VISIT_MEMBER_NAME(dampx,"dampx");
	HX_VISIT_MEMBER_NAME(dampy,"dampy");
	HX_VISIT_MEMBER_NAME(lgamma,"lgamma");
	HX_VISIT_MEMBER_NAME(nx,"nx");
	HX_VISIT_MEMBER_NAME(ny,"ny");
	HX_VISIT_MEMBER_NAME(buoyx,"buoyx");
	HX_VISIT_MEMBER_NAME(buoyy,"buoyy");
	HX_VISIT_MEMBER_NAME(wrap_position,"wrap_position");
	HX_VISIT_MEMBER_NAME(_hx_mutable,"mutable");
	HX_VISIT_MEMBER_NAME(pre_dt,"pre_dt");
	 ::zpp_nape::dynamics::ZPP_Arbiter_obj::__Visit(HX_VISIT_ARG);
}

hx::Val ZPP_FluidArbiter_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"nx") ) { return hx::Val( nx ); }
		if (HX_FIELD_EQ(inName,"ny") ) { return hx::Val( ny ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"r1x") ) { return hx::Val( r1x ); }
		if (HX_FIELD_EQ(inName,"r1y") ) { return hx::Val( r1y ); }
		if (HX_FIELD_EQ(inName,"r2x") ) { return hx::Val( r2x ); }
		if (HX_FIELD_EQ(inName,"r2y") ) { return hx::Val( r2y ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"next") ) { return hx::Val( next ); }
		if (HX_FIELD_EQ(inName,"free") ) { return hx::Val( free_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"alloc") ) { return hx::Val( alloc_dyn() ); }
		if (HX_FIELD_EQ(inName,"wMass") ) { return hx::Val( wMass ); }
		if (HX_FIELD_EQ(inName,"adamp") ) { return hx::Val( adamp ); }
		if (HX_FIELD_EQ(inName,"dampx") ) { return hx::Val( dampx ); }
		if (HX_FIELD_EQ(inName,"dampy") ) { return hx::Val( dampy ); }
		if (HX_FIELD_EQ(inName,"buoyx") ) { return hx::Val( buoyx ); }
		if (HX_FIELD_EQ(inName,"buoyy") ) { return hx::Val( buoyy ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"nodrag") ) { return hx::Val( nodrag ); }
		if (HX_FIELD_EQ(inName,"agamma") ) { return hx::Val( agamma ); }
		if (HX_FIELD_EQ(inName,"vMassa") ) { return hx::Val( vMassa ); }
		if (HX_FIELD_EQ(inName,"vMassb") ) { return hx::Val( vMassb ); }
		if (HX_FIELD_EQ(inName,"vMassc") ) { return hx::Val( vMassc ); }
		if (HX_FIELD_EQ(inName,"lgamma") ) { return hx::Val( lgamma ); }
		if (HX_FIELD_EQ(inName,"assign") ) { return hx::Val( assign_dyn() ); }
		if (HX_FIELD_EQ(inName,"retire") ) { return hx::Val( retire_dyn() ); }
		if (HX_FIELD_EQ(inName,"inject") ) { return hx::Val( inject_dyn() ); }
		if (HX_FIELD_EQ(inName,"pre_dt") ) { return hx::Val( pre_dt ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"overlap") ) { return hx::Val( overlap ); }
		if (HX_FIELD_EQ(inName,"mutable") ) { return hx::Val( _hx_mutable ); }
		if (HX_FIELD_EQ(inName,"preStep") ) { return hx::Val( preStep_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"outer_zn") ) { return hx::Val( outer_zn ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"centroidx") ) { return hx::Val( centroidx ); }
		if (HX_FIELD_EQ(inName,"centroidy") ) { return hx::Val( centroidy ); }
		if (HX_FIELD_EQ(inName,"warmStart") ) { return hx::Val( warmStart_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getposition") ) { return hx::Val( getposition_dyn() ); }
		if (HX_FIELD_EQ(inName,"makemutable") ) { return hx::Val( makemutable_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"wrap_position") ) { return hx::Val( wrap_position ); }
		if (HX_FIELD_EQ(inName,"makeimmutable") ) { return hx::Val( makeimmutable_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"applyImpulseVel") ) { return hx::Val( applyImpulseVel_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"position_validate") ) { return hx::Val( position_validate_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"position_invalidate") ) { return hx::Val( position_invalidate_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ZPP_FluidArbiter_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"zpp_pool") ) { outValue = ( zpp_pool ); return true; }
	}
	return false;
}

hx::Val ZPP_FluidArbiter_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"nx") ) { nx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ny") ) { ny=inValue.Cast< Float >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"r1x") ) { r1x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"r1y") ) { r1y=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"r2x") ) { r2x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"r2y") ) { r2y=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"next") ) { next=inValue.Cast<  ::zpp_nape::dynamics::ZPP_FluidArbiter >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"wMass") ) { wMass=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"adamp") ) { adamp=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dampx") ) { dampx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dampy") ) { dampy=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"buoyx") ) { buoyx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"buoyy") ) { buoyy=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"nodrag") ) { nodrag=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"agamma") ) { agamma=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vMassa") ) { vMassa=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vMassb") ) { vMassb=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vMassc") ) { vMassc=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lgamma") ) { lgamma=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pre_dt") ) { pre_dt=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"overlap") ) { overlap=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mutable") ) { _hx_mutable=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"outer_zn") ) { outer_zn=inValue.Cast<  ::nape::dynamics::FluidArbiter >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"centroidx") ) { centroidx=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"centroidy") ) { centroidy=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"wrap_position") ) { wrap_position=inValue.Cast<  ::nape::geom::Vec2 >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ZPP_FluidArbiter_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"zpp_pool") ) { zpp_pool=ioValue.Cast<  ::zpp_nape::dynamics::ZPP_FluidArbiter >(); return true; }
	}
	return false;
}

void ZPP_FluidArbiter_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("outer_zn",38,07,b0,a2));
	outFields->push(HX_("next",f3,84,02,49));
	outFields->push(HX_("centroidx",38,58,3e,51));
	outFields->push(HX_("centroidy",39,58,3e,51));
	outFields->push(HX_("overlap",87,43,10,a9));
	outFields->push(HX_("r1x",19,ac,56,00));
	outFields->push(HX_("r1y",1a,ac,56,00));
	outFields->push(HX_("r2x",f8,ac,56,00));
	outFields->push(HX_("r2y",f9,ac,56,00));
	outFields->push(HX_("nodrag",b5,40,2c,27));
	outFields->push(HX_("wMass",0b,75,de,b7));
	outFields->push(HX_("adamp",01,95,41,1c));
	outFields->push(HX_("agamma",26,87,54,57));
	outFields->push(HX_("vMassa",97,98,6c,c4));
	outFields->push(HX_("vMassb",98,98,6c,c4));
	outFields->push(HX_("vMassc",99,98,6c,c4));
	outFields->push(HX_("dampx",58,cc,82,d4));
	outFields->push(HX_("dampy",59,cc,82,d4));
	outFields->push(HX_("lgamma",3b,7f,41,bd));
	outFields->push(HX_("nx",4a,60,00,00));
	outFields->push(HX_("ny",4b,60,00,00));
	outFields->push(HX_("buoyx",1b,74,ef,ba));
	outFields->push(HX_("buoyy",1c,74,ef,ba));
	outFields->push(HX_("wrap_position",fe,d4,24,bb));
	outFields->push(HX_("mutable",a6,7f,48,87));
	outFields->push(HX_("pre_dt",6c,85,b1,ae));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo ZPP_FluidArbiter_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::nape::dynamics::FluidArbiter */ ,(int)offsetof(ZPP_FluidArbiter_obj,outer_zn),HX_("outer_zn",38,07,b0,a2)},
	{hx::fsObject /*  ::zpp_nape::dynamics::ZPP_FluidArbiter */ ,(int)offsetof(ZPP_FluidArbiter_obj,next),HX_("next",f3,84,02,49)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,centroidx),HX_("centroidx",38,58,3e,51)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,centroidy),HX_("centroidy",39,58,3e,51)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,overlap),HX_("overlap",87,43,10,a9)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,r1x),HX_("r1x",19,ac,56,00)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,r1y),HX_("r1y",1a,ac,56,00)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,r2x),HX_("r2x",f8,ac,56,00)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,r2y),HX_("r2y",f9,ac,56,00)},
	{hx::fsBool,(int)offsetof(ZPP_FluidArbiter_obj,nodrag),HX_("nodrag",b5,40,2c,27)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,wMass),HX_("wMass",0b,75,de,b7)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,adamp),HX_("adamp",01,95,41,1c)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,agamma),HX_("agamma",26,87,54,57)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,vMassa),HX_("vMassa",97,98,6c,c4)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,vMassb),HX_("vMassb",98,98,6c,c4)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,vMassc),HX_("vMassc",99,98,6c,c4)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,dampx),HX_("dampx",58,cc,82,d4)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,dampy),HX_("dampy",59,cc,82,d4)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,lgamma),HX_("lgamma",3b,7f,41,bd)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,nx),HX_("nx",4a,60,00,00)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,ny),HX_("ny",4b,60,00,00)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,buoyx),HX_("buoyx",1b,74,ef,ba)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,buoyy),HX_("buoyy",1c,74,ef,ba)},
	{hx::fsObject /*  ::nape::geom::Vec2 */ ,(int)offsetof(ZPP_FluidArbiter_obj,wrap_position),HX_("wrap_position",fe,d4,24,bb)},
	{hx::fsBool,(int)offsetof(ZPP_FluidArbiter_obj,_hx_mutable),HX_("mutable",a6,7f,48,87)},
	{hx::fsFloat,(int)offsetof(ZPP_FluidArbiter_obj,pre_dt),HX_("pre_dt",6c,85,b1,ae)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo ZPP_FluidArbiter_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*  ::zpp_nape::dynamics::ZPP_FluidArbiter */ ,(void *) &ZPP_FluidArbiter_obj::zpp_pool,HX_("zpp_pool",81,5d,d4,38)},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String ZPP_FluidArbiter_obj_sMemberFields[] = {
	HX_("outer_zn",38,07,b0,a2),
	HX_("next",f3,84,02,49),
	HX_("alloc",75,a4,93,21),
	HX_("free",ac,9c,c2,43),
	HX_("centroidx",38,58,3e,51),
	HX_("centroidy",39,58,3e,51),
	HX_("overlap",87,43,10,a9),
	HX_("r1x",19,ac,56,00),
	HX_("r1y",1a,ac,56,00),
	HX_("r2x",f8,ac,56,00),
	HX_("r2y",f9,ac,56,00),
	HX_("nodrag",b5,40,2c,27),
	HX_("wMass",0b,75,de,b7),
	HX_("adamp",01,95,41,1c),
	HX_("agamma",26,87,54,57),
	HX_("vMassa",97,98,6c,c4),
	HX_("vMassb",98,98,6c,c4),
	HX_("vMassc",99,98,6c,c4),
	HX_("dampx",58,cc,82,d4),
	HX_("dampy",59,cc,82,d4),
	HX_("lgamma",3b,7f,41,bd),
	HX_("nx",4a,60,00,00),
	HX_("ny",4b,60,00,00),
	HX_("buoyx",1b,74,ef,ba),
	HX_("buoyy",1c,74,ef,ba),
	HX_("position_validate",2c,4a,54,ce),
	HX_("position_invalidate",91,a4,dc,e8),
	HX_("wrap_position",fe,d4,24,bb),
	HX_("getposition",3f,a7,3c,17),
	HX_("assign",2f,46,06,4c),
	HX_("retire",9b,89,24,09),
	HX_("mutable",a6,7f,48,87),
	HX_("makemutable",78,7f,01,fe),
	HX_("makeimmutable",94,40,9d,bd),
	HX_("inject",91,4a,ea,97),
	HX_("pre_dt",6c,85,b1,ae),
	HX_("preStep",0f,c1,c0,24),
	HX_("warmStart",dd,27,03,eb),
	HX_("applyImpulseVel",b6,c7,50,1f),
	::String(null()) };

static void ZPP_FluidArbiter_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ZPP_FluidArbiter_obj::zpp_pool,"zpp_pool");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ZPP_FluidArbiter_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ZPP_FluidArbiter_obj::zpp_pool,"zpp_pool");
};

#endif

hx::Class ZPP_FluidArbiter_obj::__mClass;

static ::String ZPP_FluidArbiter_obj_sStaticFields[] = {
	HX_("zpp_pool",81,5d,d4,38),
	::String(null())
};

void ZPP_FluidArbiter_obj::__register()
{
	ZPP_FluidArbiter_obj _hx_dummy;
	ZPP_FluidArbiter_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("zpp_nape.dynamics.ZPP_FluidArbiter",5d,22,30,11);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ZPP_FluidArbiter_obj::__GetStatic;
	__mClass->mSetStaticField = &ZPP_FluidArbiter_obj::__SetStatic;
	__mClass->mMarkFunc = ZPP_FluidArbiter_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(ZPP_FluidArbiter_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ZPP_FluidArbiter_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ZPP_FluidArbiter_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ZPP_FluidArbiter_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ZPP_FluidArbiter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ZPP_FluidArbiter_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ZPP_FluidArbiter_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_55ad567f8bfbf8c4_449_boot)
HXDLIN( 449)		zpp_pool = null();
            	}
}

} // end namespace zpp_nape
} // end namespace dynamics
