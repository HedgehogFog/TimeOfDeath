// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_constraint_AngleJoint
#include <hxinc/nape/constraint/AngleJoint.h>
#endif
#ifndef INCLUDED_nape_constraint_Constraint
#include <hxinc/nape/constraint/Constraint.h>
#endif
#ifndef INCLUDED_nape_geom_Vec3
#include <hxinc/nape/geom/Vec3.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_util_Debug
#include <hxinc/nape/util/Debug.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_AngleJoint
#include <hxinc/zpp_nape/constraint/ZPP_AngleJoint.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_Constraint
#include <hxinc/zpp_nape/constraint/ZPP_Constraint.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_CopyHelper
#include <hxinc/zpp_nape/constraint/ZPP_CopyHelper.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Component
#include <hxinc/zpp_nape/space/ZPP_Component.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Constraint
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Constraint.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_174_new,"zpp_nape.constraint.ZPP_AngleJoint","new",0xa49c0ade,"zpp_nape.constraint.ZPP_AngleJoint.new","zpp_nape/constraint/AngleJoint.hx",174,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_184_is_slack,"zpp_nape.constraint.ZPP_AngleJoint","is_slack",0x891b1dbd,"zpp_nape.constraint.ZPP_AngleJoint.is_slack","zpp_nape/constraint/AngleJoint.hx",184,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_215_bodyImpulse,"zpp_nape.constraint.ZPP_AngleJoint","bodyImpulse",0x10865eb1,"zpp_nape.constraint.ZPP_AngleJoint.bodyImpulse","zpp_nape/constraint/AngleJoint.hx",215,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_221_activeBodies,"zpp_nape.constraint.ZPP_AngleJoint","activeBodies",0xd17fefa8,"zpp_nape.constraint.ZPP_AngleJoint.activeBodies","zpp_nape/constraint/AngleJoint.hx",221,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_229_inactiveBodies,"zpp_nape.constraint.ZPP_AngleJoint","inactiveBodies",0xf88b838d,"zpp_nape.constraint.ZPP_AngleJoint.inactiveBodies","zpp_nape/constraint/AngleJoint.hx",229,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_245_copy,"zpp_nape.constraint.ZPP_AngleJoint","copy",0x5cafaf77,"zpp_nape.constraint.ZPP_AngleJoint.copy","zpp_nape/constraint/AngleJoint.hx",245,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_266_copy,"zpp_nape.constraint.ZPP_AngleJoint","copy",0x5cafaf77,"zpp_nape.constraint.ZPP_AngleJoint.copy","zpp_nape/constraint/AngleJoint.hx",266,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_287_copy,"zpp_nape.constraint.ZPP_AngleJoint","copy",0x5cafaf77,"zpp_nape.constraint.ZPP_AngleJoint.copy","zpp_nape/constraint/AngleJoint.hx",287,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_300_validate,"zpp_nape.constraint.ZPP_AngleJoint","validate",0xef80cd58,"zpp_nape.constraint.ZPP_AngleJoint.validate","zpp_nape/constraint/AngleJoint.hx",300,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_307_wake_connected,"zpp_nape.constraint.ZPP_AngleJoint","wake_connected",0xa9a3c9f0,"zpp_nape.constraint.ZPP_AngleJoint.wake_connected","zpp_nape/constraint/AngleJoint.hx",307,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_311_forest,"zpp_nape.constraint.ZPP_AngleJoint","forest",0xdfe9751f,"zpp_nape.constraint.ZPP_AngleJoint.forest","zpp_nape/constraint/AngleJoint.hx",311,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_410_pair_exists,"zpp_nape.constraint.ZPP_AngleJoint","pair_exists",0x1a3c531f,"zpp_nape.constraint.ZPP_AngleJoint.pair_exists","zpp_nape/constraint/AngleJoint.hx",410,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_412_clearcache,"zpp_nape.constraint.ZPP_AngleJoint","clearcache",0x0c589ad7,"zpp_nape.constraint.ZPP_AngleJoint.clearcache","zpp_nape/constraint/AngleJoint.hx",412,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_417_preStep,"zpp_nape.constraint.ZPP_AngleJoint","preStep",0x572b128d,"zpp_nape.constraint.ZPP_AngleJoint.preStep","zpp_nape/constraint/AngleJoint.hx",417,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_482_warmStart,"zpp_nape.constraint.ZPP_AngleJoint","warmStart",0x49c354db,"zpp_nape.constraint.ZPP_AngleJoint.warmStart","zpp_nape/constraint/AngleJoint.hx",482,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_493_applyImpulseVel,"zpp_nape.constraint.ZPP_AngleJoint","applyImpulseVel",0x00c5c734,"zpp_nape.constraint.ZPP_AngleJoint.applyImpulseVel","zpp_nape/constraint/AngleJoint.hx",493,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_532_applyImpulsePos,"zpp_nape.constraint.ZPP_AngleJoint","applyImpulsePos",0x00c1426b,"zpp_nape.constraint.ZPP_AngleJoint.applyImpulsePos","zpp_nape/constraint/AngleJoint.hx",532,0x575b2617)
HX_LOCAL_STACK_FRAME(_hx_pos_cb72d1d2a3d570ae_579_draw,"zpp_nape.constraint.ZPP_AngleJoint","draw",0x5d5b1fc6,"zpp_nape.constraint.ZPP_AngleJoint.draw","zpp_nape/constraint/AngleJoint.hx",579,0x575b2617)
namespace zpp_nape{
namespace constraint{

void ZPP_AngleJoint_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_174_new)
HXLINE( 244)		this->stepped = false;
HXLINE( 243)		this->bias = ((Float)0.0);
HXLINE( 242)		this->gamma = ((Float)0.0);
HXLINE( 241)		this->jMax = ((Float)0.0);
HXLINE( 240)		this->jAcc = ((Float)0.0);
HXLINE( 239)		this->kMass = ((Float)0.0);
HXLINE( 238)		this->b2 = null();
HXLINE( 237)		this->b1 = null();
HXLINE( 181)		this->scale = ((Float)0.0);
HXLINE( 180)		this->equal = false;
HXLINE( 179)		this->slack = false;
HXLINE( 178)		this->jointMax = ((Float)0.0);
HXLINE( 177)		this->jointMin = ((Float)0.0);
HXLINE( 176)		this->ratio = ((Float)0.0);
HXLINE( 175)		this->outer_zn = null();
HXLINE( 293)		super::__construct();
HXLINE( 294)		this->ratio = ( (Float)(1) );
HXLINE( 295)		this->jAcc = ( (Float)(0) );
HXLINE( 296)		this->slack = false;
HXLINE( 297)		this->jMax = ::Math_obj::POSITIVE_INFINITY;
HXLINE( 298)		this->stepped = false;
            	}

Dynamic ZPP_AngleJoint_obj::__CreateEmpty() { return new ZPP_AngleJoint_obj; }

void *ZPP_AngleJoint_obj::_hx_vtable = 0;

Dynamic ZPP_AngleJoint_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ZPP_AngleJoint_obj > _hx_result = new ZPP_AngleJoint_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ZPP_AngleJoint_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x77664e06) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x77664e06;
	} else {
		return inClassId==(int)0x7c84a5ec;
	}
}

bool ZPP_AngleJoint_obj::is_slack(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_184_is_slack)
HXLINE( 185)		bool slack;
HXLINE( 186)		{
HXLINE( 187)			Float C = ((this->ratio * this->b2->rot) - this->b1->rot);
HXLINE( 188)			if (this->equal) {
HXLINE( 189)				C = (C - this->jointMax);
HXLINE( 190)				slack = false;
HXLINE( 191)				this->scale = ((Float)1.0);
            			}
            			else {
HXLINE( 194)				if ((C < this->jointMin)) {
HXLINE( 195)					C = (this->jointMin - C);
HXLINE( 196)					this->scale = ((Float)-1.0);
HXLINE( 197)					slack = false;
            				}
            				else {
HXLINE( 199)					if ((C > this->jointMax)) {
HXLINE( 200)						C = (C - this->jointMax);
HXLINE( 201)						this->scale = ((Float)1.0);
HXLINE( 202)						slack = false;
            					}
            					else {
HXLINE( 205)						this->scale = ((Float)0.0);
HXLINE( 206)						C = ( (Float)(0) );
HXLINE( 207)						slack = true;
            					}
            				}
            			}
            		}
HXLINE( 212)		return slack;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ZPP_AngleJoint_obj,is_slack,return )

 ::nape::geom::Vec3 ZPP_AngleJoint_obj::bodyImpulse( ::zpp_nape::phys::ZPP_Body b){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_215_bodyImpulse)
HXDLIN( 215)		if (this->stepped) {
HXLINE( 216)			if (hx::IsEq( b,this->b1 )) {
HXLINE( 216)				return ::nape::geom::Vec3_obj::get(0,0,(-(this->scale) * this->jAcc));
            			}
            			else {
HXLINE( 217)				return ::nape::geom::Vec3_obj::get(0,0,((this->ratio * this->scale) * this->jAcc));
            			}
            		}
            		else {
HXLINE( 219)			return ::nape::geom::Vec3_obj::get(0,0,0);
            		}
HXLINE( 215)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_AngleJoint_obj,bodyImpulse,return )

void ZPP_AngleJoint_obj::activeBodies(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_221_activeBodies)
HXLINE( 223)		if (hx::IsNotNull( this->b1 )) {
HXLINE( 223)			this->b1->constraints->add(hx::ObjectPtr<OBJ_>(this));
            		}
HXLINE( 225)		if (hx::IsNotEq( this->b2,this->b1 )) {
HXLINE( 226)			if (hx::IsNotNull( this->b2 )) {
HXLINE( 226)				this->b2->constraints->add(hx::ObjectPtr<OBJ_>(this));
            			}
            		}
            	}


void ZPP_AngleJoint_obj::inactiveBodies(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_229_inactiveBodies)
HXLINE( 231)		if (hx::IsNotNull( this->b1 )) {
HXLINE( 231)			this->b1->constraints->remove(hx::ObjectPtr<OBJ_>(this));
            		}
HXLINE( 233)		if (hx::IsNotEq( this->b2,this->b1 )) {
HXLINE( 234)			if (hx::IsNotNull( this->b2 )) {
HXLINE( 234)				this->b2->constraints->remove(hx::ObjectPtr<OBJ_>(this));
            			}
            		}
            	}


 ::nape::constraint::Constraint ZPP_AngleJoint_obj::copy(::Array< ::Dynamic> dict,::Array< ::Dynamic> todo){
            	HX_GC_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_245_copy)
HXLINE( 246)		 ::nape::constraint::AngleJoint ret =  ::nape::constraint::AngleJoint_obj::__alloc( HX_CTX ,null(),null(),this->jointMin,this->jointMax,this->ratio);
HXLINE( 247)		this->copyto(ret);
HXLINE( 249)		bool _hx_tmp;
HXDLIN( 249)		if (hx::IsNotNull( dict )) {
HXLINE( 249)			_hx_tmp = hx::IsNotNull( this->b1 );
            		}
            		else {
HXLINE( 249)			_hx_tmp = false;
            		}
HXDLIN( 249)		if (_hx_tmp) {
HXLINE( 258)			 ::nape::phys::Body b = null();
HXLINE( 259)			{
HXLINE( 259)				int _g = 0;
HXDLIN( 259)				while((_g < dict->length)){
HXLINE( 259)					 ::zpp_nape::constraint::ZPP_CopyHelper idc = dict->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_CopyHelper >();
HXDLIN( 259)					_g = (_g + 1);
HXLINE( 260)					if ((idc->id == this->b1->id)) {
HXLINE( 261)						b = idc->bc;
HXLINE( 262)						goto _hx_goto_5;
            					}
            				}
            				_hx_goto_5:;
            			}
HXLINE( 265)			if (hx::IsNotNull( b )) {
HXLINE( 265)				ret->zpp_inner_zn->b1 = b->zpp_inner;
            			}
            			else {
            				HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0, ::nape::constraint::AngleJoint,ret) HXARGC(1)
            				void _hx_run( ::nape::phys::Body b1){
            					HX_GC_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_266_copy)
HXLINE( 266)					ret->zpp_inner_zn->b1 = b1->zpp_inner;
            				}
            				HX_END_LOCAL_FUNC1((void))

HXLINE( 266)				todo->push(::zpp_nape::constraint::ZPP_CopyHelper_obj::todo(this->b1->id, ::Dynamic(new _hx_Closure_0(ret))));
            			}
            		}
HXLINE( 270)		bool _hx_tmp1;
HXDLIN( 270)		if (hx::IsNotNull( dict )) {
HXLINE( 270)			_hx_tmp1 = hx::IsNotNull( this->b2 );
            		}
            		else {
HXLINE( 270)			_hx_tmp1 = false;
            		}
HXDLIN( 270)		if (_hx_tmp1) {
HXLINE( 279)			 ::nape::phys::Body b2 = null();
HXLINE( 280)			{
HXLINE( 280)				int _g1 = 0;
HXDLIN( 280)				while((_g1 < dict->length)){
HXLINE( 280)					 ::zpp_nape::constraint::ZPP_CopyHelper idc1 = dict->__get(_g1).StaticCast<  ::zpp_nape::constraint::ZPP_CopyHelper >();
HXDLIN( 280)					_g1 = (_g1 + 1);
HXLINE( 281)					if ((idc1->id == this->b2->id)) {
HXLINE( 282)						b2 = idc1->bc;
HXLINE( 283)						goto _hx_goto_6;
            					}
            				}
            				_hx_goto_6:;
            			}
HXLINE( 286)			if (hx::IsNotNull( b2 )) {
HXLINE( 286)				ret->zpp_inner_zn->b2 = b2->zpp_inner;
            			}
            			else {
            				HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_1, ::nape::constraint::AngleJoint,ret) HXARGC(1)
            				void _hx_run( ::nape::phys::Body b3){
            					HX_GC_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_287_copy)
HXLINE( 287)					ret->zpp_inner_zn->b2 = b3->zpp_inner;
            				}
            				HX_END_LOCAL_FUNC1((void))

HXLINE( 287)				todo->push(::zpp_nape::constraint::ZPP_CopyHelper_obj::todo(this->b2->id, ::Dynamic(new _hx_Closure_1(ret))));
            			}
            		}
HXLINE( 290)		return ret;
            	}


void ZPP_AngleJoint_obj::validate(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_300_validate)
HXLINE( 301)		bool _hx_tmp;
HXDLIN( 301)		if (hx::IsNotNull( this->b1 )) {
HXLINE( 301)			_hx_tmp = hx::IsNull( this->b2 );
            		}
            		else {
HXLINE( 301)			_hx_tmp = true;
            		}
HXDLIN( 301)		if (_hx_tmp) {
HXLINE( 301)			HX_STACK_DO_THROW(HX_("Error: AngleJoint cannot be simulated null bodies",fe,18,41,78));
            		}
HXLINE( 302)		if (hx::IsEq( this->b1,this->b2 )) {
HXLINE( 302)			HX_STACK_DO_THROW(HX_("Error: AngleJoint cannot be simulated with body1 == body2",60,e2,c2,00));
            		}
HXLINE( 303)		bool _hx_tmp1;
HXDLIN( 303)		if (hx::IsEq( this->b1->space,this->space )) {
HXLINE( 303)			_hx_tmp1 = hx::IsNotEq( this->b2->space,this->space );
            		}
            		else {
HXLINE( 303)			_hx_tmp1 = true;
            		}
HXDLIN( 303)		if (_hx_tmp1) {
HXLINE( 303)			HX_STACK_DO_THROW(HX_("Error: Constraints must have each body within the same space to which the constraint has been assigned",e8,8c,93,57));
            		}
HXLINE( 304)		if ((this->jointMin > this->jointMax)) {
HXLINE( 304)			HX_STACK_DO_THROW(HX_("Error: AngleJoint must have jointMin <= jointMax",7d,6c,b7,43));
            		}
HXLINE( 305)		bool _hx_tmp2;
HXDLIN( 305)		if ((this->b1->type != 2)) {
HXLINE( 305)			_hx_tmp2 = (this->b2->type != 2);
            		}
            		else {
HXLINE( 305)			_hx_tmp2 = false;
            		}
HXDLIN( 305)		if (_hx_tmp2) {
HXLINE( 305)			HX_STACK_DO_THROW(HX_("Error: Constraints cannot have both bodies non-dynamic",cb,b3,6c,eb));
            		}
            	}


void ZPP_AngleJoint_obj::wake_connected(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_307_wake_connected)
HXLINE( 308)		bool _hx_tmp;
HXDLIN( 308)		if (hx::IsNotNull( this->b1 )) {
HXLINE( 308)			_hx_tmp = (this->b1->type == 2);
            		}
            		else {
HXLINE( 308)			_hx_tmp = false;
            		}
HXDLIN( 308)		if (_hx_tmp) {
HXLINE( 308)			this->b1->wake();
            		}
HXLINE( 309)		bool _hx_tmp1;
HXDLIN( 309)		if (hx::IsNotNull( this->b2 )) {
HXLINE( 309)			_hx_tmp1 = (this->b2->type == 2);
            		}
            		else {
HXLINE( 309)			_hx_tmp1 = false;
            		}
HXDLIN( 309)		if (_hx_tmp1) {
HXLINE( 309)			this->b2->wake();
            		}
            	}


void ZPP_AngleJoint_obj::forest(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_311_forest)
HXLINE( 312)		if ((this->b1->type == 2)) {
HXLINE( 313)			 ::zpp_nape::space::ZPP_Component xr;
HXDLIN( 313)			if (hx::IsEq( this->b1->component,this->b1->component->parent )) {
HXLINE( 313)				xr = this->b1->component;
            			}
            			else {
HXLINE( 316)				 ::zpp_nape::space::ZPP_Component obj = this->b1->component;
HXLINE( 317)				 ::zpp_nape::space::ZPP_Component stack = null();
HXLINE( 318)				while(hx::IsNotEq( obj,obj->parent )){
HXLINE( 319)					 ::zpp_nape::space::ZPP_Component nxt = obj->parent;
HXLINE( 320)					obj->parent = stack;
HXLINE( 321)					stack = obj;
HXLINE( 322)					obj = nxt;
            				}
HXLINE( 324)				while(hx::IsNotNull( stack )){
HXLINE( 325)					 ::zpp_nape::space::ZPP_Component nxt1 = stack->parent;
HXLINE( 326)					stack->parent = obj;
HXLINE( 327)					stack = nxt1;
            				}
HXLINE( 313)				xr = obj;
            			}
HXLINE( 332)			 ::zpp_nape::space::ZPP_Component yr;
HXDLIN( 332)			if (hx::IsEq( this->component,this->component->parent )) {
HXLINE( 332)				yr = this->component;
            			}
            			else {
HXLINE( 335)				 ::zpp_nape::space::ZPP_Component obj1 = this->component;
HXLINE( 336)				 ::zpp_nape::space::ZPP_Component stack1 = null();
HXLINE( 337)				while(hx::IsNotEq( obj1,obj1->parent )){
HXLINE( 338)					 ::zpp_nape::space::ZPP_Component nxt2 = obj1->parent;
HXLINE( 339)					obj1->parent = stack1;
HXLINE( 340)					stack1 = obj1;
HXLINE( 341)					obj1 = nxt2;
            				}
HXLINE( 343)				while(hx::IsNotNull( stack1 )){
HXLINE( 344)					 ::zpp_nape::space::ZPP_Component nxt3 = stack1->parent;
HXLINE( 345)					stack1->parent = obj1;
HXLINE( 346)					stack1 = nxt3;
            				}
HXLINE( 332)				yr = obj1;
            			}
HXLINE( 351)			if (hx::IsNotEq( xr,yr )) {
HXLINE( 352)				if ((xr->rank < yr->rank)) {
HXLINE( 352)					xr->parent = yr;
            				}
            				else {
HXLINE( 353)					if ((xr->rank > yr->rank)) {
HXLINE( 353)						yr->parent = xr;
            					}
            					else {
HXLINE( 355)						yr->parent = xr;
HXLINE( 356)						xr->rank++;
            					}
            				}
            			}
            		}
HXLINE( 360)		if ((this->b2->type == 2)) {
HXLINE( 361)			 ::zpp_nape::space::ZPP_Component xr1;
HXDLIN( 361)			if (hx::IsEq( this->b2->component,this->b2->component->parent )) {
HXLINE( 361)				xr1 = this->b2->component;
            			}
            			else {
HXLINE( 364)				 ::zpp_nape::space::ZPP_Component obj2 = this->b2->component;
HXLINE( 365)				 ::zpp_nape::space::ZPP_Component stack2 = null();
HXLINE( 366)				while(hx::IsNotEq( obj2,obj2->parent )){
HXLINE( 367)					 ::zpp_nape::space::ZPP_Component nxt4 = obj2->parent;
HXLINE( 368)					obj2->parent = stack2;
HXLINE( 369)					stack2 = obj2;
HXLINE( 370)					obj2 = nxt4;
            				}
HXLINE( 372)				while(hx::IsNotNull( stack2 )){
HXLINE( 373)					 ::zpp_nape::space::ZPP_Component nxt5 = stack2->parent;
HXLINE( 374)					stack2->parent = obj2;
HXLINE( 375)					stack2 = nxt5;
            				}
HXLINE( 361)				xr1 = obj2;
            			}
HXLINE( 380)			 ::zpp_nape::space::ZPP_Component yr1;
HXDLIN( 380)			if (hx::IsEq( this->component,this->component->parent )) {
HXLINE( 380)				yr1 = this->component;
            			}
            			else {
HXLINE( 383)				 ::zpp_nape::space::ZPP_Component obj3 = this->component;
HXLINE( 384)				 ::zpp_nape::space::ZPP_Component stack3 = null();
HXLINE( 385)				while(hx::IsNotEq( obj3,obj3->parent )){
HXLINE( 386)					 ::zpp_nape::space::ZPP_Component nxt6 = obj3->parent;
HXLINE( 387)					obj3->parent = stack3;
HXLINE( 388)					stack3 = obj3;
HXLINE( 389)					obj3 = nxt6;
            				}
HXLINE( 391)				while(hx::IsNotNull( stack3 )){
HXLINE( 392)					 ::zpp_nape::space::ZPP_Component nxt7 = stack3->parent;
HXLINE( 393)					stack3->parent = obj3;
HXLINE( 394)					stack3 = nxt7;
            				}
HXLINE( 380)				yr1 = obj3;
            			}
HXLINE( 399)			if (hx::IsNotEq( xr1,yr1 )) {
HXLINE( 400)				if ((xr1->rank < yr1->rank)) {
HXLINE( 400)					xr1->parent = yr1;
            				}
            				else {
HXLINE( 401)					if ((xr1->rank > yr1->rank)) {
HXLINE( 401)						yr1->parent = xr1;
            					}
            					else {
HXLINE( 403)						yr1->parent = xr1;
HXLINE( 404)						xr1->rank++;
            					}
            				}
            			}
            		}
            	}


bool ZPP_AngleJoint_obj::pair_exists(int id,int di){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_410_pair_exists)
HXDLIN( 410)		bool _hx_tmp;
HXDLIN( 410)		if ((this->b1->id == id)) {
HXDLIN( 410)			_hx_tmp = (this->b2->id == di);
            		}
            		else {
HXDLIN( 410)			_hx_tmp = false;
            		}
HXDLIN( 410)		if (!(_hx_tmp)) {
HXDLIN( 410)			if ((this->b1->id == di)) {
HXDLIN( 410)				return (this->b2->id == id);
            			}
            			else {
HXDLIN( 410)				return false;
            			}
            		}
            		else {
HXDLIN( 410)			return true;
            		}
HXDLIN( 410)		return false;
            	}


void ZPP_AngleJoint_obj::clearcache(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_412_clearcache)
HXLINE( 413)		this->jAcc = ( (Float)(0) );
HXLINE( 414)		this->pre_dt = ((Float)-1.0);
HXLINE( 415)		this->slack = false;
            	}


bool ZPP_AngleJoint_obj::preStep(Float dt){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_417_preStep)
HXLINE( 418)		if ((this->pre_dt == ((Float)-1.0))) {
HXLINE( 418)			this->pre_dt = dt;
            		}
HXLINE( 419)		Float dtratio = (dt / this->pre_dt);
HXLINE( 420)		this->pre_dt = dt;
HXLINE( 421)		this->stepped = true;
HXLINE( 422)		this->equal = (this->jointMin == this->jointMax);
HXLINE( 424)		Float C = ((this->ratio * this->b2->rot) - this->b1->rot);
HXLINE( 425)		if (this->equal) {
HXLINE( 426)			C = (C - this->jointMax);
HXLINE( 427)			this->slack = false;
HXLINE( 428)			this->scale = ((Float)1.0);
            		}
            		else {
HXLINE( 431)			if ((C < this->jointMin)) {
HXLINE( 432)				C = (this->jointMin - C);
HXLINE( 433)				this->scale = ((Float)-1.0);
HXLINE( 434)				this->slack = false;
            			}
            			else {
HXLINE( 436)				if ((C > this->jointMax)) {
HXLINE( 437)					C = (C - this->jointMax);
HXLINE( 438)					this->scale = ((Float)1.0);
HXLINE( 439)					this->slack = false;
            				}
            				else {
HXLINE( 442)					this->scale = ((Float)0.0);
HXLINE( 443)					C = ( (Float)(0) );
HXLINE( 444)					this->slack = true;
            				}
            			}
            		}
HXLINE( 423)		Float C1 = C;
HXLINE( 449)		if (!(this->slack)) {
HXLINE( 450)			this->kMass = (this->b1->sinertia + ((this->ratio * this->ratio) * this->b2->sinertia));
HXLINE( 453)			if ((this->kMass != 0)) {
HXLINE( 453)				this->kMass = (( (Float)(1) ) / this->kMass);
            			}
            			else {
HXLINE( 454)				this->jAcc = ( (Float)(0) );
            			}
HXLINE( 455)			if (!(this->stiff)) {
HXLINE( 456)				bool _hx_tmp;
HXDLIN( 456)				if (this->breakUnderError) {
HXLINE( 456)					_hx_tmp = ((C1 * C1) > (this->maxError * this->maxError));
            				}
            				else {
HXLINE( 456)					_hx_tmp = false;
            				}
HXDLIN( 456)				if (_hx_tmp) {
HXLINE( 456)					return true;
            				}
HXLINE( 458)				 ::zpp_nape::constraint::ZPP_AngleJoint _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXLINE( 459)				Float omega = ((( (Float)(2) ) * ::Math_obj::PI) * this->frequency);
HXLINE( 460)				this->gamma = (( (Float)(1) ) / ((dt * omega) * ((( (Float)(2) ) * this->damping) + (omega * dt))));
HXLINE( 461)				Float ig = (( (Float)(1) ) / (1 + this->gamma));
HXLINE( 457)				Float biasCoef = (((dt * omega) * omega) * this->gamma);
HXLINE( 463)				 ::zpp_nape::constraint::ZPP_AngleJoint _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 463)				_hx_tmp2->gamma = (_hx_tmp2->gamma * ig);
HXLINE( 458)				_hx_tmp1->kMass = (_hx_tmp1->kMass * ig);
HXLINE( 466)				this->bias = (-(C1) * biasCoef);
HXLINE( 468)				if ((this->bias < -(this->maxError))) {
HXLINE( 468)					this->bias = -(this->maxError);
            				}
            				else {
HXLINE( 469)					if ((this->bias > this->maxError)) {
HXLINE( 469)						this->bias = this->maxError;
            					}
            				}
            			}
            			else {
HXLINE( 473)				this->bias = ( (Float)(0) );
HXLINE( 474)				this->gamma = ( (Float)(0) );
            			}
HXLINE( 476)			 ::zpp_nape::constraint::ZPP_AngleJoint _hx_tmp3 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 476)			_hx_tmp3->jAcc = (_hx_tmp3->jAcc * dtratio);
HXLINE( 477)			this->jMax = (this->maxForce * dt);
            		}
HXLINE( 479)		return false;
            	}


void ZPP_AngleJoint_obj::warmStart(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_482_warmStart)
HXDLIN( 482)		if (!(this->slack)) {
HXLINE( 488)			 ::zpp_nape::phys::ZPP_Body _hx_tmp = this->b1;
HXDLIN( 488)			_hx_tmp->angvel = (_hx_tmp->angvel - ((this->scale * this->b1->iinertia) * this->jAcc));
HXLINE( 489)			 ::zpp_nape::phys::ZPP_Body _hx_tmp1 = this->b2;
HXDLIN( 489)			_hx_tmp1->angvel = (_hx_tmp1->angvel + (((this->ratio * this->scale) * this->b2->iinertia) * this->jAcc));
            		}
            	}


bool ZPP_AngleJoint_obj::applyImpulseVel(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_493_applyImpulseVel)
HXLINE( 494)		if (this->slack) {
HXLINE( 494)			return false;
            		}
HXLINE( 495)		Float E = (this->scale * (((this->ratio * (this->b2->angvel + this->b2->kinangvel)) - this->b1->angvel) - this->b1->kinangvel));
HXLINE( 498)		Float j = ((this->kMass * (this->bias - E)) - (this->jAcc * this->gamma));
HXLINE( 499)		{
HXLINE( 508)			Float jOld = this->jAcc;
HXLINE( 509)			 ::zpp_nape::constraint::ZPP_AngleJoint _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 509)			_hx_tmp->jAcc = (_hx_tmp->jAcc + j);
HXLINE( 510)			{
HXLINE( 511)				bool _hx_tmp1;
HXDLIN( 511)				if (!(this->equal)) {
HXLINE( 511)					_hx_tmp1 = (this->jAcc > 0);
            				}
            				else {
HXLINE( 511)					_hx_tmp1 = false;
            				}
HXDLIN( 511)				if (_hx_tmp1) {
HXLINE( 511)					this->jAcc = ( (Float)(0) );
            				}
HXLINE( 512)				bool _hx_tmp2;
HXDLIN( 512)				if (this->breakUnderForce) {
HXLINE( 512)					if (!((this->jAcc > this->jMax))) {
HXLINE( 512)						_hx_tmp2 = (this->jAcc < -(this->jMax));
            					}
            					else {
HXLINE( 512)						_hx_tmp2 = true;
            					}
            				}
            				else {
HXLINE( 512)					_hx_tmp2 = false;
            				}
HXDLIN( 512)				if (_hx_tmp2) {
HXLINE( 512)					return true;
            				}
HXLINE( 513)				if (!(this->stiff)) {
HXLINE( 514)					if ((this->jAcc > this->jMax)) {
HXLINE( 514)						this->jAcc = this->jMax;
            					}
            					else {
HXLINE( 515)						if ((this->jAcc < -(this->jMax))) {
HXLINE( 515)							this->jAcc = -(this->jMax);
            						}
            					}
            				}
            			}
HXLINE( 518)			j = (this->jAcc - jOld);
            		}
HXLINE( 525)		{
HXLINE( 526)			 ::zpp_nape::phys::ZPP_Body _hx_tmp3 = this->b1;
HXDLIN( 526)			_hx_tmp3->angvel = (_hx_tmp3->angvel - ((this->scale * this->b1->iinertia) * j));
HXLINE( 527)			 ::zpp_nape::phys::ZPP_Body _hx_tmp4 = this->b2;
HXDLIN( 527)			_hx_tmp4->angvel = (_hx_tmp4->angvel + (((this->ratio * this->scale) * this->b2->iinertia) * j));
            		}
HXLINE( 530)		return false;
            	}


bool ZPP_AngleJoint_obj::applyImpulsePos(){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_532_applyImpulsePos)
HXLINE( 534)		Float j;
HXLINE( 535)		bool slack;
HXLINE( 537)		Float C = ((this->ratio * this->b2->rot) - this->b1->rot);
HXLINE( 538)		if (this->equal) {
HXLINE( 539)			C = (C - this->jointMax);
HXLINE( 540)			slack = false;
HXLINE( 541)			this->scale = ((Float)1.0);
            		}
            		else {
HXLINE( 544)			if ((C < this->jointMin)) {
HXLINE( 545)				C = (this->jointMin - C);
HXLINE( 546)				this->scale = ((Float)-1.0);
HXLINE( 547)				slack = false;
            			}
            			else {
HXLINE( 549)				if ((C > this->jointMax)) {
HXLINE( 550)					C = (C - this->jointMax);
HXLINE( 551)					this->scale = ((Float)1.0);
HXLINE( 552)					slack = false;
            				}
            				else {
HXLINE( 555)					this->scale = ((Float)0.0);
HXLINE( 556)					C = ( (Float)(0) );
HXLINE( 557)					slack = true;
            				}
            			}
            		}
HXLINE( 533)		Float E = C;
HXLINE( 562)		if (!(slack)) {
HXLINE( 563)			bool _hx_tmp;
HXDLIN( 563)			if (this->breakUnderError) {
HXLINE( 563)				_hx_tmp = ((E * E) > (this->maxError * this->maxError));
            			}
            			else {
HXLINE( 563)				_hx_tmp = false;
            			}
HXDLIN( 563)			if (_hx_tmp) {
HXLINE( 563)				return true;
            			}
HXLINE( 564)			E = (E * ((Float)0.5));
HXLINE( 565)			j = (-(E) * this->kMass);
HXLINE( 566)			bool _hx_tmp1;
HXDLIN( 566)			if (!(this->equal)) {
HXLINE( 566)				_hx_tmp1 = (j < 0);
            			}
            			else {
HXLINE( 566)				_hx_tmp1 = true;
            			}
HXDLIN( 566)			if (_hx_tmp1) {
HXLINE( 568)				{
HXLINE( 568)					 ::zpp_nape::phys::ZPP_Body _this = this->b1;
HXDLIN( 568)					Float dr = ((-(this->scale) * j) * this->b1->iinertia);
HXDLIN( 568)					 ::zpp_nape::phys::ZPP_Body _this1 = _this;
HXDLIN( 568)					_this1->rot = (_this1->rot + dr);
HXDLIN( 568)					if (((dr * dr) > ((Float)0.0001))) {
HXLINE( 568)						_this->axisx = ::Math_obj::sin(_this->rot);
HXDLIN( 568)						_this->axisy = ::Math_obj::cos(_this->rot);
            					}
            					else {
HXLINE( 568)						Float d2 = (dr * dr);
HXDLIN( 568)						Float p = (( (Float)(1) ) - (((Float)0.5) * d2));
HXDLIN( 568)						Float m = (( (Float)(1) ) - ((d2 * d2) / ( (Float)(8) )));
HXDLIN( 568)						Float nx = (((p * _this->axisx) + (dr * _this->axisy)) * m);
HXDLIN( 568)						_this->axisy = (((p * _this->axisy) - (dr * _this->axisx)) * m);
HXDLIN( 568)						_this->axisx = nx;
            					}
            				}
HXLINE( 569)				{
HXLINE( 569)					 ::zpp_nape::phys::ZPP_Body _this2 = this->b2;
HXDLIN( 569)					Float dr1 = (((this->ratio * this->scale) * j) * this->b2->iinertia);
HXDLIN( 569)					 ::zpp_nape::phys::ZPP_Body _this3 = _this2;
HXDLIN( 569)					_this3->rot = (_this3->rot + dr1);
HXDLIN( 569)					if (((dr1 * dr1) > ((Float)0.0001))) {
HXLINE( 569)						_this2->axisx = ::Math_obj::sin(_this2->rot);
HXDLIN( 569)						_this2->axisy = ::Math_obj::cos(_this2->rot);
            					}
            					else {
HXLINE( 569)						Float d21 = (dr1 * dr1);
HXDLIN( 569)						Float p1 = (( (Float)(1) ) - (((Float)0.5) * d21));
HXDLIN( 569)						Float m1 = (( (Float)(1) ) - ((d21 * d21) / ( (Float)(8) )));
HXDLIN( 569)						Float nx1 = (((p1 * _this2->axisx) + (dr1 * _this2->axisy)) * m1);
HXDLIN( 569)						_this2->axisy = (((p1 * _this2->axisy) - (dr1 * _this2->axisx)) * m1);
HXDLIN( 569)						_this2->axisx = nx1;
            					}
            				}
            			}
            		}
HXLINE( 577)		return false;
            	}


void ZPP_AngleJoint_obj::draw( ::nape::util::Debug g){
            	HX_STACKFRAME(&_hx_pos_cb72d1d2a3d570ae_579_draw)
            	}



hx::ObjectPtr< ZPP_AngleJoint_obj > ZPP_AngleJoint_obj::__new() {
	hx::ObjectPtr< ZPP_AngleJoint_obj > __this = new ZPP_AngleJoint_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< ZPP_AngleJoint_obj > ZPP_AngleJoint_obj::__alloc(hx::Ctx *_hx_ctx) {
	ZPP_AngleJoint_obj *__this = (ZPP_AngleJoint_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ZPP_AngleJoint_obj), true, "zpp_nape.constraint.ZPP_AngleJoint"));
	*(void **)__this = ZPP_AngleJoint_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ZPP_AngleJoint_obj::ZPP_AngleJoint_obj()
{
}

void ZPP_AngleJoint_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ZPP_AngleJoint);
	HX_MARK_MEMBER_NAME(outer_zn,"outer_zn");
	HX_MARK_MEMBER_NAME(ratio,"ratio");
	HX_MARK_MEMBER_NAME(jointMin,"jointMin");
	HX_MARK_MEMBER_NAME(jointMax,"jointMax");
	HX_MARK_MEMBER_NAME(slack,"slack");
	HX_MARK_MEMBER_NAME(equal,"equal");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(b1,"b1");
	HX_MARK_MEMBER_NAME(b2,"b2");
	HX_MARK_MEMBER_NAME(kMass,"kMass");
	HX_MARK_MEMBER_NAME(jAcc,"jAcc");
	HX_MARK_MEMBER_NAME(jMax,"jMax");
	HX_MARK_MEMBER_NAME(gamma,"gamma");
	HX_MARK_MEMBER_NAME(bias,"bias");
	HX_MARK_MEMBER_NAME(stepped,"stepped");
	 ::zpp_nape::constraint::ZPP_Constraint_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ZPP_AngleJoint_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(outer_zn,"outer_zn");
	HX_VISIT_MEMBER_NAME(ratio,"ratio");
	HX_VISIT_MEMBER_NAME(jointMin,"jointMin");
	HX_VISIT_MEMBER_NAME(jointMax,"jointMax");
	HX_VISIT_MEMBER_NAME(slack,"slack");
	HX_VISIT_MEMBER_NAME(equal,"equal");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(b1,"b1");
	HX_VISIT_MEMBER_NAME(b2,"b2");
	HX_VISIT_MEMBER_NAME(kMass,"kMass");
	HX_VISIT_MEMBER_NAME(jAcc,"jAcc");
	HX_VISIT_MEMBER_NAME(jMax,"jMax");
	HX_VISIT_MEMBER_NAME(gamma,"gamma");
	HX_VISIT_MEMBER_NAME(bias,"bias");
	HX_VISIT_MEMBER_NAME(stepped,"stepped");
	 ::zpp_nape::constraint::ZPP_Constraint_obj::__Visit(HX_VISIT_ARG);
}

hx::Val ZPP_AngleJoint_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"b1") ) { return hx::Val( b1 ); }
		if (HX_FIELD_EQ(inName,"b2") ) { return hx::Val( b2 ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"jAcc") ) { return hx::Val( jAcc ); }
		if (HX_FIELD_EQ(inName,"jMax") ) { return hx::Val( jMax ); }
		if (HX_FIELD_EQ(inName,"bias") ) { return hx::Val( bias ); }
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"ratio") ) { return hx::Val( ratio ); }
		if (HX_FIELD_EQ(inName,"slack") ) { return hx::Val( slack ); }
		if (HX_FIELD_EQ(inName,"equal") ) { return hx::Val( equal ); }
		if (HX_FIELD_EQ(inName,"scale") ) { return hx::Val( scale ); }
		if (HX_FIELD_EQ(inName,"kMass") ) { return hx::Val( kMass ); }
		if (HX_FIELD_EQ(inName,"gamma") ) { return hx::Val( gamma ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"forest") ) { return hx::Val( forest_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"stepped") ) { return hx::Val( stepped ); }
		if (HX_FIELD_EQ(inName,"preStep") ) { return hx::Val( preStep_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"outer_zn") ) { return hx::Val( outer_zn ); }
		if (HX_FIELD_EQ(inName,"jointMin") ) { return hx::Val( jointMin ); }
		if (HX_FIELD_EQ(inName,"jointMax") ) { return hx::Val( jointMax ); }
		if (HX_FIELD_EQ(inName,"is_slack") ) { return hx::Val( is_slack_dyn() ); }
		if (HX_FIELD_EQ(inName,"validate") ) { return hx::Val( validate_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"warmStart") ) { return hx::Val( warmStart_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"clearcache") ) { return hx::Val( clearcache_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"bodyImpulse") ) { return hx::Val( bodyImpulse_dyn() ); }
		if (HX_FIELD_EQ(inName,"pair_exists") ) { return hx::Val( pair_exists_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"activeBodies") ) { return hx::Val( activeBodies_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"inactiveBodies") ) { return hx::Val( inactiveBodies_dyn() ); }
		if (HX_FIELD_EQ(inName,"wake_connected") ) { return hx::Val( wake_connected_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"applyImpulseVel") ) { return hx::Val( applyImpulseVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyImpulsePos") ) { return hx::Val( applyImpulsePos_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val ZPP_AngleJoint_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"b1") ) { b1=inValue.Cast<  ::zpp_nape::phys::ZPP_Body >(); return inValue; }
		if (HX_FIELD_EQ(inName,"b2") ) { b2=inValue.Cast<  ::zpp_nape::phys::ZPP_Body >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"jAcc") ) { jAcc=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jMax") ) { jMax=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bias") ) { bias=inValue.Cast< Float >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"ratio") ) { ratio=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"slack") ) { slack=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"equal") ) { equal=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scale") ) { scale=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kMass") ) { kMass=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"gamma") ) { gamma=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"stepped") ) { stepped=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"outer_zn") ) { outer_zn=inValue.Cast<  ::nape::constraint::AngleJoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jointMin") ) { jointMin=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jointMax") ) { jointMax=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ZPP_AngleJoint_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("outer_zn",38,07,b0,a2));
	outFields->push(HX_("ratio",0b,35,24,e4));
	outFields->push(HX_("jointMin",68,fa,25,55));
	outFields->push(HX_("jointMax",7a,f3,25,55));
	outFields->push(HX_("slack",50,b2,c1,7e));
	outFields->push(HX_("equal",b4,cf,82,72));
	outFields->push(HX_("scale",8a,ce,ce,78));
	outFields->push(HX_("b1",8f,55,00,00));
	outFields->push(HX_("b2",90,55,00,00));
	outFields->push(HX_("kMass",ff,7e,0f,cf));
	outFields->push(HX_("jAcc",f7,46,42,46));
	outFields->push(HX_("jMax",5a,60,4b,46));
	outFields->push(HX_("gamma",27,87,b6,8e));
	outFields->push(HX_("bias",79,ea,16,41));
	outFields->push(HX_("stepped",03,05,60,81));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo ZPP_AngleJoint_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::nape::constraint::AngleJoint */ ,(int)offsetof(ZPP_AngleJoint_obj,outer_zn),HX_("outer_zn",38,07,b0,a2)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,ratio),HX_("ratio",0b,35,24,e4)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,jointMin),HX_("jointMin",68,fa,25,55)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,jointMax),HX_("jointMax",7a,f3,25,55)},
	{hx::fsBool,(int)offsetof(ZPP_AngleJoint_obj,slack),HX_("slack",50,b2,c1,7e)},
	{hx::fsBool,(int)offsetof(ZPP_AngleJoint_obj,equal),HX_("equal",b4,cf,82,72)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,scale),HX_("scale",8a,ce,ce,78)},
	{hx::fsObject /*  ::zpp_nape::phys::ZPP_Body */ ,(int)offsetof(ZPP_AngleJoint_obj,b1),HX_("b1",8f,55,00,00)},
	{hx::fsObject /*  ::zpp_nape::phys::ZPP_Body */ ,(int)offsetof(ZPP_AngleJoint_obj,b2),HX_("b2",90,55,00,00)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,kMass),HX_("kMass",ff,7e,0f,cf)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,jAcc),HX_("jAcc",f7,46,42,46)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,jMax),HX_("jMax",5a,60,4b,46)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,gamma),HX_("gamma",27,87,b6,8e)},
	{hx::fsFloat,(int)offsetof(ZPP_AngleJoint_obj,bias),HX_("bias",79,ea,16,41)},
	{hx::fsBool,(int)offsetof(ZPP_AngleJoint_obj,stepped),HX_("stepped",03,05,60,81)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *ZPP_AngleJoint_obj_sStaticStorageInfo = 0;
#endif

static ::String ZPP_AngleJoint_obj_sMemberFields[] = {
	HX_("outer_zn",38,07,b0,a2),
	HX_("ratio",0b,35,24,e4),
	HX_("jointMin",68,fa,25,55),
	HX_("jointMax",7a,f3,25,55),
	HX_("slack",50,b2,c1,7e),
	HX_("equal",b4,cf,82,72),
	HX_("scale",8a,ce,ce,78),
	HX_("is_slack",fb,20,7e,9e),
	HX_("bodyImpulse",33,76,a2,5f),
	HX_("activeBodies",e6,69,f8,ba),
	HX_("inactiveBodies",4b,89,c5,8c),
	HX_("b1",8f,55,00,00),
	HX_("b2",90,55,00,00),
	HX_("kMass",ff,7e,0f,cf),
	HX_("jAcc",f7,46,42,46),
	HX_("jMax",5a,60,4b,46),
	HX_("gamma",27,87,b6,8e),
	HX_("bias",79,ea,16,41),
	HX_("stepped",03,05,60,81),
	HX_("copy",b5,bb,c4,41),
	HX_("validate",96,d0,e3,04),
	HX_("wake_connected",ae,cf,dd,3d),
	HX_("forest",dd,8c,88,fd),
	HX_("pair_exists",a1,6a,58,69),
	HX_("clearcache",95,69,f1,82),
	HX_("preStep",0f,c1,c0,24),
	HX_("warmStart",dd,27,03,eb),
	HX_("applyImpulseVel",b6,c7,50,1f),
	HX_("applyImpulsePos",ed,42,4c,1f),
	HX_("draw",04,2c,70,42),
	::String(null()) };

hx::Class ZPP_AngleJoint_obj::__mClass;

void ZPP_AngleJoint_obj::__register()
{
	ZPP_AngleJoint_obj _hx_dummy;
	ZPP_AngleJoint_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("zpp_nape.constraint.ZPP_AngleJoint",ec,03,92,be);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ZPP_AngleJoint_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ZPP_AngleJoint_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ZPP_AngleJoint_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ZPP_AngleJoint_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace zpp_nape
} // end namespace constraint
