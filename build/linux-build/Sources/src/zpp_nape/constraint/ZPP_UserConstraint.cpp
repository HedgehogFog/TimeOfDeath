// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_nape_Config
#include <hxinc/nape/Config.h>
#endif
#ifndef INCLUDED_nape_constraint_Constraint
#include <hxinc/nape/constraint/Constraint.h>
#endif
#ifndef INCLUDED_nape_constraint_UserConstraint
#include <hxinc/nape/constraint/UserConstraint.h>
#endif
#ifndef INCLUDED_nape_geom_Vec3
#include <hxinc/nape/geom/Vec3.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_util_Debug
#include <hxinc/nape/util/Debug.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_Constraint
#include <hxinc/zpp_nape/constraint/ZPP_Constraint.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_CopyHelper
#include <hxinc/zpp_nape/constraint/ZPP_CopyHelper.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_UserBody
#include <hxinc/zpp_nape/constraint/ZPP_UserBody.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_UserConstraint
#include <hxinc/zpp_nape/constraint/ZPP_UserConstraint.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec3
#include <hxinc/zpp_nape/geom/ZPP_Vec3.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Component
#include <hxinc/zpp_nape/space/ZPP_Component.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Constraint
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Constraint.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_62fa6ce655c689ca_174_new,"zpp_nape.constraint.ZPP_UserConstraint","new",0x54ee5fef,"zpp_nape.constraint.ZPP_UserConstraint.new","zpp_nape/constraint/UserConstraint.hx",174,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_177_bindVec2_invalidate,"zpp_nape.constraint.ZPP_UserConstraint","bindVec2_invalidate",0x941f4c4e,"zpp_nape.constraint.ZPP_UserConstraint.bindVec2_invalidate","zpp_nape/constraint/UserConstraint.hx",177,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_183_addBody,"zpp_nape.constraint.ZPP_UserConstraint","addBody",0xca33c072,"zpp_nape.constraint.ZPP_UserConstraint.addBody","zpp_nape/constraint/UserConstraint.hx",183,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_207_remBody,"zpp_nape.constraint.ZPP_UserConstraint","remBody",0x2217382b,"zpp_nape.constraint.ZPP_UserConstraint.remBody","zpp_nape/constraint/UserConstraint.hx",207,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_237_bodyImpulse,"zpp_nape.constraint.ZPP_UserConstraint","bodyImpulse",0x8cbdacc2,"zpp_nape.constraint.ZPP_UserConstraint.bodyImpulse","zpp_nape/constraint/UserConstraint.hx",237,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_244_activeBodies,"zpp_nape.constraint.ZPP_UserConstraint","activeBodies",0x05acf077,"zpp_nape.constraint.ZPP_UserConstraint.activeBodies","zpp_nape/constraint/UserConstraint.hx",244,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_249_inactiveBodies,"zpp_nape.constraint.ZPP_UserConstraint","inactiveBodies",0x5295961c,"zpp_nape.constraint.ZPP_UserConstraint.inactiveBodies","zpp_nape/constraint/UserConstraint.hx",249,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_254_copy,"zpp_nape.constraint.ZPP_UserConstraint","copy",0xf467c946,"zpp_nape.constraint.ZPP_UserConstraint.copy","zpp_nape/constraint/UserConstraint.hx",254,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_295_validate,"zpp_nape.constraint.ZPP_UserConstraint","validate",0xf7ab7aa7,"zpp_nape.constraint.ZPP_UserConstraint.validate","zpp_nape/constraint/UserConstraint.hx",295,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_300_wake_connected,"zpp_nape.constraint.ZPP_UserConstraint","wake_connected",0x03addc7f,"zpp_nape.constraint.ZPP_UserConstraint.wake_connected","zpp_nape/constraint/UserConstraint.hx",300,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_305_forest,"zpp_nape.constraint.ZPP_UserConstraint","forest",0xe936e0ae,"zpp_nape.constraint.ZPP_UserConstraint.forest","zpp_nape/constraint/UserConstraint.hx",305,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_356_pair_exists,"zpp_nape.constraint.ZPP_UserConstraint","pair_exists",0x9673a130,"zpp_nape.constraint.ZPP_UserConstraint.pair_exists","zpp_nape/constraint/UserConstraint.hx",356,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_373_broken,"zpp_nape.constraint.ZPP_UserConstraint","broken",0x08060a26,"zpp_nape.constraint.ZPP_UserConstraint.broken","zpp_nape/constraint/UserConstraint.hx",373,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_375_clearcache,"zpp_nape.constraint.ZPP_UserConstraint","clearcache",0x768479e6,"zpp_nape.constraint.ZPP_UserConstraint.clearcache","zpp_nape/constraint/UserConstraint.hx",375,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_379_lsq,"zpp_nape.constraint.ZPP_UserConstraint","lsq",0x54ece799,"zpp_nape.constraint.ZPP_UserConstraint.lsq","zpp_nape/constraint/UserConstraint.hx",379,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_384__clamp,"zpp_nape.constraint.ZPP_UserConstraint","_clamp",0x2fee0e0d,"zpp_nape.constraint.ZPP_UserConstraint._clamp","zpp_nape/constraint/UserConstraint.hx",384,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_392_solve,"zpp_nape.constraint.ZPP_UserConstraint","solve",0x1cce90ce,"zpp_nape.constraint.ZPP_UserConstraint.solve","zpp_nape/constraint/UserConstraint.hx",392,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_415_transform,"zpp_nape.constraint.ZPP_UserConstraint","transform",0xc180523b,"zpp_nape.constraint.ZPP_UserConstraint.transform","zpp_nape/constraint/UserConstraint.hx",415,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_441_preStep,"zpp_nape.constraint.ZPP_UserConstraint","preStep",0x719bc41e,"zpp_nape.constraint.ZPP_UserConstraint.preStep","zpp_nape/constraint/UserConstraint.hx",441,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_478_warmStart,"zpp_nape.constraint.ZPP_UserConstraint","warmStart",0x66f04cac,"zpp_nape.constraint.ZPP_UserConstraint.warmStart","zpp_nape/constraint/UserConstraint.hx",478,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_499_applyImpulseVel,"zpp_nape.constraint.ZPP_UserConstraint","applyImpulseVel",0x6f8bf1c5,"zpp_nape.constraint.ZPP_UserConstraint.applyImpulseVel","zpp_nape/constraint/UserConstraint.hx",499,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_533_applyImpulsePos,"zpp_nape.constraint.ZPP_UserConstraint","applyImpulsePos",0x6f876cfc,"zpp_nape.constraint.ZPP_UserConstraint.applyImpulsePos","zpp_nape/constraint/UserConstraint.hx",533,0x968ba4a6)
HX_LOCAL_STACK_FRAME(_hx_pos_62fa6ce655c689ca_565_draw,"zpp_nape.constraint.ZPP_UserConstraint","draw",0xf5133995,"zpp_nape.constraint.ZPP_UserConstraint.draw","zpp_nape/constraint/UserConstraint.hx",565,0x968ba4a6)
namespace zpp_nape{
namespace constraint{

void ZPP_UserConstraint_obj::__construct(int dim,bool velonly){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_174_new)
HXLINE( 498)		this->jOld = null();
HXLINE( 497)		this->J = null();
HXLINE( 476)		this->vec3 = null();
HXLINE( 440)		this->Keff = null();
HXLINE( 439)		this->jMax = ((Float)0.0);
HXLINE( 438)		this->velonly = false;
HXLINE( 437)		this->gamma = ((Float)0.0);
HXLINE( 436)		this->soft = ((Float)0.0);
HXLINE( 414)		this->y = null();
HXLINE( 391)		this->L = null();
HXLINE( 253)		this->stepped = false;
HXLINE( 182)		this->bias = null();
HXLINE( 181)		this->jAcc = null();
HXLINE( 180)		this->dim = 0;
HXLINE( 179)		this->bodies = null();
HXLINE( 175)		this->outer_zn = null();
HXLINE( 261)		super::__construct();
HXLINE( 262)		this->bodies = ::Array_obj< ::Dynamic>::__new();
HXLINE( 265)		this->dim = dim;
HXLINE( 266)		this->velonly = velonly;
HXLINE( 267)		this->jAcc = ::Array_obj< Float >::__new();
HXLINE( 270)		this->bias = ::Array_obj< Float >::__new();
HXLINE( 273)		this->L = ::Array_obj< Float >::__new();
HXLINE( 276)		this->J = ::Array_obj< Float >::__new();
HXLINE( 279)		this->jOld = ::Array_obj< Float >::__new();
HXLINE( 282)		this->y = ::Array_obj< Float >::__new();
HXLINE( 285)		this->Keff = ::Array_obj< Float >::__new();
HXLINE( 288)		this->vec3 = ::nape::geom::Vec3_obj::get(0,0,0);
HXLINE( 289)		{
HXLINE( 289)			int _g = 0;
HXDLIN( 289)			int _g1 = dim;
HXDLIN( 289)			while((_g < _g1)){
HXLINE( 289)				_g = (_g + 1);
HXDLIN( 289)				int i = (_g - 1);
HXLINE( 290)				Float _hx_tmp = (this->bias[i] = (this->J[i] = (this->jOld[i] = (this->y[i] = ((Float)0.0)))));
HXDLIN( 290)				this->jAcc[i] = _hx_tmp;
HXLINE( 291)				{
HXLINE( 291)					int _g2 = 0;
HXDLIN( 291)					int _g11 = dim;
HXDLIN( 291)					while((_g2 < _g11)){
HXLINE( 291)						_g2 = (_g2 + 1);
HXDLIN( 291)						int j = (_g2 - 1);
HXDLIN( 291)						this->L[((i * dim) + j)] = ((Float)0.0);
            					}
            				}
            			}
            		}
HXLINE( 293)		this->stepped = false;
            	}

Dynamic ZPP_UserConstraint_obj::__CreateEmpty() { return new ZPP_UserConstraint_obj; }

void *ZPP_UserConstraint_obj::_hx_vtable = 0;

Dynamic ZPP_UserConstraint_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ZPP_UserConstraint_obj > _hx_result = new ZPP_UserConstraint_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ZPP_UserConstraint_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x294cc45f) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x294cc45f;
	} else {
		return inClassId==(int)0x7c84a5ec;
	}
}

void ZPP_UserConstraint_obj::bindVec2_invalidate( ::zpp_nape::geom::ZPP_Vec2 _){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_177_bindVec2_invalidate)
HXDLIN( 177)		this->outer_zn->_hx___invalidate();
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_UserConstraint_obj,bindVec2_invalidate,(void))

void ZPP_UserConstraint_obj::addBody( ::zpp_nape::phys::ZPP_Body b){
            	HX_GC_STACKFRAME(&_hx_pos_62fa6ce655c689ca_183_addBody)
HXLINE( 192)		 ::zpp_nape::constraint::ZPP_UserBody match = null();
HXLINE( 193)		{
HXLINE( 193)			int _g = 0;
HXDLIN( 193)			::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 193)			while((_g < _g1->length)){
HXLINE( 193)				 ::zpp_nape::constraint::ZPP_UserBody x = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 193)				_g = (_g + 1);
HXLINE( 194)				if (hx::IsEq( x->body,b )) {
HXLINE( 195)					match = x;
HXLINE( 196)					goto _hx_goto_4;
            				}
            			}
            			_hx_goto_4:;
            		}
HXLINE( 199)		if (hx::IsNull( match )) {
HXLINE( 200)			::Array< ::Dynamic> _hx_tmp = this->bodies;
HXDLIN( 200)			_hx_tmp->push( ::zpp_nape::constraint::ZPP_UserBody_obj::__alloc( HX_CTX ,1,b));
HXLINE( 201)			bool _hx_tmp1;
HXDLIN( 201)			if (this->active) {
HXLINE( 201)				_hx_tmp1 = hx::IsNotNull( this->space );
            			}
            			else {
HXLINE( 201)				_hx_tmp1 = false;
            			}
HXDLIN( 201)			if (_hx_tmp1) {
HXLINE( 202)				if (hx::IsNotNull( b )) {
HXLINE( 202)					b->constraints->add(hx::ObjectPtr<OBJ_>(this));
            				}
            			}
            		}
            		else {
HXLINE( 205)			match->cnt++;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_UserConstraint_obj,addBody,(void))

bool ZPP_UserConstraint_obj::remBody( ::zpp_nape::phys::ZPP_Body b){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_207_remBody)
HXLINE( 216)		 ::zpp_nape::constraint::ZPP_UserBody match = null();
HXLINE( 217)		int bl = ::Std_obj::_hx_int(( (Float)(this->bodies->length) ));
HXLINE( 218)		int i = 0;
HXLINE( 219)		while((i < bl)){
HXLINE( 220)			 ::zpp_nape::constraint::ZPP_UserBody x = this->bodies->__get(i).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXLINE( 221)			if (hx::IsEq( x->body,b )) {
HXLINE( 222)				x->cnt--;
HXLINE( 223)				if ((x->cnt == 0)) {
HXLINE( 224)					if ((bl > 0)) {
HXLINE( 224)						this->bodies[i] = this->bodies->__get((bl - 1)).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
            					}
HXLINE( 225)					this->bodies->pop().StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXLINE( 226)					bool _hx_tmp;
HXDLIN( 226)					if (this->active) {
HXLINE( 226)						_hx_tmp = hx::IsNotNull( this->space );
            					}
            					else {
HXLINE( 226)						_hx_tmp = false;
            					}
HXDLIN( 226)					if (_hx_tmp) {
HXLINE( 227)						if (hx::IsNotNull( b )) {
HXLINE( 227)							b->constraints->remove(hx::ObjectPtr<OBJ_>(this));
            						}
            					}
            				}
HXLINE( 230)				match = x;
HXLINE( 231)				goto _hx_goto_6;
            			}
HXLINE( 233)			i = (i + 1);
            		}
            		_hx_goto_6:;
HXLINE( 235)		return hx::IsNotNull( match );
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_UserConstraint_obj,remBody,return )

 ::nape::geom::Vec3 ZPP_UserConstraint_obj::bodyImpulse( ::zpp_nape::phys::ZPP_Body b){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_237_bodyImpulse)
HXLINE( 238)		{
HXLINE( 238)			int _g = 0;
HXDLIN( 238)			int _g1 = this->dim;
HXDLIN( 238)			while((_g < _g1)){
HXLINE( 238)				_g = (_g + 1);
HXDLIN( 238)				int i = (_g - 1);
HXDLIN( 238)				this->J[i] = this->jAcc->__get(i);
            			}
            		}
HXLINE( 239)		 ::nape::geom::Vec3 ret = ::nape::geom::Vec3_obj::get(0,0,0);
HXLINE( 240)		if (this->stepped) {
HXLINE( 240)			this->outer_zn->_hx___impulse(this->J,b->outer,ret);
            		}
HXLINE( 241)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_UserConstraint_obj,bodyImpulse,return )

void ZPP_UserConstraint_obj::activeBodies(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_244_activeBodies)
HXDLIN( 244)		int _g = 0;
HXDLIN( 244)		::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 244)		while((_g < _g1->length)){
HXDLIN( 244)			 ::zpp_nape::constraint::ZPP_UserBody b = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 244)			_g = (_g + 1);
HXLINE( 245)			if (hx::IsNotNull( b->body )) {
HXLINE( 245)				b->body->constraints->add(hx::ObjectPtr<OBJ_>(this));
            			}
            		}
            	}


void ZPP_UserConstraint_obj::inactiveBodies(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_249_inactiveBodies)
HXDLIN( 249)		int _g = 0;
HXDLIN( 249)		::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 249)		while((_g < _g1->length)){
HXDLIN( 249)			 ::zpp_nape::constraint::ZPP_UserBody b = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 249)			_g = (_g + 1);
HXLINE( 250)			if (hx::IsNotNull( b->body )) {
HXLINE( 250)				b->body->constraints->remove(hx::ObjectPtr<OBJ_>(this));
            			}
            		}
            	}


 ::nape::constraint::Constraint ZPP_UserConstraint_obj::copy(::Array< ::Dynamic> dict,::Array< ::Dynamic> todo){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_254_copy)
HXLINE( 255)		 ::nape::constraint::UserConstraint ret = this->outer_zn->__copy();
HXLINE( 256)		this->copyto(ret);
HXLINE( 257)		HX_STACK_DO_THROW(HX_("not done yet",37,63,5d,38));
HXDLIN( 257)		return null();
            	}


void ZPP_UserConstraint_obj::validate(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_295_validate)
HXLINE( 296)		{
HXLINE( 296)			int _g = 0;
HXDLIN( 296)			::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 296)			while((_g < _g1->length)){
HXLINE( 296)				 ::zpp_nape::constraint::ZPP_UserBody b = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 296)				_g = (_g + 1);
HXDLIN( 296)				if (hx::IsNotEq( b->body->space,this->space )) {
HXLINE( 296)					HX_STACK_DO_THROW(HX_("Error: Constraints must have each body within the same sapce to which the constraint has been assigned",e6,bc,3b,9a));
            				}
            			}
            		}
HXLINE( 297)		this->outer_zn->_hx___validate();
            	}


void ZPP_UserConstraint_obj::wake_connected(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_300_wake_connected)
HXDLIN( 300)		int _g = 0;
HXDLIN( 300)		::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 300)		while((_g < _g1->length)){
HXDLIN( 300)			 ::zpp_nape::constraint::ZPP_UserBody b = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 300)			_g = (_g + 1);
HXLINE( 301)			if ((b->body->type == 2)) {
HXLINE( 301)				b->body->wake();
            			}
            		}
            	}


void ZPP_UserConstraint_obj::forest(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_305_forest)
HXDLIN( 305)		int _g = 0;
HXDLIN( 305)		::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 305)		while((_g < _g1->length)){
HXDLIN( 305)			 ::zpp_nape::constraint::ZPP_UserBody b = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 305)			_g = (_g + 1);
HXLINE( 306)			if ((b->body->type == 2)) {
HXLINE( 307)				 ::zpp_nape::space::ZPP_Component xr;
HXDLIN( 307)				if (hx::IsEq( b->body->component,b->body->component->parent )) {
HXLINE( 307)					xr = b->body->component;
            				}
            				else {
HXLINE( 310)					 ::zpp_nape::space::ZPP_Component obj = b->body->component;
HXLINE( 311)					 ::zpp_nape::space::ZPP_Component stack = null();
HXLINE( 312)					while(hx::IsNotEq( obj,obj->parent )){
HXLINE( 313)						 ::zpp_nape::space::ZPP_Component nxt = obj->parent;
HXLINE( 314)						obj->parent = stack;
HXLINE( 315)						stack = obj;
HXLINE( 316)						obj = nxt;
            					}
HXLINE( 318)					while(hx::IsNotNull( stack )){
HXLINE( 319)						 ::zpp_nape::space::ZPP_Component nxt1 = stack->parent;
HXLINE( 320)						stack->parent = obj;
HXLINE( 321)						stack = nxt1;
            					}
HXLINE( 307)					xr = obj;
            				}
HXLINE( 326)				 ::zpp_nape::space::ZPP_Component yr;
HXDLIN( 326)				if (hx::IsEq( this->component,this->component->parent )) {
HXLINE( 326)					yr = this->component;
            				}
            				else {
HXLINE( 329)					 ::zpp_nape::space::ZPP_Component obj1 = this->component;
HXLINE( 330)					 ::zpp_nape::space::ZPP_Component stack1 = null();
HXLINE( 331)					while(hx::IsNotEq( obj1,obj1->parent )){
HXLINE( 332)						 ::zpp_nape::space::ZPP_Component nxt2 = obj1->parent;
HXLINE( 333)						obj1->parent = stack1;
HXLINE( 334)						stack1 = obj1;
HXLINE( 335)						obj1 = nxt2;
            					}
HXLINE( 337)					while(hx::IsNotNull( stack1 )){
HXLINE( 338)						 ::zpp_nape::space::ZPP_Component nxt3 = stack1->parent;
HXLINE( 339)						stack1->parent = obj1;
HXLINE( 340)						stack1 = nxt3;
            					}
HXLINE( 326)					yr = obj1;
            				}
HXLINE( 345)				if (hx::IsNotEq( xr,yr )) {
HXLINE( 346)					if ((xr->rank < yr->rank)) {
HXLINE( 346)						xr->parent = yr;
            					}
            					else {
HXLINE( 347)						if ((xr->rank > yr->rank)) {
HXLINE( 347)							yr->parent = xr;
            						}
            						else {
HXLINE( 349)							yr->parent = xr;
HXLINE( 350)							xr->rank++;
            						}
            					}
            				}
            			}
            		}
            	}


bool ZPP_UserConstraint_obj::pair_exists(int id,int di){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_356_pair_exists)
HXLINE( 357)		bool ret = false;
HXLINE( 358)		int bl = ::Std_obj::_hx_int(( (Float)(this->bodies->length) ));
HXLINE( 359)		{
HXLINE( 359)			int _g = 0;
HXDLIN( 359)			int _g1 = bl;
HXDLIN( 359)			while((_g < _g1)){
HXLINE( 359)				_g = (_g + 1);
HXDLIN( 359)				int bi = (_g - 1);
HXLINE( 360)				 ::zpp_nape::phys::ZPP_Body b = this->bodies->__get(bi).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >()->body;
HXLINE( 361)				{
HXLINE( 361)					int _g2 = (bi + 1);
HXDLIN( 361)					int _g11 = bl;
HXDLIN( 361)					while((_g2 < _g11)){
HXLINE( 361)						_g2 = (_g2 + 1);
HXDLIN( 361)						int ci = (_g2 - 1);
HXLINE( 362)						 ::zpp_nape::phys::ZPP_Body c = this->bodies->__get(ci).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >()->body;
HXLINE( 363)						bool _hx_tmp;
HXDLIN( 363)						bool _hx_tmp1;
HXDLIN( 363)						if ((b->id == id)) {
HXLINE( 363)							_hx_tmp1 = (c->id == di);
            						}
            						else {
HXLINE( 363)							_hx_tmp1 = false;
            						}
HXDLIN( 363)						if (!(_hx_tmp1)) {
HXLINE( 363)							if ((b->id == di)) {
HXLINE( 363)								_hx_tmp = (c->id == id);
            							}
            							else {
HXLINE( 363)								_hx_tmp = false;
            							}
            						}
            						else {
HXLINE( 363)							_hx_tmp = true;
            						}
HXDLIN( 363)						if (_hx_tmp) {
HXLINE( 364)							ret = true;
HXLINE( 365)							goto _hx_goto_26;
            						}
            					}
            					_hx_goto_26:;
            				}
HXLINE( 368)				if (ret) {
HXLINE( 368)					goto _hx_goto_25;
            				}
            			}
            			_hx_goto_25:;
            		}
HXLINE( 370)		return ret;
            	}


void ZPP_UserConstraint_obj::broken(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_373_broken)
HXDLIN( 373)		this->outer_zn->_hx___broken();
            	}


void ZPP_UserConstraint_obj::clearcache(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_375_clearcache)
HXLINE( 376)		{
HXLINE( 376)			int _g = 0;
HXDLIN( 376)			int _g1 = this->dim;
HXDLIN( 376)			while((_g < _g1)){
HXLINE( 376)				_g = (_g + 1);
HXDLIN( 376)				int i = (_g - 1);
HXDLIN( 376)				this->jAcc[i] = ((Float)0.0);
            			}
            		}
HXLINE( 377)		this->pre_dt = ((Float)-1.0);
            	}


Float ZPP_UserConstraint_obj::lsq(::Array< Float > v){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_379_lsq)
HXLINE( 380)		Float sum = ((Float)0.0);
HXLINE( 381)		{
HXLINE( 381)			int _g = 0;
HXDLIN( 381)			int _g1 = this->dim;
HXDLIN( 381)			while((_g < _g1)){
HXLINE( 381)				_g = (_g + 1);
HXDLIN( 381)				int i = (_g - 1);
HXDLIN( 381)				sum = (sum + (v->__get(i) * v->__get(i)));
            			}
            		}
HXLINE( 382)		return sum;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_UserConstraint_obj,lsq,return )

void ZPP_UserConstraint_obj::_clamp(::Array< Float > v,Float max){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_384__clamp)
HXLINE( 385)		Float x = this->lsq(v);
HXLINE( 386)		if ((x > (max * max))) {
HXLINE( 387)			Float scale = (max / ::Math_obj::sqrt(x));
HXLINE( 388)			{
HXLINE( 388)				int _g = 0;
HXDLIN( 388)				int _g1 = this->dim;
HXDLIN( 388)				while((_g < _g1)){
HXLINE( 388)					_g = (_g + 1);
HXDLIN( 388)					int i = (_g - 1);
HXDLIN( 388)					::Array< Float > v1 = v;
HXDLIN( 388)					int i1 = i;
HXDLIN( 388)					v1[i1] = (v1->__get(i1) * scale);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(ZPP_UserConstraint_obj,_clamp,(void))

::Array< Float > ZPP_UserConstraint_obj::solve(::Array< Float > m){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_392_solve)
HXLINE( 393)		int ind = 0;
HXLINE( 394)		{
HXLINE( 394)			int _g = 0;
HXDLIN( 394)			int _g1 = this->dim;
HXDLIN( 394)			while((_g < _g1)){
HXLINE( 394)				_g = (_g + 1);
HXDLIN( 394)				int j = (_g - 1);
HXLINE( 395)				Float sum = ((Float)0.0);
HXLINE( 396)				{
HXLINE( 396)					int _g2 = 0;
HXDLIN( 396)					int _g11 = (j - 1);
HXDLIN( 396)					while((_g2 < _g11)){
HXLINE( 396)						_g2 = (_g2 + 1);
HXDLIN( 396)						int k = (_g2 - 1);
HXDLIN( 396)						sum = (sum + (this->L->__get(((j * this->dim) + k)) * this->L->__get(((j * this->dim) + k))));
            					}
            				}
HXLINE( 397)				ind = (ind + 1);
HXDLIN( 397)				Float rec = ::Math_obj::sqrt((m->__get((ind - 1)) - sum));
HXLINE( 398)				this->L[((j * this->dim) + j)] = rec;
HXLINE( 399)				if ((rec != 0)) {
HXLINE( 400)					rec = (((Float)1.0) / rec);
HXLINE( 401)					{
HXLINE( 401)						int _g21 = (j + 1);
HXDLIN( 401)						int _g3 = this->dim;
HXDLIN( 401)						while((_g21 < _g3)){
HXLINE( 401)							_g21 = (_g21 + 1);
HXDLIN( 401)							int i = (_g21 - 1);
HXLINE( 402)							Float sum1 = ((Float)0.0);
HXLINE( 403)							{
HXLINE( 403)								int _g22 = 0;
HXDLIN( 403)								int _g31 = (j - 1);
HXDLIN( 403)								while((_g22 < _g31)){
HXLINE( 403)									_g22 = (_g22 + 1);
HXDLIN( 403)									int k1 = (_g22 - 1);
HXDLIN( 403)									sum1 = (sum1 + (this->L->__get(((i * this->dim) + k1)) * this->L->__get(((j * this->dim) + k1))));
            								}
            							}
HXLINE( 404)							ind = (ind + 1);
HXDLIN( 404)							this->L[((i * this->dim) + j)] = (rec * (m->__get((ind - 1)) - sum1));
            						}
            					}
            				}
            				else {
HXLINE( 408)					{
HXLINE( 408)						int _g23 = (j + 1);
HXDLIN( 408)						int _g32 = this->dim;
HXDLIN( 408)						while((_g23 < _g32)){
HXLINE( 408)							_g23 = (_g23 + 1);
HXDLIN( 408)							int i1 = (_g23 - 1);
HXDLIN( 408)							this->L[((i1 * this->dim) + j)] = ((Float)0.0);
            						}
            					}
HXLINE( 409)					ind = (ind + ((this->dim - j) - 1));
            				}
            			}
            		}
HXLINE( 412)		return this->L;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ZPP_UserConstraint_obj,solve,return )

void ZPP_UserConstraint_obj::transform(::Array< Float > L,::Array< Float > x){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_415_transform)
HXLINE( 416)		{
HXLINE( 416)			int _g = 0;
HXDLIN( 416)			int _g1 = this->dim;
HXDLIN( 416)			while((_g < _g1)){
HXLINE( 416)				_g = (_g + 1);
HXDLIN( 416)				int i = (_g - 1);
HXLINE( 417)				Float sum = x->__get(i);
HXLINE( 418)				Float lii = L->__get(((i * this->dim) + i));
HXLINE( 419)				if ((lii != 0)) {
HXLINE( 420)					{
HXLINE( 420)						int _g2 = 0;
HXDLIN( 420)						int _g11 = i;
HXDLIN( 420)						while((_g2 < _g11)){
HXLINE( 420)							_g2 = (_g2 + 1);
HXDLIN( 420)							int k = (_g2 - 1);
HXDLIN( 420)							sum = (sum - (L->__get(((i * this->dim) + k)) * this->y->__get(k)));
            						}
            					}
HXLINE( 421)					this->y[i] = (sum / lii);
            				}
            				else {
HXLINE( 423)					this->y[i] = ((Float)0.0);
            				}
            			}
            		}
HXLINE( 425)		{
HXLINE( 425)			int _g21 = 0;
HXDLIN( 425)			int _g3 = this->dim;
HXDLIN( 425)			while((_g21 < _g3)){
HXLINE( 425)				_g21 = (_g21 + 1);
HXDLIN( 425)				int ix = (_g21 - 1);
HXLINE( 426)				int i1 = ((this->dim - 1) - ix);
HXLINE( 427)				Float lii1 = L->__get(((i1 * this->dim) + i1));
HXLINE( 428)				if ((lii1 != 0)) {
HXLINE( 429)					Float sum1 = this->y->__get(i1);
HXLINE( 430)					{
HXLINE( 430)						int _g22 = (i1 + 1);
HXDLIN( 430)						int _g31 = this->dim;
HXDLIN( 430)						while((_g22 < _g31)){
HXLINE( 430)							_g22 = (_g22 + 1);
HXDLIN( 430)							int k1 = (_g22 - 1);
HXDLIN( 430)							sum1 = (sum1 - (L->__get(((k1 * this->dim) + i1)) * x->__get(k1)));
            						}
            					}
HXLINE( 431)					x[i1] = (sum1 / lii1);
            				}
            				else {
HXLINE( 433)					x[i1] = ((Float)0.0);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(ZPP_UserConstraint_obj,transform,(void))

bool ZPP_UserConstraint_obj::preStep(Float dt){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_441_preStep)
HXLINE( 445)		if ((this->pre_dt == ((Float)-1.0))) {
HXLINE( 445)			this->pre_dt = dt;
            		}
HXLINE( 446)		Float dtratio = (dt / this->pre_dt);
HXLINE( 447)		this->pre_dt = dt;
HXLINE( 448)		this->stepped = true;
HXLINE( 449)		this->outer_zn->_hx___prepare();
HXLINE( 450)		this->outer_zn->_hx___eff_mass(this->Keff);
HXLINE( 451)		this->L = this->solve(this->Keff);
HXLINE( 452)		bool _hx_tmp;
HXDLIN( 452)		if (!(this->stiff)) {
HXLINE( 452)			_hx_tmp = !(this->velonly);
            		}
            		else {
HXLINE( 452)			_hx_tmp = false;
            		}
HXDLIN( 452)		if (_hx_tmp) {
HXLINE( 455)			Float omega = ((( (Float)(2) ) * ::Math_obj::PI) * this->frequency);
HXLINE( 456)			this->gamma = (( (Float)(1) ) / ((dt * omega) * ((( (Float)(2) ) * this->damping) + (omega * dt))));
HXLINE( 457)			Float ig = (( (Float)(1) ) / (1 + this->gamma));
HXLINE( 453)			Float biasCoef = (((dt * omega) * omega) * this->gamma);
HXLINE( 459)			 ::zpp_nape::constraint::ZPP_UserConstraint _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 459)			_hx_tmp1->gamma = (_hx_tmp1->gamma * ig);
HXLINE( 454)			this->soft = ig;
HXLINE( 462)			this->outer_zn->_hx___position(this->bias);
HXLINE( 463)			bool _hx_tmp2;
HXDLIN( 463)			if (this->breakUnderError) {
HXLINE( 463)				Float _hx_tmp3 = this->lsq(this->bias);
HXDLIN( 463)				_hx_tmp2 = (_hx_tmp3 > (this->maxError * this->maxError));
            			}
            			else {
HXLINE( 463)				_hx_tmp2 = false;
            			}
HXDLIN( 463)			if (_hx_tmp2) {
HXLINE( 463)				return true;
            			}
HXLINE( 464)			{
HXLINE( 464)				int _g = 0;
HXDLIN( 464)				int _g1 = this->dim;
HXDLIN( 464)				while((_g < _g1)){
HXLINE( 464)					_g = (_g + 1);
HXDLIN( 464)					int i = (_g - 1);
HXDLIN( 464)					::Array< Float > _hx_tmp4 = this->bias;
HXDLIN( 464)					int i1 = i;
HXDLIN( 464)					_hx_tmp4[i1] = (_hx_tmp4->__get(i1) * -(biasCoef));
            				}
            			}
HXLINE( 465)			this->_clamp(this->bias,this->maxError);
            		}
            		else {
HXLINE( 468)			{
HXLINE( 468)				int _g2 = 0;
HXDLIN( 468)				int _g11 = this->dim;
HXDLIN( 468)				while((_g2 < _g11)){
HXLINE( 468)					_g2 = (_g2 + 1);
HXDLIN( 468)					int i2 = (_g2 - 1);
HXDLIN( 468)					this->bias[i2] = ((Float)0.0);
            				}
            			}
HXLINE( 469)			this->gamma = ((Float)0.0);
HXLINE( 470)			this->soft = ((Float)1.0);
            		}
HXLINE( 472)		{
HXLINE( 472)			int _g3 = 0;
HXDLIN( 472)			int _g12 = this->dim;
HXDLIN( 472)			while((_g3 < _g12)){
HXLINE( 472)				_g3 = (_g3 + 1);
HXDLIN( 472)				int i3 = (_g3 - 1);
HXDLIN( 472)				::Array< Float > _hx_tmp5 = this->jAcc;
HXDLIN( 472)				int i4 = i3;
HXDLIN( 472)				_hx_tmp5[i4] = (_hx_tmp5->__get(i4) * dtratio);
            			}
            		}
HXLINE( 473)		this->jMax = (this->maxForce * dt);
HXLINE( 474)		return false;
            	}


void ZPP_UserConstraint_obj::warmStart(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_478_warmStart)
HXDLIN( 478)		int _g = 0;
HXDLIN( 478)		::Array< ::Dynamic> _g1 = this->bodies;
HXDLIN( 478)		while((_g < _g1->length)){
HXDLIN( 478)			 ::zpp_nape::constraint::ZPP_UserBody bs = _g1->__get(_g).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 478)			_g = (_g + 1);
HXLINE( 479)			 ::zpp_nape::phys::ZPP_Body b = bs->body;
HXLINE( 480)			this->outer_zn->_hx___impulse(this->jAcc,b->outer,this->vec3);
HXLINE( 481)			{
HXLINE( 482)				Float t = b->imass;
HXLINE( 491)				 ::zpp_nape::phys::ZPP_Body b1 = b;
HXDLIN( 491)				Float b2 = b1->velx;
HXDLIN( 491)				 ::nape::geom::Vec3 _this = this->vec3;
HXDLIN( 491)				bool _hx_tmp;
HXDLIN( 491)				if (hx::IsNotNull( _this )) {
HXLINE( 491)					_hx_tmp = _this->zpp_disp;
            				}
            				else {
HXLINE( 491)					_hx_tmp = false;
            				}
HXDLIN( 491)				if (_hx_tmp) {
HXLINE( 491)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 491)				{
HXLINE( 491)					 ::zpp_nape::geom::ZPP_Vec3 _this1 = _this->zpp_inner;
HXDLIN( 491)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 491)						_this1->_validate();
            					}
            				}
HXDLIN( 491)				b1->velx = (b2 + (_this->zpp_inner->x * t));
HXLINE( 492)				 ::zpp_nape::phys::ZPP_Body b3 = b;
HXDLIN( 492)				Float b4 = b3->vely;
HXDLIN( 492)				 ::nape::geom::Vec3 _this2 = this->vec3;
HXDLIN( 492)				bool _hx_tmp1;
HXDLIN( 492)				if (hx::IsNotNull( _this2 )) {
HXLINE( 492)					_hx_tmp1 = _this2->zpp_disp;
            				}
            				else {
HXLINE( 492)					_hx_tmp1 = false;
            				}
HXDLIN( 492)				if (_hx_tmp1) {
HXLINE( 492)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 492)				{
HXLINE( 492)					 ::zpp_nape::geom::ZPP_Vec3 _this3 = _this2->zpp_inner;
HXDLIN( 492)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 492)						_this3->_validate();
            					}
            				}
HXDLIN( 492)				b3->vely = (b4 + (_this2->zpp_inner->y * t));
            			}
HXLINE( 494)			 ::zpp_nape::phys::ZPP_Body b5 = b;
HXDLIN( 494)			Float b6 = b5->angvel;
HXDLIN( 494)			 ::nape::geom::Vec3 _this4 = this->vec3;
HXDLIN( 494)			bool _hx_tmp2;
HXDLIN( 494)			if (hx::IsNotNull( _this4 )) {
HXLINE( 494)				_hx_tmp2 = _this4->zpp_disp;
            			}
            			else {
HXLINE( 494)				_hx_tmp2 = false;
            			}
HXDLIN( 494)			if (_hx_tmp2) {
HXLINE( 494)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 494)			{
HXLINE( 494)				 ::zpp_nape::geom::ZPP_Vec3 _this5 = _this4->zpp_inner;
HXDLIN( 494)				if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 494)					_this5->_validate();
            				}
            			}
HXDLIN( 494)			b5->angvel = (b6 + (_this4->zpp_inner->z * b->iinertia));
            		}
            	}


bool ZPP_UserConstraint_obj::applyImpulseVel(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_499_applyImpulseVel)
HXLINE( 500)		this->outer_zn->_hx___velocity(this->J);
HXLINE( 501)		{
HXLINE( 501)			int _g = 0;
HXDLIN( 501)			int _g1 = this->dim;
HXDLIN( 501)			while((_g < _g1)){
HXLINE( 501)				_g = (_g + 1);
HXDLIN( 501)				int i = (_g - 1);
HXDLIN( 501)				this->J[i] = (this->bias->__get(i) - this->J->__get(i));
            			}
            		}
HXLINE( 502)		this->transform(this->L,this->J);
HXLINE( 503)		{
HXLINE( 503)			int _g2 = 0;
HXDLIN( 503)			int _g3 = this->dim;
HXDLIN( 503)			while((_g2 < _g3)){
HXLINE( 503)				_g2 = (_g2 + 1);
HXDLIN( 503)				int i1 = (_g2 - 1);
HXLINE( 504)				this->jOld[i1] = this->jAcc->__get(i1);
HXLINE( 505)				::Array< Float > _hx_tmp = this->jAcc;
HXDLIN( 505)				int i2 = i1;
HXDLIN( 505)				Float _hx_tmp1 = _hx_tmp->__get(i2);
HXDLIN( 505)				_hx_tmp[i2] = (_hx_tmp1 + (this->J[i1] = ((this->J->__get(i1) * this->soft) - (this->jAcc->__get(i1) * this->gamma))));
            			}
            		}
HXLINE( 507)		this->outer_zn->_hx___clamp(this->jAcc);
HXLINE( 508)		bool _hx_tmp2;
HXDLIN( 508)		bool _hx_tmp3;
HXDLIN( 508)		if (!(this->breakUnderForce)) {
HXLINE( 508)			_hx_tmp3 = !(this->stiff);
            		}
            		else {
HXLINE( 508)			_hx_tmp3 = true;
            		}
HXDLIN( 508)		if (_hx_tmp3) {
HXLINE( 508)			Float _hx_tmp4 = this->lsq(this->jAcc);
HXDLIN( 508)			_hx_tmp2 = (_hx_tmp4 > (this->jMax * this->jMax));
            		}
            		else {
HXLINE( 508)			_hx_tmp2 = false;
            		}
HXDLIN( 508)		if (_hx_tmp2) {
HXLINE( 509)			if (this->breakUnderForce) {
HXLINE( 509)				return true;
            			}
            			else {
HXLINE( 510)				if (!(this->stiff)) {
HXLINE( 510)					this->_clamp(this->jAcc,this->jMax);
            				}
            			}
            		}
HXLINE( 512)		{
HXLINE( 512)			int _g4 = 0;
HXDLIN( 512)			int _g5 = this->dim;
HXDLIN( 512)			while((_g4 < _g5)){
HXLINE( 512)				_g4 = (_g4 + 1);
HXDLIN( 512)				int i3 = (_g4 - 1);
HXDLIN( 512)				this->J[i3] = (this->jAcc->__get(i3) - this->jOld->__get(i3));
            			}
            		}
HXLINE( 513)		{
HXLINE( 513)			int _g6 = 0;
HXDLIN( 513)			::Array< ::Dynamic> _g7 = this->bodies;
HXDLIN( 513)			while((_g6 < _g7->length)){
HXLINE( 513)				 ::zpp_nape::constraint::ZPP_UserBody bs = _g7->__get(_g6).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 513)				_g6 = (_g6 + 1);
HXLINE( 514)				 ::zpp_nape::phys::ZPP_Body b = bs->body;
HXLINE( 515)				this->outer_zn->_hx___impulse(this->J,b->outer,this->vec3);
HXLINE( 516)				{
HXLINE( 517)					Float t = b->imass;
HXLINE( 526)					 ::zpp_nape::phys::ZPP_Body b1 = b;
HXDLIN( 526)					Float b2 = b1->velx;
HXDLIN( 526)					 ::nape::geom::Vec3 _this = this->vec3;
HXDLIN( 526)					bool _hx_tmp5;
HXDLIN( 526)					if (hx::IsNotNull( _this )) {
HXLINE( 526)						_hx_tmp5 = _this->zpp_disp;
            					}
            					else {
HXLINE( 526)						_hx_tmp5 = false;
            					}
HXDLIN( 526)					if (_hx_tmp5) {
HXLINE( 526)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 526)					{
HXLINE( 526)						 ::zpp_nape::geom::ZPP_Vec3 _this1 = _this->zpp_inner;
HXDLIN( 526)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 526)							_this1->_validate();
            						}
            					}
HXDLIN( 526)					b1->velx = (b2 + (_this->zpp_inner->x * t));
HXLINE( 527)					 ::zpp_nape::phys::ZPP_Body b3 = b;
HXDLIN( 527)					Float b4 = b3->vely;
HXDLIN( 527)					 ::nape::geom::Vec3 _this2 = this->vec3;
HXDLIN( 527)					bool _hx_tmp6;
HXDLIN( 527)					if (hx::IsNotNull( _this2 )) {
HXLINE( 527)						_hx_tmp6 = _this2->zpp_disp;
            					}
            					else {
HXLINE( 527)						_hx_tmp6 = false;
            					}
HXDLIN( 527)					if (_hx_tmp6) {
HXLINE( 527)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 527)					{
HXLINE( 527)						 ::zpp_nape::geom::ZPP_Vec3 _this3 = _this2->zpp_inner;
HXDLIN( 527)						if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 527)							_this3->_validate();
            						}
            					}
HXDLIN( 527)					b3->vely = (b4 + (_this2->zpp_inner->y * t));
            				}
HXLINE( 529)				 ::zpp_nape::phys::ZPP_Body b5 = b;
HXDLIN( 529)				Float b6 = b5->angvel;
HXDLIN( 529)				 ::nape::geom::Vec3 _this4 = this->vec3;
HXDLIN( 529)				bool _hx_tmp7;
HXDLIN( 529)				if (hx::IsNotNull( _this4 )) {
HXLINE( 529)					_hx_tmp7 = _this4->zpp_disp;
            				}
            				else {
HXLINE( 529)					_hx_tmp7 = false;
            				}
HXDLIN( 529)				if (_hx_tmp7) {
HXLINE( 529)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 529)				{
HXLINE( 529)					 ::zpp_nape::geom::ZPP_Vec3 _this5 = _this4->zpp_inner;
HXDLIN( 529)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 529)						_this5->_validate();
            					}
            				}
HXDLIN( 529)				b5->angvel = (b6 + (_this4->zpp_inner->z * b->iinertia));
            			}
            		}
HXLINE( 531)		return false;
            	}


bool ZPP_UserConstraint_obj::applyImpulsePos(){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_533_applyImpulsePos)
HXLINE( 534)		if (this->velonly) {
HXLINE( 534)			return false;
            		}
HXLINE( 535)		this->outer_zn->_hx___prepare();
HXLINE( 536)		this->outer_zn->_hx___position(this->J);
HXLINE( 537)		Float lj = this->lsq(this->J);
HXLINE( 538)		bool _hx_tmp;
HXDLIN( 538)		if (this->breakUnderError) {
HXLINE( 538)			_hx_tmp = (lj > (this->maxError * this->maxError));
            		}
            		else {
HXLINE( 538)			_hx_tmp = false;
            		}
HXDLIN( 538)		if (_hx_tmp) {
HXLINE( 538)			return true;
            		}
            		else {
HXLINE( 539)			if ((lj < (::nape::Config_obj::constraintLinearSlop * ::nape::Config_obj::constraintLinearSlop))) {
HXLINE( 539)				return false;
            			}
            		}
HXLINE( 540)		{
HXLINE( 540)			int _g = 0;
HXDLIN( 540)			int _g1 = this->dim;
HXDLIN( 540)			while((_g < _g1)){
HXLINE( 540)				_g = (_g + 1);
HXDLIN( 540)				int i = (_g - 1);
HXDLIN( 540)				::Array< Float > _hx_tmp1 = this->J;
HXDLIN( 540)				int i1 = i;
HXDLIN( 540)				_hx_tmp1[i1] = (_hx_tmp1->__get(i1) * ( (Float)(-1) ));
            			}
            		}
HXLINE( 541)		this->outer_zn->_hx___eff_mass(this->Keff);
HXLINE( 542)		::Array< Float > _hx_tmp2 = this->solve(this->Keff);
HXDLIN( 542)		this->transform(_hx_tmp2,this->J);
HXLINE( 543)		this->outer_zn->_hx___clamp(this->J);
HXLINE( 544)		{
HXLINE( 544)			int _g2 = 0;
HXDLIN( 544)			::Array< ::Dynamic> _g3 = this->bodies;
HXDLIN( 544)			while((_g2 < _g3->length)){
HXLINE( 544)				 ::zpp_nape::constraint::ZPP_UserBody bs = _g3->__get(_g2).StaticCast<  ::zpp_nape::constraint::ZPP_UserBody >();
HXDLIN( 544)				_g2 = (_g2 + 1);
HXLINE( 545)				 ::zpp_nape::phys::ZPP_Body b = bs->body;
HXLINE( 546)				this->outer_zn->_hx___impulse(this->J,b->outer,this->vec3);
HXLINE( 547)				{
HXLINE( 548)					Float t = b->imass;
HXLINE( 557)					 ::zpp_nape::phys::ZPP_Body b1 = b;
HXDLIN( 557)					Float b2 = b1->posx;
HXDLIN( 557)					 ::nape::geom::Vec3 _this = this->vec3;
HXDLIN( 557)					bool _hx_tmp3;
HXDLIN( 557)					if (hx::IsNotNull( _this )) {
HXLINE( 557)						_hx_tmp3 = _this->zpp_disp;
            					}
            					else {
HXLINE( 557)						_hx_tmp3 = false;
            					}
HXDLIN( 557)					if (_hx_tmp3) {
HXLINE( 557)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 557)					{
HXLINE( 557)						 ::zpp_nape::geom::ZPP_Vec3 _this1 = _this->zpp_inner;
HXDLIN( 557)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 557)							_this1->_validate();
            						}
            					}
HXDLIN( 557)					b1->posx = (b2 + (_this->zpp_inner->x * t));
HXLINE( 558)					 ::zpp_nape::phys::ZPP_Body b3 = b;
HXDLIN( 558)					Float b4 = b3->posy;
HXDLIN( 558)					 ::nape::geom::Vec3 _this2 = this->vec3;
HXDLIN( 558)					bool _hx_tmp4;
HXDLIN( 558)					if (hx::IsNotNull( _this2 )) {
HXLINE( 558)						_hx_tmp4 = _this2->zpp_disp;
            					}
            					else {
HXLINE( 558)						_hx_tmp4 = false;
            					}
HXDLIN( 558)					if (_hx_tmp4) {
HXLINE( 558)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 558)					{
HXLINE( 558)						 ::zpp_nape::geom::ZPP_Vec3 _this3 = _this2->zpp_inner;
HXDLIN( 558)						if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 558)							_this3->_validate();
            						}
            					}
HXDLIN( 558)					b3->posy = (b4 + (_this2->zpp_inner->y * t));
            				}
HXLINE( 560)				{
HXLINE( 560)					 ::nape::geom::Vec3 _this4 = this->vec3;
HXDLIN( 560)					bool dr;
HXDLIN( 560)					if (hx::IsNotNull( _this4 )) {
HXLINE( 560)						dr = _this4->zpp_disp;
            					}
            					else {
HXLINE( 560)						dr = false;
            					}
HXDLIN( 560)					if (dr) {
HXLINE( 560)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 560)					{
HXLINE( 560)						 ::zpp_nape::geom::ZPP_Vec3 _this5 = _this4->zpp_inner;
HXDLIN( 560)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 560)							_this5->_validate();
            						}
            					}
HXDLIN( 560)					Float dr1 = (_this4->zpp_inner->z * b->iinertia);
HXDLIN( 560)					 ::zpp_nape::phys::ZPP_Body b5 = b;
HXDLIN( 560)					b5->rot = (b5->rot + dr1);
HXDLIN( 560)					if (((dr1 * dr1) > ((Float)0.0001))) {
HXLINE( 560)						b->axisx = ::Math_obj::sin(b->rot);
HXDLIN( 560)						b->axisy = ::Math_obj::cos(b->rot);
            					}
            					else {
HXLINE( 560)						Float d2 = (dr1 * dr1);
HXDLIN( 560)						Float p = (( (Float)(1) ) - (((Float)0.5) * d2));
HXDLIN( 560)						Float m = (( (Float)(1) ) - ((d2 * d2) / ( (Float)(8) )));
HXDLIN( 560)						Float nx = (((p * b->axisx) + (dr1 * b->axisy)) * m);
HXDLIN( 560)						b->axisy = (((p * b->axisy) - (dr1 * b->axisx)) * m);
HXDLIN( 560)						b->axisx = nx;
            					}
            				}
            			}
            		}
HXLINE( 562)		return false;
            	}


void ZPP_UserConstraint_obj::draw( ::nape::util::Debug g){
            	HX_STACKFRAME(&_hx_pos_62fa6ce655c689ca_565_draw)
HXDLIN( 565)		this->outer_zn->_hx___draw(g);
            	}



hx::ObjectPtr< ZPP_UserConstraint_obj > ZPP_UserConstraint_obj::__new(int dim,bool velonly) {
	hx::ObjectPtr< ZPP_UserConstraint_obj > __this = new ZPP_UserConstraint_obj();
	__this->__construct(dim,velonly);
	return __this;
}

hx::ObjectPtr< ZPP_UserConstraint_obj > ZPP_UserConstraint_obj::__alloc(hx::Ctx *_hx_ctx,int dim,bool velonly) {
	ZPP_UserConstraint_obj *__this = (ZPP_UserConstraint_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ZPP_UserConstraint_obj), true, "zpp_nape.constraint.ZPP_UserConstraint"));
	*(void **)__this = ZPP_UserConstraint_obj::_hx_vtable;
	__this->__construct(dim,velonly);
	return __this;
}

ZPP_UserConstraint_obj::ZPP_UserConstraint_obj()
{
}

void ZPP_UserConstraint_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ZPP_UserConstraint);
	HX_MARK_MEMBER_NAME(outer_zn,"outer_zn");
	HX_MARK_MEMBER_NAME(bodies,"bodies");
	HX_MARK_MEMBER_NAME(dim,"dim");
	HX_MARK_MEMBER_NAME(jAcc,"jAcc");
	HX_MARK_MEMBER_NAME(bias,"bias");
	HX_MARK_MEMBER_NAME(stepped,"stepped");
	HX_MARK_MEMBER_NAME(L,"L");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(soft,"soft");
	HX_MARK_MEMBER_NAME(gamma,"gamma");
	HX_MARK_MEMBER_NAME(velonly,"velonly");
	HX_MARK_MEMBER_NAME(jMax,"jMax");
	HX_MARK_MEMBER_NAME(Keff,"Keff");
	HX_MARK_MEMBER_NAME(vec3,"vec3");
	HX_MARK_MEMBER_NAME(J,"J");
	HX_MARK_MEMBER_NAME(jOld,"jOld");
	 ::zpp_nape::constraint::ZPP_Constraint_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ZPP_UserConstraint_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(outer_zn,"outer_zn");
	HX_VISIT_MEMBER_NAME(bodies,"bodies");
	HX_VISIT_MEMBER_NAME(dim,"dim");
	HX_VISIT_MEMBER_NAME(jAcc,"jAcc");
	HX_VISIT_MEMBER_NAME(bias,"bias");
	HX_VISIT_MEMBER_NAME(stepped,"stepped");
	HX_VISIT_MEMBER_NAME(L,"L");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(soft,"soft");
	HX_VISIT_MEMBER_NAME(gamma,"gamma");
	HX_VISIT_MEMBER_NAME(velonly,"velonly");
	HX_VISIT_MEMBER_NAME(jMax,"jMax");
	HX_VISIT_MEMBER_NAME(Keff,"Keff");
	HX_VISIT_MEMBER_NAME(vec3,"vec3");
	HX_VISIT_MEMBER_NAME(J,"J");
	HX_VISIT_MEMBER_NAME(jOld,"jOld");
	 ::zpp_nape::constraint::ZPP_Constraint_obj::__Visit(HX_VISIT_ARG);
}

hx::Val ZPP_UserConstraint_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"L") ) { return hx::Val( L ); }
		if (HX_FIELD_EQ(inName,"y") ) { return hx::Val( y ); }
		if (HX_FIELD_EQ(inName,"J") ) { return hx::Val( J ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"dim") ) { return hx::Val( dim ); }
		if (HX_FIELD_EQ(inName,"lsq") ) { return hx::Val( lsq_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"jAcc") ) { return hx::Val( jAcc ); }
		if (HX_FIELD_EQ(inName,"bias") ) { return hx::Val( bias ); }
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		if (HX_FIELD_EQ(inName,"soft") ) { return hx::Val( soft ); }
		if (HX_FIELD_EQ(inName,"jMax") ) { return hx::Val( jMax ); }
		if (HX_FIELD_EQ(inName,"Keff") ) { return hx::Val( Keff ); }
		if (HX_FIELD_EQ(inName,"vec3") ) { return hx::Val( vec3 ); }
		if (HX_FIELD_EQ(inName,"jOld") ) { return hx::Val( jOld ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"solve") ) { return hx::Val( solve_dyn() ); }
		if (HX_FIELD_EQ(inName,"gamma") ) { return hx::Val( gamma ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bodies") ) { return hx::Val( bodies ); }
		if (HX_FIELD_EQ(inName,"forest") ) { return hx::Val( forest_dyn() ); }
		if (HX_FIELD_EQ(inName,"broken") ) { return hx::Val( broken_dyn() ); }
		if (HX_FIELD_EQ(inName,"_clamp") ) { return hx::Val( _clamp_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"addBody") ) { return hx::Val( addBody_dyn() ); }
		if (HX_FIELD_EQ(inName,"remBody") ) { return hx::Val( remBody_dyn() ); }
		if (HX_FIELD_EQ(inName,"stepped") ) { return hx::Val( stepped ); }
		if (HX_FIELD_EQ(inName,"velonly") ) { return hx::Val( velonly ); }
		if (HX_FIELD_EQ(inName,"preStep") ) { return hx::Val( preStep_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"outer_zn") ) { return hx::Val( outer_zn ); }
		if (HX_FIELD_EQ(inName,"validate") ) { return hx::Val( validate_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"transform") ) { return hx::Val( transform_dyn() ); }
		if (HX_FIELD_EQ(inName,"warmStart") ) { return hx::Val( warmStart_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"clearcache") ) { return hx::Val( clearcache_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"bodyImpulse") ) { return hx::Val( bodyImpulse_dyn() ); }
		if (HX_FIELD_EQ(inName,"pair_exists") ) { return hx::Val( pair_exists_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"activeBodies") ) { return hx::Val( activeBodies_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"inactiveBodies") ) { return hx::Val( inactiveBodies_dyn() ); }
		if (HX_FIELD_EQ(inName,"wake_connected") ) { return hx::Val( wake_connected_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"applyImpulseVel") ) { return hx::Val( applyImpulseVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyImpulsePos") ) { return hx::Val( applyImpulsePos_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"bindVec2_invalidate") ) { return hx::Val( bindVec2_invalidate_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val ZPP_UserConstraint_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"L") ) { L=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"J") ) { J=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"dim") ) { dim=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"jAcc") ) { jAcc=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bias") ) { bias=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"soft") ) { soft=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jMax") ) { jMax=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"Keff") ) { Keff=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vec3") ) { vec3=inValue.Cast<  ::nape::geom::Vec3 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"jOld") ) { jOld=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"gamma") ) { gamma=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bodies") ) { bodies=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"stepped") ) { stepped=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"velonly") ) { velonly=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"outer_zn") ) { outer_zn=inValue.Cast<  ::nape::constraint::UserConstraint >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ZPP_UserConstraint_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("outer_zn",38,07,b0,a2));
	outFields->push(HX_("bodies",80,1b,dd,5a));
	outFields->push(HX_("dim",48,3d,4c,00));
	outFields->push(HX_("jAcc",f7,46,42,46));
	outFields->push(HX_("bias",79,ea,16,41));
	outFields->push(HX_("stepped",03,05,60,81));
	outFields->push(HX_("L",4c,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("soft",ea,1c,58,4c));
	outFields->push(HX_("gamma",27,87,b6,8e));
	outFields->push(HX_("velonly",49,5a,e9,05));
	outFields->push(HX_("jMax",5a,60,4b,46));
	outFields->push(HX_("Keff",7a,fd,df,31));
	outFields->push(HX_("vec3",5f,27,4c,4e));
	outFields->push(HX_("J",4a,00,00,00));
	outFields->push(HX_("jOld",5d,ee,4c,46));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo ZPP_UserConstraint_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::nape::constraint::UserConstraint */ ,(int)offsetof(ZPP_UserConstraint_obj,outer_zn),HX_("outer_zn",38,07,b0,a2)},
	{hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(ZPP_UserConstraint_obj,bodies),HX_("bodies",80,1b,dd,5a)},
	{hx::fsInt,(int)offsetof(ZPP_UserConstraint_obj,dim),HX_("dim",48,3d,4c,00)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,jAcc),HX_("jAcc",f7,46,42,46)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,bias),HX_("bias",79,ea,16,41)},
	{hx::fsBool,(int)offsetof(ZPP_UserConstraint_obj,stepped),HX_("stepped",03,05,60,81)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,L),HX_("L",4c,00,00,00)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,y),HX_("y",79,00,00,00)},
	{hx::fsFloat,(int)offsetof(ZPP_UserConstraint_obj,soft),HX_("soft",ea,1c,58,4c)},
	{hx::fsFloat,(int)offsetof(ZPP_UserConstraint_obj,gamma),HX_("gamma",27,87,b6,8e)},
	{hx::fsBool,(int)offsetof(ZPP_UserConstraint_obj,velonly),HX_("velonly",49,5a,e9,05)},
	{hx::fsFloat,(int)offsetof(ZPP_UserConstraint_obj,jMax),HX_("jMax",5a,60,4b,46)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,Keff),HX_("Keff",7a,fd,df,31)},
	{hx::fsObject /*  ::nape::geom::Vec3 */ ,(int)offsetof(ZPP_UserConstraint_obj,vec3),HX_("vec3",5f,27,4c,4e)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,J),HX_("J",4a,00,00,00)},
	{hx::fsObject /* ::Array< Float > */ ,(int)offsetof(ZPP_UserConstraint_obj,jOld),HX_("jOld",5d,ee,4c,46)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *ZPP_UserConstraint_obj_sStaticStorageInfo = 0;
#endif

static ::String ZPP_UserConstraint_obj_sMemberFields[] = {
	HX_("outer_zn",38,07,b0,a2),
	HX_("bindVec2_invalidate",bf,6e,04,93),
	HX_("bodies",80,1b,dd,5a),
	HX_("dim",48,3d,4c,00),
	HX_("jAcc",f7,46,42,46),
	HX_("bias",79,ea,16,41),
	HX_("addBody",63,bd,58,7d),
	HX_("remBody",1c,35,3c,d5),
	HX_("bodyImpulse",33,76,a2,5f),
	HX_("activeBodies",e6,69,f8,ba),
	HX_("inactiveBodies",4b,89,c5,8c),
	HX_("stepped",03,05,60,81),
	HX_("copy",b5,bb,c4,41),
	HX_("validate",96,d0,e3,04),
	HX_("wake_connected",ae,cf,dd,3d),
	HX_("forest",dd,8c,88,fd),
	HX_("pair_exists",a1,6a,58,69),
	HX_("broken",55,b6,57,1c),
	HX_("clearcache",95,69,f1,82),
	HX_("lsq",0a,58,52,00),
	HX_("_clamp",3c,ba,3f,44),
	HX_("L",4c,00,00,00),
	HX_("solve",7f,bf,c5,80),
	HX_("y",79,00,00,00),
	HX_("transform",6c,2d,93,45),
	HX_("soft",ea,1c,58,4c),
	HX_("gamma",27,87,b6,8e),
	HX_("velonly",49,5a,e9,05),
	HX_("jMax",5a,60,4b,46),
	HX_("Keff",7a,fd,df,31),
	HX_("preStep",0f,c1,c0,24),
	HX_("vec3",5f,27,4c,4e),
	HX_("warmStart",dd,27,03,eb),
	HX_("J",4a,00,00,00),
	HX_("jOld",5d,ee,4c,46),
	HX_("applyImpulseVel",b6,c7,50,1f),
	HX_("applyImpulsePos",ed,42,4c,1f),
	HX_("draw",04,2c,70,42),
	::String(null()) };

hx::Class ZPP_UserConstraint_obj::__mClass;

void ZPP_UserConstraint_obj::__register()
{
	ZPP_UserConstraint_obj _hx_dummy;
	ZPP_UserConstraint_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("zpp_nape.constraint.ZPP_UserConstraint",7d,3c,4e,73);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ZPP_UserConstraint_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ZPP_UserConstraint_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ZPP_UserConstraint_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ZPP_UserConstraint_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace zpp_nape
} // end namespace constraint
