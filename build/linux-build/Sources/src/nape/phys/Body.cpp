// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_nape_callbacks_CbType
#include <hxinc/nape/callbacks/CbType.h>
#endif
#ifndef INCLUDED_nape_callbacks_InteractionType
#include <hxinc/nape/callbacks/InteractionType.h>
#endif
#ifndef INCLUDED_nape_constraint_Constraint
#include <hxinc/nape/constraint/Constraint.h>
#endif
#ifndef INCLUDED_nape_constraint_ConstraintIterator
#include <hxinc/nape/constraint/ConstraintIterator.h>
#endif
#ifndef INCLUDED_nape_constraint_ConstraintList
#include <hxinc/nape/constraint/ConstraintList.h>
#endif
#ifndef INCLUDED_nape_dynamics_Arbiter
#include <hxinc/nape/dynamics/Arbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_ArbiterIterator
#include <hxinc/nape/dynamics/ArbiterIterator.h>
#endif
#ifndef INCLUDED_nape_dynamics_ArbiterList
#include <hxinc/nape/dynamics/ArbiterList.h>
#endif
#ifndef INCLUDED_nape_dynamics_CollisionArbiter
#include <hxinc/nape/dynamics/CollisionArbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_FluidArbiter
#include <hxinc/nape/dynamics/FluidArbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_InteractionFilter
#include <hxinc/nape/dynamics/InteractionFilter.h>
#endif
#ifndef INCLUDED_nape_geom_AABB
#include <hxinc/nape/geom/AABB.h>
#endif
#ifndef INCLUDED_nape_geom_Mat23
#include <hxinc/nape/geom/Mat23.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_geom_Vec3
#include <hxinc/nape/geom/Vec3.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_BodyList
#include <hxinc/nape/phys/BodyList.h>
#endif
#ifndef INCLUDED_nape_phys_BodyType
#include <hxinc/nape/phys/BodyType.h>
#endif
#ifndef INCLUDED_nape_phys_Compound
#include <hxinc/nape/phys/Compound.h>
#endif
#ifndef INCLUDED_nape_phys_FluidProperties
#include <hxinc/nape/phys/FluidProperties.h>
#endif
#ifndef INCLUDED_nape_phys_GravMassMode
#include <hxinc/nape/phys/GravMassMode.h>
#endif
#ifndef INCLUDED_nape_phys_InertiaMode
#include <hxinc/nape/phys/InertiaMode.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_phys_MassMode
#include <hxinc/nape/phys/MassMode.h>
#endif
#ifndef INCLUDED_nape_phys_Material
#include <hxinc/nape/phys/Material.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <hxinc/nape/shape/Shape.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeList
#include <hxinc/nape/shape/ShapeList.h>
#endif
#ifndef INCLUDED_nape_space_Space
#include <hxinc/nape/space/Space.h>
#endif
#ifndef INCLUDED_zpp_nape_callbacks_ZPP_CbType
#include <hxinc/zpp_nape/callbacks/ZPP_CbType.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_Constraint
#include <hxinc/zpp_nape/constraint/ZPP_Constraint.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Arbiter
#include <hxinc/zpp_nape/dynamics/ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_ColArbiter
#include <hxinc/zpp_nape/dynamics/ZPP_ColArbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_FluidArbiter
#include <hxinc/zpp_nape/dynamics/ZPP_FluidArbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_InteractionFilter
#include <hxinc/zpp_nape/dynamics/ZPP_InteractionFilter.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_AABB
#include <hxinc/zpp_nape/geom/ZPP_AABB.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec3
#include <hxinc/zpp_nape/geom/ZPP_Vec3.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Compound
#include <hxinc/zpp_nape/phys/ZPP_Compound.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_FluidProperties
#include <hxinc/zpp_nape/phys/ZPP_FluidProperties.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Material
#include <hxinc/zpp_nape/phys/ZPP_Material.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Polygon
#include <hxinc/zpp_nape/shape/ZPP_Polygon.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <hxinc/zpp_nape/shape/ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Component
#include <hxinc/zpp_nape/space/ZPP_Component.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Arbiter
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Constraint
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Constraint.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Shape
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Constraint
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Constraint.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Shape
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ArbiterList
#include <hxinc/zpp_nape/util/ZPP_ArbiterList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_BodyList
#include <hxinc/zpp_nape/util/ZPP_BodyList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ConstraintList
#include <hxinc/zpp_nape/util/ZPP_ConstraintList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_Flags
#include <hxinc/zpp_nape/util/ZPP_Flags.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_PubPool
#include <hxinc/zpp_nape/util/ZPP_PubPool.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ShapeList
#include <hxinc/zpp_nape/util/ZPP_ShapeList.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_177_new,"nape.phys.Body","new",0x6578e0ca,"nape.phys.Body.new","nape/phys/Body.hx",177,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_198_get_type,"nape.phys.Body","get_type",0xb918dd99,"nape.phys.Body.get_type","nape/phys/Body.hx",198,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_200_set_type,"nape.phys.Body","set_type",0x6776370d,"nape.phys.Body.set_type","nape/phys/Body.hx",200,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_260_get_isBullet,"nape.phys.Body","get_isBullet",0x76a2742b,"nape.phys.Body.get_isBullet","nape/phys/Body.hx",260,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_262_set_isBullet,"nape.phys.Body","set_isBullet",0x8b9b979f,"nape.phys.Body.set_isBullet","nape/phys/Body.hx",262,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_279_get_disableCCD,"nape.phys.Body","get_disableCCD",0xefa9a4db,"nape.phys.Body.get_disableCCD","nape/phys/Body.hx",279,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_281_set_disableCCD,"nape.phys.Body","set_disableCCD",0x0fc98d4f,"nape.phys.Body.set_disableCCD","nape/phys/Body.hx",281,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_295_integrate,"nape.phys.Body","integrate",0xca94aa5b,"nape.phys.Body.integrate","nape/phys/Body.hx",295,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_320_isStatic,"nape.phys.Body","isStatic",0x4abaa78e,"nape.phys.Body.isStatic","nape/phys/Body.hx",320,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_329_isDynamic,"nape.phys.Body","isDynamic",0x1848589f,"nape.phys.Body.isDynamic","nape/phys/Body.hx",329,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_338_isKinematic,"nape.phys.Body","isKinematic",0xc32aba25,"nape.phys.Body.isKinematic","nape/phys/Body.hx",338,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_350_get_shapes,"nape.phys.Body","get_shapes",0x9d317ad1,"nape.phys.Body.get_shapes","nape/phys/Body.hx",350,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_364_get_compound,"nape.phys.Body","get_compound",0xcb7809ca,"nape.phys.Body.get_compound","nape/phys/Body.hx",364,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_366_set_compound,"nape.phys.Body","set_compound",0xe0712d3e,"nape.phys.Body.set_compound","nape/phys/Body.hx",366,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_386_get_space,"nape.phys.Body","get_space",0xa3442507,"nape.phys.Body.get_space","nape/phys/Body.hx",386,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_388_set_space,"nape.phys.Body","set_space",0x86951113,"nape.phys.Body.set_space","nape/phys/Body.hx",388,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_412_get_arbiters,"nape.phys.Body","get_arbiters",0x6b5a72c9,"nape.phys.Body.get_arbiters","nape/phys/Body.hx",412,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_428_get_isSleeping,"nape.phys.Body","get_isSleeping",0xc4504654,"nape.phys.Body.get_isSleeping","nape/phys/Body.hx",428,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_443_get_constraints,"nape.phys.Body","get_constraints",0xcac71077,"nape.phys.Body.get_constraints","nape/phys/Body.hx",443,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_542_copy,"nape.phys.Body","copy",0x5d0e080b,"nape.phys.Body.copy","nape/phys/Body.hx",542,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_564_get_position,"nape.phys.Body","get_position",0x14a2e708,"nape.phys.Body.get_position","nape/phys/Body.hx",564,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_568_set_position,"nape.phys.Body","set_position",0x299c0a7c,"nape.phys.Body.set_position","nape/phys/Body.hx",568,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_593_get_velocity,"nape.phys.Body","get_velocity",0x68a6487c,"nape.phys.Body.get_velocity","nape/phys/Body.hx",593,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_597_set_velocity,"nape.phys.Body","set_velocity",0x7d9f6bf0,"nape.phys.Body.set_velocity","nape/phys/Body.hx",597,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_628_setVelocityFromTarget,"nape.phys.Body","setVelocityFromTarget",0x4d9f6804,"nape.phys.Body.setVelocityFromTarget","nape/phys/Body.hx",628,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_668_get_kinematicVel,"nape.phys.Body","get_kinematicVel",0x61163437,"nape.phys.Body.get_kinematicVel","nape/phys/Body.hx",668,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_672_set_kinematicVel,"nape.phys.Body","set_kinematicVel",0xb75821ab,"nape.phys.Body.set_kinematicVel","nape/phys/Body.hx",672,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_700_get_surfaceVel,"nape.phys.Body","get_surfaceVel",0x19286a4f,"nape.phys.Body.get_surfaceVel","nape/phys/Body.hx",700,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_704_set_surfaceVel,"nape.phys.Body","set_surfaceVel",0x394852c3,"nape.phys.Body.set_surfaceVel","nape/phys/Body.hx",704,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_729_get_force,"nape.phys.Body","get_force",0x26724a2c,"nape.phys.Body.get_force","nape/phys/Body.hx",729,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_733_set_force,"nape.phys.Body","set_force",0x09c33638,"nape.phys.Body.set_force","nape/phys/Body.hx",733,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_755_get_constraintVelocity,"nape.phys.Body","get_constraintVelocity",0x30b476b9,"nape.phys.Body.get_constraintVelocity","nape/phys/Body.hx",755,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_774_get_rotation,"nape.phys.Body","get_rotation",0x522e839d,"nape.phys.Body.get_rotation","nape/phys/Body.hx",774,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_776_set_rotation,"nape.phys.Body","set_rotation",0x6727a711,"nape.phys.Body.set_rotation","nape/phys/Body.hx",776,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_806_get_angularVel,"nape.phys.Body","get_angularVel",0x11a0c0ba,"nape.phys.Body.get_angularVel","nape/phys/Body.hx",806,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_808_set_angularVel,"nape.phys.Body","set_angularVel",0x31c0a92e,"nape.phys.Body.set_angularVel","nape/phys/Body.hx",808,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_841_get_kinAngVel,"nape.phys.Body","get_kinAngVel",0x4002dd94,"nape.phys.Body.get_kinAngVel","nape/phys/Body.hx",841,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_843_set_kinAngVel,"nape.phys.Body","set_kinAngVel",0x8508bfa0,"nape.phys.Body.set_kinAngVel","nape/phys/Body.hx",843,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_870_get_torque,"nape.phys.Body","get_torque",0x16985769,"nape.phys.Body.get_torque","nape/phys/Body.hx",870,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_872_set_torque,"nape.phys.Body","set_torque",0x1a15f5dd,"nape.phys.Body.set_torque","nape/phys/Body.hx",872,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_901_get_bounds,"nape.phys.Body","get_bounds",0xe6252714,"nape.phys.Body.get_bounds","nape/phys/Body.hx",901,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_919_get_allowMovement,"nape.phys.Body","get_allowMovement",0x7d735819,"nape.phys.Body.get_allowMovement","nape/phys/Body.hx",919,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_921_set_allowMovement,"nape.phys.Body","set_allowMovement",0xa0e13025,"nape.phys.Body.set_allowMovement","nape/phys/Body.hx",921,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_943_get_allowRotation,"nape.phys.Body","get_allowRotation",0x85c21028,"nape.phys.Body.get_allowRotation","nape/phys/Body.hx",943,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_945_set_allowRotation,"nape.phys.Body","set_allowRotation",0xa92fe834,"nape.phys.Body.set_allowRotation","nape/phys/Body.hx",945,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_967_get_massMode,"nape.phys.Body","get_massMode",0xcb1e10d6,"nape.phys.Body.get_massMode","nape/phys/Body.hx",967,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_969_set_massMode,"nape.phys.Body","set_massMode",0xe017344a,"nape.phys.Body.set_massMode","nape/phys/Body.hx",969,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_992_get_constraintMass,"nape.phys.Body","get_constraintMass",0xb4d73790,"nape.phys.Body.get_constraintMass","nape/phys/Body.hx",992,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1010_get_mass,"nape.phys.Body","get_mass",0xb4662bd3,"nape.phys.Body.get_mass","nape/phys/Body.hx",1010,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1020_set_mass,"nape.phys.Body","set_mass",0x62c38547,"nape.phys.Body.set_mass","nape/phys/Body.hx",1020,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1047_get_gravMassMode,"nape.phys.Body","get_gravMassMode",0x470a9856,"nape.phys.Body.get_gravMassMode","nape/phys/Body.hx",1047,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1049_set_gravMassMode,"nape.phys.Body","set_gravMassMode",0x9d4c85ca,"nape.phys.Body.set_gravMassMode","nape/phys/Body.hx",1049,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1072_get_gravMass,"nape.phys.Body","get_gravMass",0xbe98f353,"nape.phys.Body.get_gravMass","nape/phys/Body.hx",1072,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1084_set_gravMass,"nape.phys.Body","set_gravMass",0xd39216c7,"nape.phys.Body.set_gravMass","nape/phys/Body.hx",1084,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1109_get_gravMassScale,"nape.phys.Body","get_gravMassScale",0x4eb15e37,"nape.phys.Body.get_gravMassScale","nape/phys/Body.hx",1109,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1118_set_gravMassScale,"nape.phys.Body","set_gravMassScale",0x721f3643,"nape.phys.Body.set_gravMassScale","nape/phys/Body.hx",1118,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1143_get_inertiaMode,"nape.phys.Body","get_inertiaMode",0xc04c747e,"nape.phys.Body.get_inertiaMode","nape/phys/Body.hx",1143,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1145_set_inertiaMode,"nape.phys.Body","set_inertiaMode",0xbc17f18a,"nape.phys.Body.set_inertiaMode","nape/phys/Body.hx",1145,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1168_get_constraintInertia,"nape.phys.Body","get_constraintInertia",0xe1d4c3de,"nape.phys.Body.get_constraintInertia","nape/phys/Body.hx",1168,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1179_get_inertia,"nape.phys.Body","get_inertia",0x035f9b7b,"nape.phys.Body.get_inertia","nape/phys/Body.hx",1179,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1189_set_inertia,"nape.phys.Body","set_inertia",0x0dcca287,"nape.phys.Body.set_inertia","nape/phys/Body.hx",1189,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1224_connectedBodies,"nape.phys.Body","connectedBodies",0x5a493693,"nape.phys.Body.connectedBodies","nape/phys/Body.hx",1224,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1241_interactingBodies,"nape.phys.Body","interactingBodies",0x9771f576,"nape.phys.Body.interactingBodies","nape/phys/Body.hx",1241,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1263_crushFactor,"nape.phys.Body","crushFactor",0x8f2ff294,"nape.phys.Body.crushFactor","nape/phys/Body.hx",1263,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1300_localPointToWorld,"nape.phys.Body","localPointToWorld",0x529ec05c,"nape.phys.Body.localPointToWorld","nape/phys/Body.hx",1300,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1340_worldPointToLocal,"nape.phys.Body","worldPointToLocal",0x87d1fedc,"nape.phys.Body.worldPointToLocal","nape/phys/Body.hx",1340,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1387_localVectorToWorld,"nape.phys.Body","localVectorToWorld",0x7d44febf,"nape.phys.Body.localVectorToWorld","nape/phys/Body.hx",1387,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1428_worldVectorToLocal,"nape.phys.Body","worldVectorToLocal",0xef542091,"nape.phys.Body.worldVectorToLocal","nape/phys/Body.hx",1428,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1478_applyImpulse,"nape.phys.Body","applyImpulse",0x41b92f3d,"nape.phys.Body.applyImpulse","nape/phys/Body.hx",1478,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1587_applyAngularImpulse,"nape.phys.Body","applyAngularImpulse",0x699fcc6b,"nape.phys.Body.applyAngularImpulse","nape/phys/Body.hx",1587,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1613_translateShapes,"nape.phys.Body","translateShapes",0x68f49b8a,"nape.phys.Body.translateShapes","nape/phys/Body.hx",1613,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1661_rotateShapes,"nape.phys.Body","rotateShapes",0x7006dd43,"nape.phys.Body.rotateShapes","nape/phys/Body.hx",1661,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1689_scaleShapes,"nape.phys.Body","scaleShapes",0x09d82ac6,"nape.phys.Body.scaleShapes","nape/phys/Body.hx",1689,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1718_transformShapes,"nape.phys.Body","transformShapes",0x4ab05c28,"nape.phys.Body.transformShapes","nape/phys/Body.hx",1718,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1749_align,"nape.phys.Body","align",0xe66ad5af,"nape.phys.Body.align","nape/phys/Body.hx",1749,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1792_rotate,"nape.phys.Body","rotate",0x4495d431,"nape.phys.Body.rotate","nape/phys/Body.hx",1792,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1834_setShapeMaterials,"nape.phys.Body","setShapeMaterials",0x701983b7,"nape.phys.Body.setShapeMaterials","nape/phys/Body.hx",1834,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1858_setShapeFilters,"nape.phys.Body","setShapeFilters",0x8194d6c6,"nape.phys.Body.setShapeFilters","nape/phys/Body.hx",1858,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1882_setShapeFluidProperties,"nape.phys.Body","setShapeFluidProperties",0x85eac2a8,"nape.phys.Body.setShapeFluidProperties","nape/phys/Body.hx",1882,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1907_get_localCOM,"nape.phys.Body","get_localCOM",0x29880df5,"nape.phys.Body.get_localCOM","nape/phys/Body.hx",1907,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1929_get_worldCOM,"nape.phys.Body","get_worldCOM",0xee2c0b6e,"nape.phys.Body.get_worldCOM","nape/phys/Body.hx",1929,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_1954_normalImpulse,"nape.phys.Body","normalImpulse",0x6f782238,"nape.phys.Body.normalImpulse","nape/phys/Body.hx",1954,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2018_tangentImpulse,"nape.phys.Body","tangentImpulse",0x28568246,"nape.phys.Body.tangentImpulse","nape/phys/Body.hx",2018,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2082_totalContactsImpulse,"nape.phys.Body","totalContactsImpulse",0xcd704014,"nape.phys.Body.totalContactsImpulse","nape/phys/Body.hx",2082,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2146_rollingImpulse,"nape.phys.Body","rollingImpulse",0x8df60986,"nape.phys.Body.rollingImpulse","nape/phys/Body.hx",2146,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2172_buoyancyImpulse,"nape.phys.Body","buoyancyImpulse",0x9134aedf,"nape.phys.Body.buoyancyImpulse","nape/phys/Body.hx",2172,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2234_dragImpulse,"nape.phys.Body","dragImpulse",0x2488fd8b,"nape.phys.Body.dragImpulse","nape/phys/Body.hx",2234,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2296_totalFluidImpulse,"nape.phys.Body","totalFluidImpulse",0x5f513f99,"nape.phys.Body.totalFluidImpulse","nape/phys/Body.hx",2296,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2353_constraintsImpulse,"nape.phys.Body","constraintsImpulse",0x3e34d8b5,"nape.phys.Body.constraintsImpulse","nape/phys/Body.hx",2353,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2419_totalImpulse,"nape.phys.Body","totalImpulse",0xab4a77a7,"nape.phys.Body.totalImpulse","nape/phys/Body.hx",2419,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2504_contains,"nape.phys.Body","contains",0x18d08975,"nape.phys.Body.contains","nape/phys/Body.hx",2504,0xcb2bb586)
HX_LOCAL_STACK_FRAME(_hx_pos_276b1c0c2f1cb053_2550_toString,"nape.phys.Body","toString",0x24c40002,"nape.phys.Body.toString","nape/phys/Body.hx",2550,0xcb2bb586)
namespace nape{
namespace phys{

void Body_obj::__construct( ::nape::phys::BodyType type, ::nape::geom::Vec2 position){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_177_new)
HXLINE( 189)		this->debugDraw = true;
HXLINE( 181)		this->zpp_inner = null();
HXLINE( 459)		::nape::phys::Interactor_obj::zpp_internalAlloc = true;
HXLINE( 460)		super::__construct();
HXLINE( 461)		::nape::phys::Interactor_obj::zpp_internalAlloc = false;
HXLINE( 466)		this->zpp_inner =  ::zpp_nape::phys::ZPP_Body_obj::__alloc( HX_CTX );
HXLINE( 467)		this->zpp_inner->outer = hx::ObjectPtr<OBJ_>(this);
HXLINE( 468)		this->zpp_inner->outer_i = hx::ObjectPtr<OBJ_>(this);
HXLINE( 469)		this->zpp_inner_i = this->zpp_inner;
HXLINE( 470)		if (hx::IsNotNull( position )) {
HXLINE( 473)			bool _hx_tmp;
HXDLIN( 473)			if (hx::IsNotNull( position )) {
HXLINE( 473)				_hx_tmp = position->zpp_disp;
            			}
            			else {
HXLINE( 473)				_hx_tmp = false;
            			}
HXDLIN( 473)			if (_hx_tmp) {
HXLINE( 473)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 476)			{
HXLINE( 477)				bool _hx_tmp1;
HXDLIN( 477)				if (hx::IsNotNull( position )) {
HXLINE( 477)					_hx_tmp1 = position->zpp_disp;
            				}
            				else {
HXLINE( 477)					_hx_tmp1 = false;
            				}
HXDLIN( 477)				if (_hx_tmp1) {
HXLINE( 477)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 477)				{
HXLINE( 477)					 ::zpp_nape::geom::ZPP_Vec2 _this = position->zpp_inner;
HXDLIN( 477)					if (hx::IsNotNull( _this->_validate )) {
HXLINE( 477)						_this->_validate();
            					}
            				}
HXDLIN( 477)				this->zpp_inner->posx = position->zpp_inner->x;
HXLINE( 478)				bool _hx_tmp2;
HXDLIN( 478)				if (hx::IsNotNull( position )) {
HXLINE( 478)					_hx_tmp2 = position->zpp_disp;
            				}
            				else {
HXLINE( 478)					_hx_tmp2 = false;
            				}
HXDLIN( 478)				if (_hx_tmp2) {
HXLINE( 478)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 478)				{
HXLINE( 478)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = position->zpp_inner;
HXDLIN( 478)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 478)						_this1->_validate();
            					}
            				}
HXDLIN( 478)				this->zpp_inner->posy = position->zpp_inner->y;
            			}
            		}
            		else {
HXLINE( 498)			this->zpp_inner->posx = ( (Float)(0) );
HXLINE( 499)			this->zpp_inner->posy = ( (Float)(0) );
            		}
HXLINE( 517)		{
HXLINE( 517)			 ::nape::phys::BodyType type1;
HXDLIN( 517)			if (hx::IsNull( type )) {
HXLINE( 517)				if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC )) {
HXLINE( 517)					::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 517)					::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC =  ::nape::phys::BodyType_obj::__alloc( HX_CTX );
HXDLIN( 517)					::zpp_nape::util::ZPP_Flags_obj::internal = false;
            				}
HXDLIN( 517)				type1 = ::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC;
            			}
            			else {
HXLINE( 517)				type1 = type;
            			}
HXDLIN( 517)			{
HXLINE( 517)				this->zpp_inner->immutable_midstep(HX_("Body::type",bc,a9,32,ec));
HXDLIN( 517)				if (this->zpp_inner->world) {
HXLINE( 517)					HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            				}
HXDLIN( 517)				if (hx::IsNotEq( ::zpp_nape::phys::ZPP_Body_obj::types->__get(this->zpp_inner->type).StaticCast<  ::nape::phys::BodyType >(),type1 )) {
HXLINE( 517)					if (hx::IsNull( type1 )) {
HXLINE( 517)						HX_STACK_DO_THROW(HX_("Error: Cannot use null BodyType",cd,f3,4c,7b));
            					}
HXDLIN( 517)					int ntype;
HXDLIN( 517)					if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC )) {
HXLINE( 517)						::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 517)						::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC =  ::nape::phys::BodyType_obj::__alloc( HX_CTX );
HXDLIN( 517)						::zpp_nape::util::ZPP_Flags_obj::internal = false;
            					}
HXDLIN( 517)					if (hx::IsEq( type1,::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC )) {
HXLINE( 517)						ntype = 2;
            					}
            					else {
HXLINE( 517)						if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::BodyType_KINEMATIC )) {
HXLINE( 517)							::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 517)							::zpp_nape::util::ZPP_Flags_obj::BodyType_KINEMATIC =  ::nape::phys::BodyType_obj::__alloc( HX_CTX );
HXDLIN( 517)							::zpp_nape::util::ZPP_Flags_obj::internal = false;
            						}
HXDLIN( 517)						if (hx::IsEq( type1,::zpp_nape::util::ZPP_Flags_obj::BodyType_KINEMATIC )) {
HXLINE( 517)							ntype = 3;
            						}
            						else {
HXLINE( 517)							ntype = 1;
            						}
            					}
HXDLIN( 517)					bool _hx_tmp3;
HXDLIN( 517)					if ((ntype == 1)) {
HXLINE( 517)						_hx_tmp3 = hx::IsNotNull( this->zpp_inner->space );
            					}
            					else {
HXLINE( 517)						_hx_tmp3 = false;
            					}
HXDLIN( 517)					if (_hx_tmp3) {
HXLINE( 517)						{
HXLINE( 517)							this->zpp_inner->velx = ( (Float)(0) );
HXDLIN( 517)							this->zpp_inner->vely = ( (Float)(0) );
            						}
HXDLIN( 517)						this->zpp_inner->angvel = ( (Float)(0) );
            					}
HXDLIN( 517)					this->zpp_inner->invalidate_type();
HXDLIN( 517)					if (hx::IsNotNull( this->zpp_inner->space )) {
HXLINE( 517)						this->zpp_inner->space->transmitType(this->zpp_inner,ntype);
            					}
            					else {
HXLINE( 517)						this->zpp_inner->type = ntype;
            					}
            				}
            			}
            		}
HXLINE( 518)		if (hx::IsNotNull( position )) {
HXLINE( 518)			if (position->zpp_inner->weak) {
HXLINE( 522)				bool _hx_tmp4;
HXDLIN( 522)				if (hx::IsNotNull( position )) {
HXLINE( 522)					_hx_tmp4 = position->zpp_disp;
            				}
            				else {
HXLINE( 522)					_hx_tmp4 = false;
            				}
HXDLIN( 522)				if (_hx_tmp4) {
HXLINE( 522)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 522)				{
HXLINE( 522)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = position->zpp_inner;
HXDLIN( 522)					if (_this2->_immutable) {
HXLINE( 522)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 522)					if (hx::IsNotNull( _this2->_isimmutable )) {
HXLINE( 522)						_this2->_isimmutable();
            					}
            				}
HXDLIN( 522)				if (position->zpp_inner->_inuse) {
HXLINE( 522)					HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            				}
HXDLIN( 522)				 ::zpp_nape::geom::ZPP_Vec2 inner = position->zpp_inner;
HXDLIN( 522)				position->zpp_inner->outer = null();
HXDLIN( 522)				position->zpp_inner = null();
HXDLIN( 522)				{
HXLINE( 522)					 ::nape::geom::Vec2 o = position;
HXDLIN( 522)					o->zpp_pool = null();
HXDLIN( 522)					if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 522)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            					}
            					else {
HXLINE( 522)						::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            					}
HXDLIN( 522)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 522)					o->zpp_disp = true;
            				}
HXDLIN( 522)				{
HXLINE( 522)					 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 522)					{
HXLINE( 522)						if (hx::IsNotNull( o1->outer )) {
HXLINE( 522)							o1->outer->zpp_inner = null();
HXDLIN( 522)							o1->outer = null();
            						}
HXDLIN( 522)						o1->_isimmutable = null();
HXDLIN( 522)						o1->_validate = null();
HXDLIN( 522)						o1->_invalidate = null();
            					}
HXDLIN( 522)					o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 522)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            				}
            			}
            		}
HXLINE( 529)		this->zpp_inner_i->insert_cbtype(::zpp_nape::callbacks::ZPP_CbType_obj::ANY_BODY->zpp_inner);
            	}

Dynamic Body_obj::__CreateEmpty() { return new Body_obj; }

void *Body_obj::_hx_vtable = 0;

Dynamic Body_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Body_obj > _hx_result = new Body_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Body_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1e1af07c) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x1e1af07c;
	} else {
		return inClassId==(int)0x643c1bb3;
	}
}

 ::nape::phys::BodyType Body_obj::get_type(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_198_get_type)
HXDLIN( 198)		return ::zpp_nape::phys::ZPP_Body_obj::types->__get(this->zpp_inner->type).StaticCast<  ::nape::phys::BodyType >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_type,return )

 ::nape::phys::BodyType Body_obj::set_type( ::nape::phys::BodyType type){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_200_set_type)
HXLINE( 201)		{
HXLINE( 202)			this->zpp_inner->immutable_midstep(HX_("Body::type",bc,a9,32,ec));
HXLINE( 204)			if (this->zpp_inner->world) {
HXLINE( 204)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 206)			if (hx::IsNotEq( ::zpp_nape::phys::ZPP_Body_obj::types->__get(this->zpp_inner->type).StaticCast<  ::nape::phys::BodyType >(),type )) {
HXLINE( 208)				if (hx::IsNull( type )) {
HXLINE( 208)					HX_STACK_DO_THROW(HX_("Error: Cannot use null BodyType",cd,f3,4c,7b));
            				}
HXLINE( 210)				int ntype;
HXDLIN( 210)				if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC )) {
HXLINE( 210)					::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 210)					::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC =  ::nape::phys::BodyType_obj::__alloc( HX_CTX );
HXDLIN( 210)					::zpp_nape::util::ZPP_Flags_obj::internal = false;
            				}
HXDLIN( 210)				if (hx::IsEq( type,::zpp_nape::util::ZPP_Flags_obj::BodyType_DYNAMIC )) {
HXLINE( 210)					ntype = 2;
            				}
            				else {
HXLINE( 210)					if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::BodyType_KINEMATIC )) {
HXLINE( 210)						::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 210)						::zpp_nape::util::ZPP_Flags_obj::BodyType_KINEMATIC =  ::nape::phys::BodyType_obj::__alloc( HX_CTX );
HXDLIN( 210)						::zpp_nape::util::ZPP_Flags_obj::internal = false;
            					}
HXDLIN( 210)					if (hx::IsEq( type,::zpp_nape::util::ZPP_Flags_obj::BodyType_KINEMATIC )) {
HXLINE( 210)						ntype = 3;
            					}
            					else {
HXLINE( 210)						ntype = 1;
            					}
            				}
HXLINE( 211)				bool _hx_tmp;
HXDLIN( 211)				if ((ntype == 1)) {
HXLINE( 211)					_hx_tmp = hx::IsNotNull( this->zpp_inner->space );
            				}
            				else {
HXLINE( 211)					_hx_tmp = false;
            				}
HXDLIN( 211)				if (_hx_tmp) {
HXLINE( 212)					{
HXLINE( 213)						this->zpp_inner->velx = ( (Float)(0) );
HXLINE( 214)						this->zpp_inner->vely = ( (Float)(0) );
            					}
HXLINE( 232)					this->zpp_inner->angvel = ( (Float)(0) );
            				}
HXLINE( 234)				this->zpp_inner->invalidate_type();
HXLINE( 235)				if (hx::IsNotNull( this->zpp_inner->space )) {
HXLINE( 235)					this->zpp_inner->space->transmitType(this->zpp_inner,ntype);
            				}
            				else {
HXLINE( 236)					this->zpp_inner->type = ntype;
            				}
            			}
            		}
HXLINE( 239)		return ::zpp_nape::phys::ZPP_Body_obj::types->__get(this->zpp_inner->type).StaticCast<  ::nape::phys::BodyType >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_type,return )

bool Body_obj::get_isBullet(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_260_get_isBullet)
HXDLIN( 260)		return this->zpp_inner->bulletEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_isBullet,return )

bool Body_obj::set_isBullet(bool isBullet){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_262_set_isBullet)
HXLINE( 264)		this->zpp_inner->bulletEnabled = isBullet;
HXLINE( 266)		return this->zpp_inner->bulletEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_isBullet,return )

bool Body_obj::get_disableCCD(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_279_get_disableCCD)
HXDLIN( 279)		return this->zpp_inner->disableCCD;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_disableCCD,return )

bool Body_obj::set_disableCCD(bool disableCCD){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_281_set_disableCCD)
HXLINE( 283)		this->zpp_inner->disableCCD = disableCCD;
HXLINE( 285)		return this->zpp_inner->disableCCD;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_disableCCD,return )

 ::nape::phys::Body Body_obj::integrate(Float deltaTime){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_295_integrate)
HXLINE( 297)		if ((deltaTime != deltaTime)) {
HXLINE( 297)			HX_STACK_DO_THROW(HX_("Cannot integrate by NaN time",2f,66,d3,2b));
            		}
HXLINE( 299)		this->zpp_inner->immutable_midstep(HX_("Body::space",84,f7,bc,26));
HXLINE( 301)		if (this->zpp_inner->world) {
HXLINE( 301)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE( 303)		if ((deltaTime == 0)) {
HXLINE( 303)			return hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE( 304)		 ::zpp_nape::phys::ZPP_Body cur = this->zpp_inner;
HXLINE( 305)		cur->sweepTime = ( (Float)(0) );
HXLINE( 306)		cur->sweep_angvel = cur->angvel;
HXLINE( 307)		{
HXLINE( 307)			Float delta = (deltaTime - cur->sweepTime);
HXDLIN( 307)			if ((delta != 0)) {
HXLINE( 307)				cur->sweepTime = deltaTime;
HXDLIN( 307)				{
HXLINE( 307)					Float t = delta;
HXDLIN( 307)					 ::zpp_nape::phys::ZPP_Body cur1 = cur;
HXDLIN( 307)					cur1->posx = (cur1->posx + (cur->velx * t));
HXDLIN( 307)					 ::zpp_nape::phys::ZPP_Body cur2 = cur;
HXDLIN( 307)					cur2->posy = (cur2->posy + (cur->vely * t));
            				}
HXDLIN( 307)				if ((cur->angvel != 0)) {
HXLINE( 307)					Float dr = (cur->sweep_angvel * delta);
HXDLIN( 307)					 ::zpp_nape::phys::ZPP_Body cur3 = cur;
HXDLIN( 307)					cur3->rot = (cur3->rot + dr);
HXDLIN( 307)					if (((dr * dr) > ((Float)0.0001))) {
HXLINE( 307)						cur->axisx = ::Math_obj::sin(cur->rot);
HXDLIN( 307)						cur->axisy = ::Math_obj::cos(cur->rot);
            					}
            					else {
HXLINE( 307)						Float d2 = (dr * dr);
HXDLIN( 307)						Float p = (( (Float)(1) ) - (((Float)0.5) * d2));
HXDLIN( 307)						Float m = (( (Float)(1) ) - ((d2 * d2) / ( (Float)(8) )));
HXDLIN( 307)						Float nx = (((p * cur->axisx) + (dr * cur->axisy)) * m);
HXDLIN( 307)						cur->axisy = (((p * cur->axisy) - (dr * cur->axisx)) * m);
HXDLIN( 307)						cur->axisx = nx;
            					}
            				}
            			}
            		}
HXLINE( 308)		{
HXLINE( 308)			{
HXLINE( 308)				 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = cur->shapes->head;
HXDLIN( 308)				while(hx::IsNotNull( cx_ite )){
HXLINE( 308)					 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXDLIN( 308)					{
HXLINE( 308)						if ((s->type == 1)) {
HXLINE( 308)							s->polygon->invalidate_gverts();
HXDLIN( 308)							s->polygon->invalidate_gaxi();
            						}
HXDLIN( 308)						s->invalidate_worldCOM();
            					}
HXDLIN( 308)					cx_ite = cx_ite->next;
            				}
            			}
HXDLIN( 308)			cur->zip_worldCOM = true;
            		}
HXLINE( 309)		{
HXLINE( 309)			cur->zip_axis = true;
HXDLIN( 309)			{
HXLINE( 309)				 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite1 = cur->shapes->head;
HXDLIN( 309)				while(hx::IsNotNull( cx_ite1 )){
HXLINE( 309)					 ::zpp_nape::shape::ZPP_Shape s1 = cx_ite1->elt;
HXDLIN( 309)					{
HXLINE( 309)						if ((s1->type == 1)) {
HXLINE( 309)							s1->polygon->invalidate_gverts();
HXDLIN( 309)							s1->polygon->invalidate_gaxi();
            						}
HXDLIN( 309)						s1->invalidate_worldCOM();
            					}
HXDLIN( 309)					cx_ite1 = cx_ite1->next;
            				}
            			}
HXDLIN( 309)			cur->zip_worldCOM = true;
            		}
HXLINE( 310)		cur->sweepTime = ( (Float)(0) );
HXLINE( 311)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,integrate,return )

bool Body_obj::isStatic(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_320_isStatic)
HXDLIN( 320)		return (this->zpp_inner->type == 1);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,isStatic,return )

bool Body_obj::isDynamic(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_329_isDynamic)
HXDLIN( 329)		return (this->zpp_inner->type == 2);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,isDynamic,return )

bool Body_obj::isKinematic(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_338_isKinematic)
HXDLIN( 338)		return (this->zpp_inner->type == 3);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,isKinematic,return )

 ::nape::shape::ShapeList Body_obj::get_shapes(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_350_get_shapes)
HXDLIN( 350)		return this->zpp_inner->wrap_shapes;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_shapes,return )

 ::nape::phys::Compound Body_obj::get_compound(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_364_get_compound)
HXDLIN( 364)		if (hx::IsNull( this->zpp_inner->compound )) {
HXDLIN( 364)			return null();
            		}
            		else {
HXDLIN( 364)			return this->zpp_inner->compound->outer;
            		}
HXDLIN( 364)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_compound,return )

 ::nape::phys::Compound Body_obj::set_compound( ::nape::phys::Compound compound){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_366_set_compound)
HXLINE( 368)		 ::nape::phys::Compound _hx_tmp;
HXDLIN( 368)		if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 368)			_hx_tmp = null();
            		}
            		else {
HXLINE( 368)			_hx_tmp = this->zpp_inner->compound->outer;
            		}
HXDLIN( 368)		if (hx::IsNotEq( _hx_tmp,compound )) {
HXLINE( 369)			 ::nape::phys::Compound _hx_tmp1;
HXDLIN( 369)			if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 369)				_hx_tmp1 = null();
            			}
            			else {
HXLINE( 369)				_hx_tmp1 = this->zpp_inner->compound->outer;
            			}
HXDLIN( 369)			if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 369)				 ::nape::phys::Compound _hx_tmp2;
HXDLIN( 369)				if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 369)					_hx_tmp2 = null();
            				}
            				else {
HXLINE( 369)					_hx_tmp2 = this->zpp_inner->compound->outer;
            				}
HXDLIN( 369)				_hx_tmp2->zpp_inner->wrap_bodies->remove(hx::ObjectPtr<OBJ_>(this));
            			}
HXLINE( 370)			if (hx::IsNotNull( compound )) {
HXLINE( 370)				 ::nape::phys::BodyList _this = compound->zpp_inner->wrap_bodies;
HXDLIN( 370)				if (_this->zpp_inner->reverse_flag) {
HXLINE( 370)					_this->push(hx::ObjectPtr<OBJ_>(this));
            				}
            				else {
HXLINE( 370)					_this->unshift(hx::ObjectPtr<OBJ_>(this));
            				}
            			}
            		}
HXLINE( 373)		if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 373)			return null();
            		}
            		else {
HXLINE( 373)			return this->zpp_inner->compound->outer;
            		}
HXDLIN( 373)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_compound,return )

 ::nape::space::Space Body_obj::get_space(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_386_get_space)
HXDLIN( 386)		if (hx::IsNull( this->zpp_inner->space )) {
HXDLIN( 386)			return null();
            		}
            		else {
HXDLIN( 386)			return this->zpp_inner->space->outer;
            		}
HXDLIN( 386)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_space,return )

 ::nape::space::Space Body_obj::set_space( ::nape::space::Space space){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_388_set_space)
HXLINE( 389)		{
HXLINE( 391)			if (hx::IsNotNull( this->zpp_inner->compound )) {
HXLINE( 391)				HX_STACK_DO_THROW(HX_("Error: Cannot set the space of a Body belonging to a Compound, only the root Compound space can be set",2f,88,46,ff));
            			}
HXLINE( 393)			this->zpp_inner->immutable_midstep(HX_("Body::space",84,f7,bc,26));
HXLINE( 395)			if (this->zpp_inner->world) {
HXLINE( 395)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 397)			 ::nape::space::Space _hx_tmp;
HXDLIN( 397)			if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 397)				_hx_tmp = null();
            			}
            			else {
HXLINE( 397)				_hx_tmp = this->zpp_inner->space->outer;
            			}
HXDLIN( 397)			if (hx::IsNotEq( _hx_tmp,space )) {
HXLINE( 398)				 ::nape::space::Space _hx_tmp1;
HXDLIN( 398)				if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 398)					_hx_tmp1 = null();
            				}
            				else {
HXLINE( 398)					_hx_tmp1 = this->zpp_inner->space->outer;
            				}
HXDLIN( 398)				if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 398)					this->zpp_inner->component->woken = false;
            				}
HXLINE( 399)				 ::nape::space::Space _hx_tmp2;
HXDLIN( 399)				if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 399)					_hx_tmp2 = null();
            				}
            				else {
HXLINE( 399)					_hx_tmp2 = this->zpp_inner->space->outer;
            				}
HXDLIN( 399)				if (hx::IsNotNull( _hx_tmp2 )) {
HXLINE( 399)					 ::nape::space::Space _hx_tmp3;
HXDLIN( 399)					if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 399)						_hx_tmp3 = null();
            					}
            					else {
HXLINE( 399)						_hx_tmp3 = this->zpp_inner->space->outer;
            					}
HXDLIN( 399)					_hx_tmp3->zpp_inner->wrap_bodies->remove(hx::ObjectPtr<OBJ_>(this));
            				}
HXLINE( 400)				if (hx::IsNotNull( space )) {
HXLINE( 400)					 ::nape::phys::BodyList _this = space->zpp_inner->wrap_bodies;
HXDLIN( 400)					if (_this->zpp_inner->reverse_flag) {
HXLINE( 400)						_this->push(hx::ObjectPtr<OBJ_>(this));
            					}
            					else {
HXLINE( 400)						_this->unshift(hx::ObjectPtr<OBJ_>(this));
            					}
            				}
            			}
            		}
HXLINE( 403)		if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 403)			return null();
            		}
            		else {
HXLINE( 403)			return this->zpp_inner->space->outer;
            		}
HXDLIN( 403)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_space,return )

 ::nape::dynamics::ArbiterList Body_obj::get_arbiters(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_412_get_arbiters)
HXLINE( 413)		if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE( 413)			this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            		}
HXLINE( 414)		return this->zpp_inner->wrap_arbiters;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_arbiters,return )

bool Body_obj::get_isSleeping(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_428_get_isSleeping)
HXLINE( 430)		if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 430)			HX_STACK_DO_THROW(HX_("Error: isSleeping makes no sense if the object is not contained within a Space",1a,c1,d3,eb));
            		}
HXLINE( 432)		return this->zpp_inner->component->sleeping;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_isSleeping,return )

 ::nape::constraint::ConstraintList Body_obj::get_constraints(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_443_get_constraints)
HXLINE( 444)		if (hx::IsNull( this->zpp_inner->wrap_constraints )) {
HXLINE( 444)			this->zpp_inner->wrap_constraints = ::zpp_nape::util::ZPP_ConstraintList_obj::get(this->zpp_inner->constraints,true);
            		}
HXLINE( 445)		return this->zpp_inner->wrap_constraints;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_constraints,return )

 ::nape::phys::Body Body_obj::copy(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_542_copy)
HXLINE( 544)		if (this->zpp_inner->world) {
HXLINE( 544)			HX_STACK_DO_THROW(HX_("Error: Space::world cannot be copied",8a,96,3d,f8));
            		}
HXLINE( 546)		return this->zpp_inner->copy();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,copy,return )

 ::nape::geom::Vec2 Body_obj::get_position(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_564_get_position)
HXLINE( 565)		if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE( 565)			this->zpp_inner->setupPosition();
            		}
HXLINE( 566)		return this->zpp_inner->wrap_pos;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_position,return )

 ::nape::geom::Vec2 Body_obj::set_position( ::nape::geom::Vec2 position){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_568_set_position)
HXLINE( 569)		{
HXLINE( 572)			bool _hx_tmp;
HXDLIN( 572)			if (hx::IsNotNull( position )) {
HXLINE( 572)				_hx_tmp = position->zpp_disp;
            			}
            			else {
HXLINE( 572)				_hx_tmp = false;
            			}
HXDLIN( 572)			if (_hx_tmp) {
HXLINE( 572)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 576)			if (hx::IsNull( position )) {
HXLINE( 576)				HX_STACK_DO_THROW(((HX_("Error: Body::",d0,64,91,7e) + HX_("position",a9,a0,fa,ca)) + HX_(" cannot be null",07,dc,5d,15)));
            			}
HXLINE( 578)			{
HXLINE( 578)				if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE( 578)					this->zpp_inner->setupPosition();
            				}
HXDLIN( 578)				 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_pos;
HXDLIN( 578)				bool _hx_tmp1;
HXDLIN( 578)				if (hx::IsNotNull( _this )) {
HXLINE( 578)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 578)					_hx_tmp1 = false;
            				}
HXDLIN( 578)				if (_hx_tmp1) {
HXLINE( 578)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 578)				bool _hx_tmp2;
HXDLIN( 578)				if (hx::IsNotNull( position )) {
HXLINE( 578)					_hx_tmp2 = position->zpp_disp;
            				}
            				else {
HXLINE( 578)					_hx_tmp2 = false;
            				}
HXDLIN( 578)				if (_hx_tmp2) {
HXLINE( 578)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 578)				{
HXLINE( 578)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 578)					if (_this1->_immutable) {
HXLINE( 578)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 578)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 578)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 578)				if (hx::IsNull( position )) {
HXLINE( 578)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 578)				bool _hx_tmp3;
HXDLIN( 578)				if (hx::IsNotNull( position )) {
HXLINE( 578)					_hx_tmp3 = position->zpp_disp;
            				}
            				else {
HXLINE( 578)					_hx_tmp3 = false;
            				}
HXDLIN( 578)				if (_hx_tmp3) {
HXLINE( 578)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 578)				{
HXLINE( 578)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = position->zpp_inner;
HXDLIN( 578)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 578)						_this2->_validate();
            					}
            				}
HXDLIN( 578)				Float x = position->zpp_inner->x;
HXDLIN( 578)				bool _hx_tmp4;
HXDLIN( 578)				if (hx::IsNotNull( position )) {
HXLINE( 578)					_hx_tmp4 = position->zpp_disp;
            				}
            				else {
HXLINE( 578)					_hx_tmp4 = false;
            				}
HXDLIN( 578)				if (_hx_tmp4) {
HXLINE( 578)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 578)				{
HXLINE( 578)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = position->zpp_inner;
HXDLIN( 578)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 578)						_this3->_validate();
            					}
            				}
HXDLIN( 578)				Float y = position->zpp_inner->y;
HXDLIN( 578)				bool _hx_tmp5;
HXDLIN( 578)				if (hx::IsNotNull( _this )) {
HXLINE( 578)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 578)					_hx_tmp5 = false;
            				}
HXDLIN( 578)				if (_hx_tmp5) {
HXLINE( 578)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 578)				{
HXLINE( 578)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 578)					if (_this4->_immutable) {
HXLINE( 578)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 578)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 578)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 578)				bool _hx_tmp6;
HXDLIN( 578)				if ((x == x)) {
HXLINE( 578)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 578)					_hx_tmp6 = true;
            				}
HXDLIN( 578)				if (_hx_tmp6) {
HXLINE( 578)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 578)				bool _hx_tmp7;
HXDLIN( 578)				bool _hx_tmp8;
HXDLIN( 578)				if (hx::IsNotNull( _this )) {
HXLINE( 578)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 578)					_hx_tmp8 = false;
            				}
HXDLIN( 578)				if (_hx_tmp8) {
HXLINE( 578)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 578)				{
HXLINE( 578)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 578)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 578)						_this5->_validate();
            					}
            				}
HXDLIN( 578)				if ((_this->zpp_inner->x == x)) {
HXLINE( 578)					bool _hx_tmp9;
HXDLIN( 578)					if (hx::IsNotNull( _this )) {
HXLINE( 578)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 578)						_hx_tmp9 = false;
            					}
HXDLIN( 578)					if (_hx_tmp9) {
HXLINE( 578)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 578)					{
HXLINE( 578)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 578)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 578)							_this6->_validate();
            						}
            					}
HXDLIN( 578)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 578)					_hx_tmp7 = false;
            				}
HXDLIN( 578)				if (!(_hx_tmp7)) {
HXLINE( 578)					{
HXLINE( 578)						_this->zpp_inner->x = x;
HXDLIN( 578)						_this->zpp_inner->y = y;
            					}
HXDLIN( 578)					{
HXLINE( 578)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 578)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 578)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 578)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 578)				if (position->zpp_inner->weak) {
HXLINE( 578)					bool _hx_tmp10;
HXDLIN( 578)					if (hx::IsNotNull( position )) {
HXLINE( 578)						_hx_tmp10 = position->zpp_disp;
            					}
            					else {
HXLINE( 578)						_hx_tmp10 = false;
            					}
HXDLIN( 578)					if (_hx_tmp10) {
HXLINE( 578)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 578)					{
HXLINE( 578)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = position->zpp_inner;
HXDLIN( 578)						if (_this8->_immutable) {
HXLINE( 578)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 578)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 578)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 578)					if (position->zpp_inner->_inuse) {
HXLINE( 578)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 578)					 ::zpp_nape::geom::ZPP_Vec2 inner = position->zpp_inner;
HXDLIN( 578)					position->zpp_inner->outer = null();
HXDLIN( 578)					position->zpp_inner = null();
HXDLIN( 578)					{
HXLINE( 578)						 ::nape::geom::Vec2 o = position;
HXDLIN( 578)						o->zpp_pool = null();
HXDLIN( 578)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 578)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 578)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 578)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 578)						o->zpp_disp = true;
            					}
HXDLIN( 578)					{
HXLINE( 578)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 578)						{
HXLINE( 578)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 578)								o1->outer->zpp_inner = null();
HXDLIN( 578)								o1->outer = null();
            							}
HXDLIN( 578)							o1->_isimmutable = null();
HXDLIN( 578)							o1->_validate = null();
HXDLIN( 578)							o1->_invalidate = null();
            						}
HXDLIN( 578)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 578)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 580)		if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE( 580)			this->zpp_inner->setupPosition();
            		}
HXDLIN( 580)		return this->zpp_inner->wrap_pos;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_position,return )

 ::nape::geom::Vec2 Body_obj::get_velocity(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_593_get_velocity)
HXLINE( 594)		if (hx::IsNull( this->zpp_inner->wrap_vel )) {
HXLINE( 594)			this->zpp_inner->setupVelocity();
            		}
HXLINE( 595)		return this->zpp_inner->wrap_vel;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_velocity,return )

 ::nape::geom::Vec2 Body_obj::set_velocity( ::nape::geom::Vec2 velocity){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_597_set_velocity)
HXLINE( 598)		{
HXLINE( 601)			bool _hx_tmp;
HXDLIN( 601)			if (hx::IsNotNull( velocity )) {
HXLINE( 601)				_hx_tmp = velocity->zpp_disp;
            			}
            			else {
HXLINE( 601)				_hx_tmp = false;
            			}
HXDLIN( 601)			if (_hx_tmp) {
HXLINE( 601)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 605)			if (hx::IsNull( velocity )) {
HXLINE( 605)				HX_STACK_DO_THROW(((HX_("Error: Body::",d0,64,91,7e) + HX_("velocity",1d,02,fe,1e)) + HX_(" cannot be null",07,dc,5d,15)));
            			}
HXLINE( 607)			{
HXLINE( 607)				if (hx::IsNull( this->zpp_inner->wrap_vel )) {
HXLINE( 607)					this->zpp_inner->setupVelocity();
            				}
HXDLIN( 607)				 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_vel;
HXDLIN( 607)				bool _hx_tmp1;
HXDLIN( 607)				if (hx::IsNotNull( _this )) {
HXLINE( 607)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 607)					_hx_tmp1 = false;
            				}
HXDLIN( 607)				if (_hx_tmp1) {
HXLINE( 607)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 607)				bool _hx_tmp2;
HXDLIN( 607)				if (hx::IsNotNull( velocity )) {
HXLINE( 607)					_hx_tmp2 = velocity->zpp_disp;
            				}
            				else {
HXLINE( 607)					_hx_tmp2 = false;
            				}
HXDLIN( 607)				if (_hx_tmp2) {
HXLINE( 607)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 607)				{
HXLINE( 607)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 607)					if (_this1->_immutable) {
HXLINE( 607)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 607)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 607)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 607)				if (hx::IsNull( velocity )) {
HXLINE( 607)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 607)				bool _hx_tmp3;
HXDLIN( 607)				if (hx::IsNotNull( velocity )) {
HXLINE( 607)					_hx_tmp3 = velocity->zpp_disp;
            				}
            				else {
HXLINE( 607)					_hx_tmp3 = false;
            				}
HXDLIN( 607)				if (_hx_tmp3) {
HXLINE( 607)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 607)				{
HXLINE( 607)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = velocity->zpp_inner;
HXDLIN( 607)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 607)						_this2->_validate();
            					}
            				}
HXDLIN( 607)				Float x = velocity->zpp_inner->x;
HXDLIN( 607)				bool _hx_tmp4;
HXDLIN( 607)				if (hx::IsNotNull( velocity )) {
HXLINE( 607)					_hx_tmp4 = velocity->zpp_disp;
            				}
            				else {
HXLINE( 607)					_hx_tmp4 = false;
            				}
HXDLIN( 607)				if (_hx_tmp4) {
HXLINE( 607)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 607)				{
HXLINE( 607)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = velocity->zpp_inner;
HXDLIN( 607)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 607)						_this3->_validate();
            					}
            				}
HXDLIN( 607)				Float y = velocity->zpp_inner->y;
HXDLIN( 607)				bool _hx_tmp5;
HXDLIN( 607)				if (hx::IsNotNull( _this )) {
HXLINE( 607)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 607)					_hx_tmp5 = false;
            				}
HXDLIN( 607)				if (_hx_tmp5) {
HXLINE( 607)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 607)				{
HXLINE( 607)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 607)					if (_this4->_immutable) {
HXLINE( 607)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 607)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 607)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 607)				bool _hx_tmp6;
HXDLIN( 607)				if ((x == x)) {
HXLINE( 607)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 607)					_hx_tmp6 = true;
            				}
HXDLIN( 607)				if (_hx_tmp6) {
HXLINE( 607)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 607)				bool _hx_tmp7;
HXDLIN( 607)				bool _hx_tmp8;
HXDLIN( 607)				if (hx::IsNotNull( _this )) {
HXLINE( 607)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 607)					_hx_tmp8 = false;
            				}
HXDLIN( 607)				if (_hx_tmp8) {
HXLINE( 607)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 607)				{
HXLINE( 607)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 607)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 607)						_this5->_validate();
            					}
            				}
HXDLIN( 607)				if ((_this->zpp_inner->x == x)) {
HXLINE( 607)					bool _hx_tmp9;
HXDLIN( 607)					if (hx::IsNotNull( _this )) {
HXLINE( 607)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 607)						_hx_tmp9 = false;
            					}
HXDLIN( 607)					if (_hx_tmp9) {
HXLINE( 607)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 607)					{
HXLINE( 607)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 607)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 607)							_this6->_validate();
            						}
            					}
HXDLIN( 607)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 607)					_hx_tmp7 = false;
            				}
HXDLIN( 607)				if (!(_hx_tmp7)) {
HXLINE( 607)					{
HXLINE( 607)						_this->zpp_inner->x = x;
HXDLIN( 607)						_this->zpp_inner->y = y;
            					}
HXDLIN( 607)					{
HXLINE( 607)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 607)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 607)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 607)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 607)				if (velocity->zpp_inner->weak) {
HXLINE( 607)					bool _hx_tmp10;
HXDLIN( 607)					if (hx::IsNotNull( velocity )) {
HXLINE( 607)						_hx_tmp10 = velocity->zpp_disp;
            					}
            					else {
HXLINE( 607)						_hx_tmp10 = false;
            					}
HXDLIN( 607)					if (_hx_tmp10) {
HXLINE( 607)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 607)					{
HXLINE( 607)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = velocity->zpp_inner;
HXDLIN( 607)						if (_this8->_immutable) {
HXLINE( 607)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 607)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 607)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 607)					if (velocity->zpp_inner->_inuse) {
HXLINE( 607)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 607)					 ::zpp_nape::geom::ZPP_Vec2 inner = velocity->zpp_inner;
HXDLIN( 607)					velocity->zpp_inner->outer = null();
HXDLIN( 607)					velocity->zpp_inner = null();
HXDLIN( 607)					{
HXLINE( 607)						 ::nape::geom::Vec2 o = velocity;
HXDLIN( 607)						o->zpp_pool = null();
HXDLIN( 607)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 607)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 607)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 607)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 607)						o->zpp_disp = true;
            					}
HXDLIN( 607)					{
HXLINE( 607)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 607)						{
HXLINE( 607)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 607)								o1->outer->zpp_inner = null();
HXDLIN( 607)								o1->outer = null();
            							}
HXDLIN( 607)							o1->_isimmutable = null();
HXDLIN( 607)							o1->_validate = null();
HXDLIN( 607)							o1->_invalidate = null();
            						}
HXDLIN( 607)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 607)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 609)		if (hx::IsNull( this->zpp_inner->wrap_vel )) {
HXLINE( 609)			this->zpp_inner->setupVelocity();
            		}
HXDLIN( 609)		return this->zpp_inner->wrap_vel;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_velocity,return )

 ::nape::phys::Body Body_obj::setVelocityFromTarget( ::nape::geom::Vec2 targetPosition,Float targetRotation,Float deltaTime){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_628_setVelocityFromTarget)
HXLINE( 631)		bool _hx_tmp;
HXDLIN( 631)		if (hx::IsNotNull( targetPosition )) {
HXLINE( 631)			_hx_tmp = targetPosition->zpp_disp;
            		}
            		else {
HXLINE( 631)			_hx_tmp = false;
            		}
HXDLIN( 631)		if (_hx_tmp) {
HXLINE( 631)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 635)		if (hx::IsNull( targetPosition )) {
HXLINE( 635)			HX_STACK_DO_THROW(HX_("Cannot set velocity for null target position",de,2d,b3,30));
            		}
HXLINE( 636)		if ((deltaTime == 0)) {
HXLINE( 636)			HX_STACK_DO_THROW(HX_("deltaTime cannot be 0 for setVelocityFromTarget",38,1b,1b,d9));
            		}
HXLINE( 638)		Float idt = (( (Float)(1) ) / deltaTime);
HXLINE( 639)		{
HXLINE( 639)			if (hx::IsNull( this->zpp_inner->wrap_vel )) {
HXLINE( 639)				this->zpp_inner->setupVelocity();
            			}
HXDLIN( 639)			 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_vel;
HXDLIN( 639)			if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE( 639)				this->zpp_inner->setupPosition();
            			}
HXDLIN( 639)			 ::nape::geom::Vec2 vector = targetPosition->sub(this->zpp_inner->wrap_pos,true)->muleq(idt);
HXDLIN( 639)			bool _hx_tmp1;
HXDLIN( 639)			if (hx::IsNotNull( _this )) {
HXLINE( 639)				_hx_tmp1 = _this->zpp_disp;
            			}
            			else {
HXLINE( 639)				_hx_tmp1 = false;
            			}
HXDLIN( 639)			if (_hx_tmp1) {
HXLINE( 639)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 639)			bool _hx_tmp2;
HXDLIN( 639)			if (hx::IsNotNull( vector )) {
HXLINE( 639)				_hx_tmp2 = vector->zpp_disp;
            			}
            			else {
HXLINE( 639)				_hx_tmp2 = false;
            			}
HXDLIN( 639)			if (_hx_tmp2) {
HXLINE( 639)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 639)			{
HXLINE( 639)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 639)				if (_this1->_immutable) {
HXLINE( 639)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 639)				if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 639)					_this1->_isimmutable();
            				}
            			}
HXDLIN( 639)			if (hx::IsNull( vector )) {
HXLINE( 639)				HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            			}
HXDLIN( 639)			bool _hx_tmp3;
HXDLIN( 639)			if (hx::IsNotNull( vector )) {
HXLINE( 639)				_hx_tmp3 = vector->zpp_disp;
            			}
            			else {
HXLINE( 639)				_hx_tmp3 = false;
            			}
HXDLIN( 639)			if (_hx_tmp3) {
HXLINE( 639)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 639)			{
HXLINE( 639)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = vector->zpp_inner;
HXDLIN( 639)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 639)					_this2->_validate();
            				}
            			}
HXDLIN( 639)			Float x = vector->zpp_inner->x;
HXDLIN( 639)			bool _hx_tmp4;
HXDLIN( 639)			if (hx::IsNotNull( vector )) {
HXLINE( 639)				_hx_tmp4 = vector->zpp_disp;
            			}
            			else {
HXLINE( 639)				_hx_tmp4 = false;
            			}
HXDLIN( 639)			if (_hx_tmp4) {
HXLINE( 639)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 639)			{
HXLINE( 639)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = vector->zpp_inner;
HXDLIN( 639)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 639)					_this3->_validate();
            				}
            			}
HXDLIN( 639)			Float y = vector->zpp_inner->y;
HXDLIN( 639)			bool _hx_tmp5;
HXDLIN( 639)			if (hx::IsNotNull( _this )) {
HXLINE( 639)				_hx_tmp5 = _this->zpp_disp;
            			}
            			else {
HXLINE( 639)				_hx_tmp5 = false;
            			}
HXDLIN( 639)			if (_hx_tmp5) {
HXLINE( 639)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 639)			{
HXLINE( 639)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 639)				if (_this4->_immutable) {
HXLINE( 639)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 639)				if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 639)					_this4->_isimmutable();
            				}
            			}
HXDLIN( 639)			bool _hx_tmp6;
HXDLIN( 639)			if ((x == x)) {
HXLINE( 639)				_hx_tmp6 = (y != y);
            			}
            			else {
HXLINE( 639)				_hx_tmp6 = true;
            			}
HXDLIN( 639)			if (_hx_tmp6) {
HXLINE( 639)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN( 639)			bool _hx_tmp7;
HXDLIN( 639)			bool _hx_tmp8;
HXDLIN( 639)			if (hx::IsNotNull( _this )) {
HXLINE( 639)				_hx_tmp8 = _this->zpp_disp;
            			}
            			else {
HXLINE( 639)				_hx_tmp8 = false;
            			}
HXDLIN( 639)			if (_hx_tmp8) {
HXLINE( 639)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 639)			{
HXLINE( 639)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 639)				if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 639)					_this5->_validate();
            				}
            			}
HXDLIN( 639)			if ((_this->zpp_inner->x == x)) {
HXLINE( 639)				bool _hx_tmp9;
HXDLIN( 639)				if (hx::IsNotNull( _this )) {
HXLINE( 639)					_hx_tmp9 = _this->zpp_disp;
            				}
            				else {
HXLINE( 639)					_hx_tmp9 = false;
            				}
HXDLIN( 639)				if (_hx_tmp9) {
HXLINE( 639)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 639)				{
HXLINE( 639)					 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 639)					if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 639)						_this6->_validate();
            					}
            				}
HXDLIN( 639)				_hx_tmp7 = (_this->zpp_inner->y == y);
            			}
            			else {
HXLINE( 639)				_hx_tmp7 = false;
            			}
HXDLIN( 639)			if (!(_hx_tmp7)) {
HXLINE( 639)				{
HXLINE( 639)					_this->zpp_inner->x = x;
HXDLIN( 639)					_this->zpp_inner->y = y;
            				}
HXDLIN( 639)				{
HXLINE( 639)					 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 639)					if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 639)						_this7->_invalidate(_this7);
            					}
            				}
            			}
HXDLIN( 639)			 ::nape::geom::Vec2 ret = _this;
HXDLIN( 639)			if (vector->zpp_inner->weak) {
HXLINE( 639)				bool _hx_tmp10;
HXDLIN( 639)				if (hx::IsNotNull( vector )) {
HXLINE( 639)					_hx_tmp10 = vector->zpp_disp;
            				}
            				else {
HXLINE( 639)					_hx_tmp10 = false;
            				}
HXDLIN( 639)				if (_hx_tmp10) {
HXLINE( 639)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 639)				{
HXLINE( 639)					 ::zpp_nape::geom::ZPP_Vec2 _this8 = vector->zpp_inner;
HXDLIN( 639)					if (_this8->_immutable) {
HXLINE( 639)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 639)					if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 639)						_this8->_isimmutable();
            					}
            				}
HXDLIN( 639)				if (vector->zpp_inner->_inuse) {
HXLINE( 639)					HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            				}
HXDLIN( 639)				 ::zpp_nape::geom::ZPP_Vec2 inner = vector->zpp_inner;
HXDLIN( 639)				vector->zpp_inner->outer = null();
HXDLIN( 639)				vector->zpp_inner = null();
HXDLIN( 639)				{
HXLINE( 639)					 ::nape::geom::Vec2 o = vector;
HXDLIN( 639)					o->zpp_pool = null();
HXDLIN( 639)					if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 639)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            					}
            					else {
HXLINE( 639)						::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            					}
HXDLIN( 639)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 639)					o->zpp_disp = true;
            				}
HXDLIN( 639)				{
HXLINE( 639)					 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 639)					{
HXLINE( 639)						if (hx::IsNotNull( o1->outer )) {
HXLINE( 639)							o1->outer->zpp_inner = null();
HXDLIN( 639)							o1->outer = null();
            						}
HXDLIN( 639)						o1->_isimmutable = null();
HXDLIN( 639)						o1->_validate = null();
HXDLIN( 639)						o1->_invalidate = null();
            					}
HXDLIN( 639)					o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 639)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            				}
            			}
            		}
HXLINE( 640)		{
HXLINE( 640)			Float angularVel = ((targetRotation - this->zpp_inner->rot) * idt);
HXDLIN( 640)			{
HXLINE( 640)				if (this->zpp_inner->world) {
HXLINE( 640)					HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            				}
HXDLIN( 640)				if ((this->zpp_inner->angvel != angularVel)) {
HXLINE( 640)					if ((angularVel != angularVel)) {
HXLINE( 640)						HX_STACK_DO_THROW(HX_("Error: Body::angularVel cannot be NaN",c6,69,71,8d));
            					}
HXDLIN( 640)					if ((this->zpp_inner->type == 1)) {
HXLINE( 640)						HX_STACK_DO_THROW(HX_("Error: A static object cannot be given a velocity",3b,e0,bd,35));
            					}
HXDLIN( 640)					this->zpp_inner->angvel = angularVel;
HXDLIN( 640)					this->zpp_inner->wake();
            				}
            			}
            		}
HXLINE( 641)		if (targetPosition->zpp_inner->weak) {
HXLINE( 645)			bool _hx_tmp11;
HXDLIN( 645)			if (hx::IsNotNull( targetPosition )) {
HXLINE( 645)				_hx_tmp11 = targetPosition->zpp_disp;
            			}
            			else {
HXLINE( 645)				_hx_tmp11 = false;
            			}
HXDLIN( 645)			if (_hx_tmp11) {
HXLINE( 645)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 645)			{
HXLINE( 645)				 ::zpp_nape::geom::ZPP_Vec2 _this9 = targetPosition->zpp_inner;
HXDLIN( 645)				if (_this9->_immutable) {
HXLINE( 645)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 645)				if (hx::IsNotNull( _this9->_isimmutable )) {
HXLINE( 645)					_this9->_isimmutable();
            				}
            			}
HXDLIN( 645)			if (targetPosition->zpp_inner->_inuse) {
HXLINE( 645)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 645)			 ::zpp_nape::geom::ZPP_Vec2 inner1 = targetPosition->zpp_inner;
HXDLIN( 645)			targetPosition->zpp_inner->outer = null();
HXDLIN( 645)			targetPosition->zpp_inner = null();
HXDLIN( 645)			{
HXLINE( 645)				 ::nape::geom::Vec2 o2 = targetPosition;
HXDLIN( 645)				o2->zpp_pool = null();
HXDLIN( 645)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 645)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            				}
            				else {
HXLINE( 645)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            				}
HXDLIN( 645)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN( 645)				o2->zpp_disp = true;
            			}
HXDLIN( 645)			{
HXLINE( 645)				 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN( 645)				{
HXLINE( 645)					if (hx::IsNotNull( o3->outer )) {
HXLINE( 645)						o3->outer->zpp_inner = null();
HXDLIN( 645)						o3->outer = null();
            					}
HXDLIN( 645)					o3->_isimmutable = null();
HXDLIN( 645)					o3->_validate = null();
HXDLIN( 645)					o3->_invalidate = null();
            				}
HXDLIN( 645)				o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 645)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            			}
            		}
HXLINE( 652)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Body_obj,setVelocityFromTarget,return )

 ::nape::geom::Vec2 Body_obj::get_kinematicVel(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_668_get_kinematicVel)
HXLINE( 669)		if (hx::IsNull( this->zpp_inner->wrap_kinvel )) {
HXLINE( 669)			this->zpp_inner->setupkinvel();
            		}
HXLINE( 670)		return this->zpp_inner->wrap_kinvel;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_kinematicVel,return )

 ::nape::geom::Vec2 Body_obj::set_kinematicVel( ::nape::geom::Vec2 kinematicVel){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_672_set_kinematicVel)
HXLINE( 673)		{
HXLINE( 676)			bool _hx_tmp;
HXDLIN( 676)			if (hx::IsNotNull( kinematicVel )) {
HXLINE( 676)				_hx_tmp = kinematicVel->zpp_disp;
            			}
            			else {
HXLINE( 676)				_hx_tmp = false;
            			}
HXDLIN( 676)			if (_hx_tmp) {
HXLINE( 676)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 680)			if (hx::IsNull( kinematicVel )) {
HXLINE( 680)				HX_STACK_DO_THROW(((HX_("Error: Body::",d0,64,91,7e) + HX_("kinematicVel",58,d2,c1,63)) + HX_(" cannot be null",07,dc,5d,15)));
            			}
HXLINE( 682)			{
HXLINE( 682)				if (hx::IsNull( this->zpp_inner->wrap_kinvel )) {
HXLINE( 682)					this->zpp_inner->setupkinvel();
            				}
HXDLIN( 682)				 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_kinvel;
HXDLIN( 682)				bool _hx_tmp1;
HXDLIN( 682)				if (hx::IsNotNull( _this )) {
HXLINE( 682)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 682)					_hx_tmp1 = false;
            				}
HXDLIN( 682)				if (_hx_tmp1) {
HXLINE( 682)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 682)				bool _hx_tmp2;
HXDLIN( 682)				if (hx::IsNotNull( kinematicVel )) {
HXLINE( 682)					_hx_tmp2 = kinematicVel->zpp_disp;
            				}
            				else {
HXLINE( 682)					_hx_tmp2 = false;
            				}
HXDLIN( 682)				if (_hx_tmp2) {
HXLINE( 682)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 682)				{
HXLINE( 682)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 682)					if (_this1->_immutable) {
HXLINE( 682)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 682)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 682)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 682)				if (hx::IsNull( kinematicVel )) {
HXLINE( 682)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 682)				bool _hx_tmp3;
HXDLIN( 682)				if (hx::IsNotNull( kinematicVel )) {
HXLINE( 682)					_hx_tmp3 = kinematicVel->zpp_disp;
            				}
            				else {
HXLINE( 682)					_hx_tmp3 = false;
            				}
HXDLIN( 682)				if (_hx_tmp3) {
HXLINE( 682)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 682)				{
HXLINE( 682)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = kinematicVel->zpp_inner;
HXDLIN( 682)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 682)						_this2->_validate();
            					}
            				}
HXDLIN( 682)				Float x = kinematicVel->zpp_inner->x;
HXDLIN( 682)				bool _hx_tmp4;
HXDLIN( 682)				if (hx::IsNotNull( kinematicVel )) {
HXLINE( 682)					_hx_tmp4 = kinematicVel->zpp_disp;
            				}
            				else {
HXLINE( 682)					_hx_tmp4 = false;
            				}
HXDLIN( 682)				if (_hx_tmp4) {
HXLINE( 682)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 682)				{
HXLINE( 682)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = kinematicVel->zpp_inner;
HXDLIN( 682)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 682)						_this3->_validate();
            					}
            				}
HXDLIN( 682)				Float y = kinematicVel->zpp_inner->y;
HXDLIN( 682)				bool _hx_tmp5;
HXDLIN( 682)				if (hx::IsNotNull( _this )) {
HXLINE( 682)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 682)					_hx_tmp5 = false;
            				}
HXDLIN( 682)				if (_hx_tmp5) {
HXLINE( 682)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 682)				{
HXLINE( 682)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 682)					if (_this4->_immutable) {
HXLINE( 682)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 682)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 682)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 682)				bool _hx_tmp6;
HXDLIN( 682)				if ((x == x)) {
HXLINE( 682)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 682)					_hx_tmp6 = true;
            				}
HXDLIN( 682)				if (_hx_tmp6) {
HXLINE( 682)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 682)				bool _hx_tmp7;
HXDLIN( 682)				bool _hx_tmp8;
HXDLIN( 682)				if (hx::IsNotNull( _this )) {
HXLINE( 682)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 682)					_hx_tmp8 = false;
            				}
HXDLIN( 682)				if (_hx_tmp8) {
HXLINE( 682)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 682)				{
HXLINE( 682)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 682)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 682)						_this5->_validate();
            					}
            				}
HXDLIN( 682)				if ((_this->zpp_inner->x == x)) {
HXLINE( 682)					bool _hx_tmp9;
HXDLIN( 682)					if (hx::IsNotNull( _this )) {
HXLINE( 682)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 682)						_hx_tmp9 = false;
            					}
HXDLIN( 682)					if (_hx_tmp9) {
HXLINE( 682)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 682)					{
HXLINE( 682)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 682)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 682)							_this6->_validate();
            						}
            					}
HXDLIN( 682)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 682)					_hx_tmp7 = false;
            				}
HXDLIN( 682)				if (!(_hx_tmp7)) {
HXLINE( 682)					{
HXLINE( 682)						_this->zpp_inner->x = x;
HXDLIN( 682)						_this->zpp_inner->y = y;
            					}
HXDLIN( 682)					{
HXLINE( 682)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 682)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 682)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 682)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 682)				if (kinematicVel->zpp_inner->weak) {
HXLINE( 682)					bool _hx_tmp10;
HXDLIN( 682)					if (hx::IsNotNull( kinematicVel )) {
HXLINE( 682)						_hx_tmp10 = kinematicVel->zpp_disp;
            					}
            					else {
HXLINE( 682)						_hx_tmp10 = false;
            					}
HXDLIN( 682)					if (_hx_tmp10) {
HXLINE( 682)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 682)					{
HXLINE( 682)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = kinematicVel->zpp_inner;
HXDLIN( 682)						if (_this8->_immutable) {
HXLINE( 682)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 682)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 682)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 682)					if (kinematicVel->zpp_inner->_inuse) {
HXLINE( 682)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 682)					 ::zpp_nape::geom::ZPP_Vec2 inner = kinematicVel->zpp_inner;
HXDLIN( 682)					kinematicVel->zpp_inner->outer = null();
HXDLIN( 682)					kinematicVel->zpp_inner = null();
HXDLIN( 682)					{
HXLINE( 682)						 ::nape::geom::Vec2 o = kinematicVel;
HXDLIN( 682)						o->zpp_pool = null();
HXDLIN( 682)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 682)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 682)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 682)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 682)						o->zpp_disp = true;
            					}
HXDLIN( 682)					{
HXLINE( 682)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 682)						{
HXLINE( 682)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 682)								o1->outer->zpp_inner = null();
HXDLIN( 682)								o1->outer = null();
            							}
HXDLIN( 682)							o1->_isimmutable = null();
HXDLIN( 682)							o1->_validate = null();
HXDLIN( 682)							o1->_invalidate = null();
            						}
HXDLIN( 682)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 682)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 684)		if (hx::IsNull( this->zpp_inner->wrap_kinvel )) {
HXLINE( 684)			this->zpp_inner->setupkinvel();
            		}
HXDLIN( 684)		return this->zpp_inner->wrap_kinvel;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_kinematicVel,return )

 ::nape::geom::Vec2 Body_obj::get_surfaceVel(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_700_get_surfaceVel)
HXLINE( 701)		if (hx::IsNull( this->zpp_inner->wrap_svel )) {
HXLINE( 701)			this->zpp_inner->setupsvel();
            		}
HXLINE( 702)		return this->zpp_inner->wrap_svel;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_surfaceVel,return )

 ::nape::geom::Vec2 Body_obj::set_surfaceVel( ::nape::geom::Vec2 surfaceVel){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_704_set_surfaceVel)
HXLINE( 705)		{
HXLINE( 708)			bool _hx_tmp;
HXDLIN( 708)			if (hx::IsNotNull( surfaceVel )) {
HXLINE( 708)				_hx_tmp = surfaceVel->zpp_disp;
            			}
            			else {
HXLINE( 708)				_hx_tmp = false;
            			}
HXDLIN( 708)			if (_hx_tmp) {
HXLINE( 708)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 712)			if (hx::IsNull( surfaceVel )) {
HXLINE( 712)				HX_STACK_DO_THROW(((HX_("Error: Body::",d0,64,91,7e) + HX_("surfaceVel",30,8e,1a,e0)) + HX_(" cannot be null",07,dc,5d,15)));
            			}
HXLINE( 714)			{
HXLINE( 714)				if (hx::IsNull( this->zpp_inner->wrap_svel )) {
HXLINE( 714)					this->zpp_inner->setupsvel();
            				}
HXDLIN( 714)				 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_svel;
HXDLIN( 714)				bool _hx_tmp1;
HXDLIN( 714)				if (hx::IsNotNull( _this )) {
HXLINE( 714)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 714)					_hx_tmp1 = false;
            				}
HXDLIN( 714)				if (_hx_tmp1) {
HXLINE( 714)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 714)				bool _hx_tmp2;
HXDLIN( 714)				if (hx::IsNotNull( surfaceVel )) {
HXLINE( 714)					_hx_tmp2 = surfaceVel->zpp_disp;
            				}
            				else {
HXLINE( 714)					_hx_tmp2 = false;
            				}
HXDLIN( 714)				if (_hx_tmp2) {
HXLINE( 714)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 714)				{
HXLINE( 714)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 714)					if (_this1->_immutable) {
HXLINE( 714)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 714)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 714)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 714)				if (hx::IsNull( surfaceVel )) {
HXLINE( 714)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 714)				bool _hx_tmp3;
HXDLIN( 714)				if (hx::IsNotNull( surfaceVel )) {
HXLINE( 714)					_hx_tmp3 = surfaceVel->zpp_disp;
            				}
            				else {
HXLINE( 714)					_hx_tmp3 = false;
            				}
HXDLIN( 714)				if (_hx_tmp3) {
HXLINE( 714)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 714)				{
HXLINE( 714)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = surfaceVel->zpp_inner;
HXDLIN( 714)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 714)						_this2->_validate();
            					}
            				}
HXDLIN( 714)				Float x = surfaceVel->zpp_inner->x;
HXDLIN( 714)				bool _hx_tmp4;
HXDLIN( 714)				if (hx::IsNotNull( surfaceVel )) {
HXLINE( 714)					_hx_tmp4 = surfaceVel->zpp_disp;
            				}
            				else {
HXLINE( 714)					_hx_tmp4 = false;
            				}
HXDLIN( 714)				if (_hx_tmp4) {
HXLINE( 714)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 714)				{
HXLINE( 714)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = surfaceVel->zpp_inner;
HXDLIN( 714)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 714)						_this3->_validate();
            					}
            				}
HXDLIN( 714)				Float y = surfaceVel->zpp_inner->y;
HXDLIN( 714)				bool _hx_tmp5;
HXDLIN( 714)				if (hx::IsNotNull( _this )) {
HXLINE( 714)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 714)					_hx_tmp5 = false;
            				}
HXDLIN( 714)				if (_hx_tmp5) {
HXLINE( 714)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 714)				{
HXLINE( 714)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 714)					if (_this4->_immutable) {
HXLINE( 714)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 714)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 714)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 714)				bool _hx_tmp6;
HXDLIN( 714)				if ((x == x)) {
HXLINE( 714)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 714)					_hx_tmp6 = true;
            				}
HXDLIN( 714)				if (_hx_tmp6) {
HXLINE( 714)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 714)				bool _hx_tmp7;
HXDLIN( 714)				bool _hx_tmp8;
HXDLIN( 714)				if (hx::IsNotNull( _this )) {
HXLINE( 714)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 714)					_hx_tmp8 = false;
            				}
HXDLIN( 714)				if (_hx_tmp8) {
HXLINE( 714)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 714)				{
HXLINE( 714)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 714)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 714)						_this5->_validate();
            					}
            				}
HXDLIN( 714)				if ((_this->zpp_inner->x == x)) {
HXLINE( 714)					bool _hx_tmp9;
HXDLIN( 714)					if (hx::IsNotNull( _this )) {
HXLINE( 714)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 714)						_hx_tmp9 = false;
            					}
HXDLIN( 714)					if (_hx_tmp9) {
HXLINE( 714)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 714)					{
HXLINE( 714)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 714)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 714)							_this6->_validate();
            						}
            					}
HXDLIN( 714)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 714)					_hx_tmp7 = false;
            				}
HXDLIN( 714)				if (!(_hx_tmp7)) {
HXLINE( 714)					{
HXLINE( 714)						_this->zpp_inner->x = x;
HXDLIN( 714)						_this->zpp_inner->y = y;
            					}
HXDLIN( 714)					{
HXLINE( 714)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 714)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 714)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 714)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 714)				if (surfaceVel->zpp_inner->weak) {
HXLINE( 714)					bool _hx_tmp10;
HXDLIN( 714)					if (hx::IsNotNull( surfaceVel )) {
HXLINE( 714)						_hx_tmp10 = surfaceVel->zpp_disp;
            					}
            					else {
HXLINE( 714)						_hx_tmp10 = false;
            					}
HXDLIN( 714)					if (_hx_tmp10) {
HXLINE( 714)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 714)					{
HXLINE( 714)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = surfaceVel->zpp_inner;
HXDLIN( 714)						if (_this8->_immutable) {
HXLINE( 714)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 714)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 714)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 714)					if (surfaceVel->zpp_inner->_inuse) {
HXLINE( 714)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 714)					 ::zpp_nape::geom::ZPP_Vec2 inner = surfaceVel->zpp_inner;
HXDLIN( 714)					surfaceVel->zpp_inner->outer = null();
HXDLIN( 714)					surfaceVel->zpp_inner = null();
HXDLIN( 714)					{
HXLINE( 714)						 ::nape::geom::Vec2 o = surfaceVel;
HXDLIN( 714)						o->zpp_pool = null();
HXDLIN( 714)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 714)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 714)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 714)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 714)						o->zpp_disp = true;
            					}
HXDLIN( 714)					{
HXLINE( 714)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 714)						{
HXLINE( 714)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 714)								o1->outer->zpp_inner = null();
HXDLIN( 714)								o1->outer = null();
            							}
HXDLIN( 714)							o1->_isimmutable = null();
HXDLIN( 714)							o1->_validate = null();
HXDLIN( 714)							o1->_invalidate = null();
            						}
HXDLIN( 714)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 714)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 716)		if (hx::IsNull( this->zpp_inner->wrap_svel )) {
HXLINE( 716)			this->zpp_inner->setupsvel();
            		}
HXDLIN( 716)		return this->zpp_inner->wrap_svel;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_surfaceVel,return )

 ::nape::geom::Vec2 Body_obj::get_force(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_729_get_force)
HXLINE( 730)		if (hx::IsNull( this->zpp_inner->wrap_force )) {
HXLINE( 730)			this->zpp_inner->setupForce();
            		}
HXLINE( 731)		return this->zpp_inner->wrap_force;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_force,return )

 ::nape::geom::Vec2 Body_obj::set_force( ::nape::geom::Vec2 force){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_733_set_force)
HXLINE( 734)		{
HXLINE( 737)			bool _hx_tmp;
HXDLIN( 737)			if (hx::IsNotNull( force )) {
HXLINE( 737)				_hx_tmp = force->zpp_disp;
            			}
            			else {
HXLINE( 737)				_hx_tmp = false;
            			}
HXDLIN( 737)			if (_hx_tmp) {
HXLINE( 737)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 741)			if (hx::IsNull( force )) {
HXLINE( 741)				HX_STACK_DO_THROW(((HX_("Error: Body::",d0,64,91,7e) + HX_("force",eb,b1,94,04)) + HX_(" cannot be null",07,dc,5d,15)));
            			}
HXLINE( 743)			{
HXLINE( 743)				if (hx::IsNull( this->zpp_inner->wrap_force )) {
HXLINE( 743)					this->zpp_inner->setupForce();
            				}
HXDLIN( 743)				 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_force;
HXDLIN( 743)				bool _hx_tmp1;
HXDLIN( 743)				if (hx::IsNotNull( _this )) {
HXLINE( 743)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 743)					_hx_tmp1 = false;
            				}
HXDLIN( 743)				if (_hx_tmp1) {
HXLINE( 743)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 743)				bool _hx_tmp2;
HXDLIN( 743)				if (hx::IsNotNull( force )) {
HXLINE( 743)					_hx_tmp2 = force->zpp_disp;
            				}
            				else {
HXLINE( 743)					_hx_tmp2 = false;
            				}
HXDLIN( 743)				if (_hx_tmp2) {
HXLINE( 743)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 743)				{
HXLINE( 743)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 743)					if (_this1->_immutable) {
HXLINE( 743)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 743)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 743)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 743)				if (hx::IsNull( force )) {
HXLINE( 743)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 743)				bool _hx_tmp3;
HXDLIN( 743)				if (hx::IsNotNull( force )) {
HXLINE( 743)					_hx_tmp3 = force->zpp_disp;
            				}
            				else {
HXLINE( 743)					_hx_tmp3 = false;
            				}
HXDLIN( 743)				if (_hx_tmp3) {
HXLINE( 743)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 743)				{
HXLINE( 743)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = force->zpp_inner;
HXDLIN( 743)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 743)						_this2->_validate();
            					}
            				}
HXDLIN( 743)				Float x = force->zpp_inner->x;
HXDLIN( 743)				bool _hx_tmp4;
HXDLIN( 743)				if (hx::IsNotNull( force )) {
HXLINE( 743)					_hx_tmp4 = force->zpp_disp;
            				}
            				else {
HXLINE( 743)					_hx_tmp4 = false;
            				}
HXDLIN( 743)				if (_hx_tmp4) {
HXLINE( 743)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 743)				{
HXLINE( 743)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = force->zpp_inner;
HXDLIN( 743)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 743)						_this3->_validate();
            					}
            				}
HXDLIN( 743)				Float y = force->zpp_inner->y;
HXDLIN( 743)				bool _hx_tmp5;
HXDLIN( 743)				if (hx::IsNotNull( _this )) {
HXLINE( 743)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 743)					_hx_tmp5 = false;
            				}
HXDLIN( 743)				if (_hx_tmp5) {
HXLINE( 743)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 743)				{
HXLINE( 743)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 743)					if (_this4->_immutable) {
HXLINE( 743)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 743)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 743)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 743)				bool _hx_tmp6;
HXDLIN( 743)				if ((x == x)) {
HXLINE( 743)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 743)					_hx_tmp6 = true;
            				}
HXDLIN( 743)				if (_hx_tmp6) {
HXLINE( 743)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 743)				bool _hx_tmp7;
HXDLIN( 743)				bool _hx_tmp8;
HXDLIN( 743)				if (hx::IsNotNull( _this )) {
HXLINE( 743)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 743)					_hx_tmp8 = false;
            				}
HXDLIN( 743)				if (_hx_tmp8) {
HXLINE( 743)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 743)				{
HXLINE( 743)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 743)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 743)						_this5->_validate();
            					}
            				}
HXDLIN( 743)				if ((_this->zpp_inner->x == x)) {
HXLINE( 743)					bool _hx_tmp9;
HXDLIN( 743)					if (hx::IsNotNull( _this )) {
HXLINE( 743)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 743)						_hx_tmp9 = false;
            					}
HXDLIN( 743)					if (_hx_tmp9) {
HXLINE( 743)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 743)					{
HXLINE( 743)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 743)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 743)							_this6->_validate();
            						}
            					}
HXDLIN( 743)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 743)					_hx_tmp7 = false;
            				}
HXDLIN( 743)				if (!(_hx_tmp7)) {
HXLINE( 743)					{
HXLINE( 743)						_this->zpp_inner->x = x;
HXDLIN( 743)						_this->zpp_inner->y = y;
            					}
HXDLIN( 743)					{
HXLINE( 743)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 743)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 743)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 743)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 743)				if (force->zpp_inner->weak) {
HXLINE( 743)					bool _hx_tmp10;
HXDLIN( 743)					if (hx::IsNotNull( force )) {
HXLINE( 743)						_hx_tmp10 = force->zpp_disp;
            					}
            					else {
HXLINE( 743)						_hx_tmp10 = false;
            					}
HXDLIN( 743)					if (_hx_tmp10) {
HXLINE( 743)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 743)					{
HXLINE( 743)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = force->zpp_inner;
HXDLIN( 743)						if (_this8->_immutable) {
HXLINE( 743)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 743)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 743)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 743)					if (force->zpp_inner->_inuse) {
HXLINE( 743)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 743)					 ::zpp_nape::geom::ZPP_Vec2 inner = force->zpp_inner;
HXDLIN( 743)					force->zpp_inner->outer = null();
HXDLIN( 743)					force->zpp_inner = null();
HXDLIN( 743)					{
HXLINE( 743)						 ::nape::geom::Vec2 o = force;
HXDLIN( 743)						o->zpp_pool = null();
HXDLIN( 743)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 743)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 743)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 743)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 743)						o->zpp_disp = true;
            					}
HXDLIN( 743)					{
HXLINE( 743)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 743)						{
HXLINE( 743)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 743)								o1->outer->zpp_inner = null();
HXDLIN( 743)								o1->outer = null();
            							}
HXDLIN( 743)							o1->_isimmutable = null();
HXDLIN( 743)							o1->_validate = null();
HXDLIN( 743)							o1->_invalidate = null();
            						}
HXDLIN( 743)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 743)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 745)		if (hx::IsNull( this->zpp_inner->wrap_force )) {
HXLINE( 745)			this->zpp_inner->setupForce();
            		}
HXDLIN( 745)		return this->zpp_inner->wrap_force;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_force,return )

 ::nape::geom::Vec3 Body_obj::get_constraintVelocity(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_755_get_constraintVelocity)
HXLINE( 756)		if (hx::IsNull( this->zpp_inner->wrapcvel )) {
HXLINE( 756)			this->zpp_inner->setup_cvel();
            		}
HXLINE( 757)		return this->zpp_inner->wrapcvel;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_constraintVelocity,return )

Float Body_obj::get_rotation(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_774_get_rotation)
HXDLIN( 774)		return this->zpp_inner->rot;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_rotation,return )

Float Body_obj::set_rotation(Float rotation){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_776_set_rotation)
HXLINE( 777)		{
HXLINE( 778)			this->zpp_inner->immutable_midstep(HX_("Body::rotation",40,9d,24,6b));
HXLINE( 780)			if (this->zpp_inner->world) {
HXLINE( 780)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 783)			bool _hx_tmp;
HXDLIN( 783)			if ((this->zpp_inner->type == 1)) {
HXLINE( 783)				_hx_tmp = hx::IsNotNull( this->zpp_inner->space );
            			}
            			else {
HXLINE( 783)				_hx_tmp = false;
            			}
HXDLIN( 783)			if (_hx_tmp) {
HXLINE( 783)				HX_STACK_DO_THROW(HX_("Error: Static objects cannot be rotated once inside a Space",1b,e2,01,c9));
            			}
HXLINE( 785)			if ((this->zpp_inner->rot != rotation)) {
HXLINE( 787)				if ((rotation != rotation)) {
HXLINE( 787)					HX_STACK_DO_THROW(HX_("Error: Body::rotation cannot be NaN",a9,a5,47,9c));
            				}
HXLINE( 789)				this->zpp_inner->rot = rotation;
HXLINE( 790)				{
HXLINE( 790)					 ::zpp_nape::phys::ZPP_Body _this = this->zpp_inner;
HXDLIN( 790)					_this->zip_axis = true;
HXDLIN( 790)					{
HXLINE( 790)						 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = _this->shapes->head;
HXDLIN( 790)						while(hx::IsNotNull( cx_ite )){
HXLINE( 790)							 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXDLIN( 790)							{
HXLINE( 790)								if ((s->type == 1)) {
HXLINE( 790)									s->polygon->invalidate_gverts();
HXDLIN( 790)									s->polygon->invalidate_gaxi();
            								}
HXDLIN( 790)								s->invalidate_worldCOM();
            							}
HXDLIN( 790)							cx_ite = cx_ite->next;
            						}
            					}
HXDLIN( 790)					_this->zip_worldCOM = true;
            				}
HXLINE( 791)				this->zpp_inner->wake();
            			}
            		}
HXLINE( 794)		return this->zpp_inner->rot;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_rotation,return )

Float Body_obj::get_angularVel(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_806_get_angularVel)
HXDLIN( 806)		return this->zpp_inner->angvel;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_angularVel,return )

Float Body_obj::set_angularVel(Float angularVel){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_808_set_angularVel)
HXLINE( 809)		{
HXLINE( 811)			if (this->zpp_inner->world) {
HXLINE( 811)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 813)			if ((this->zpp_inner->angvel != angularVel)) {
HXLINE( 815)				if ((angularVel != angularVel)) {
HXLINE( 815)					HX_STACK_DO_THROW(HX_("Error: Body::angularVel cannot be NaN",c6,69,71,8d));
            				}
HXLINE( 818)				if ((this->zpp_inner->type == 1)) {
HXLINE( 818)					HX_STACK_DO_THROW(HX_("Error: A static object cannot be given a velocity",3b,e0,bd,35));
            				}
HXLINE( 820)				this->zpp_inner->angvel = angularVel;
HXLINE( 821)				this->zpp_inner->wake();
            			}
            		}
HXLINE( 824)		return this->zpp_inner->angvel;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_angularVel,return )

Float Body_obj::get_kinAngVel(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_841_get_kinAngVel)
HXDLIN( 841)		return this->zpp_inner->kinangvel;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_kinAngVel,return )

Float Body_obj::set_kinAngVel(Float kinAngVel){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_843_set_kinAngVel)
HXLINE( 844)		{
HXLINE( 846)			if (this->zpp_inner->world) {
HXLINE( 846)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 848)			if ((this->zpp_inner->kinangvel != kinAngVel)) {
HXLINE( 850)				if ((kinAngVel != kinAngVel)) {
HXLINE( 850)					HX_STACK_DO_THROW(HX_("Error: Body::kinAngVel cannot be NaN",5e,e8,3f,15));
            				}
HXLINE( 852)				this->zpp_inner->kinangvel = kinAngVel;
HXLINE( 853)				this->zpp_inner->wake();
            			}
            		}
HXLINE( 856)		return this->zpp_inner->kinangvel;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_kinAngVel,return )

Float Body_obj::get_torque(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_870_get_torque)
HXDLIN( 870)		return this->zpp_inner->torque;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_torque,return )

Float Body_obj::set_torque(Float torque){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_872_set_torque)
HXLINE( 873)		{
HXLINE( 875)			if (this->zpp_inner->world) {
HXLINE( 875)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 878)			if ((this->zpp_inner->type != 2)) {
HXLINE( 878)				HX_STACK_DO_THROW(HX_("Error: Non-dynamic body cannot have torque applied.",1d,98,9c,52));
            			}
HXLINE( 881)			if ((torque != torque)) {
HXLINE( 881)				HX_STACK_DO_THROW(HX_("Error: Body::torque cannot be NaN",35,68,4e,79));
            			}
HXLINE( 883)			if ((this->zpp_inner->torque != torque)) {
HXLINE( 884)				this->zpp_inner->torque = torque;
HXLINE( 885)				this->zpp_inner->wake();
            			}
            		}
HXLINE( 888)		return this->zpp_inner->torque;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_torque,return )

 ::nape::geom::AABB Body_obj::get_bounds(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_901_get_bounds)
HXLINE( 903)		if (this->zpp_inner->world) {
HXLINE( 903)			HX_STACK_DO_THROW(HX_("Error: Space::world has no bounds",88,ea,f6,a3));
            		}
HXLINE( 905)		return this->zpp_inner->aabb->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_bounds,return )

bool Body_obj::get_allowMovement(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_919_get_allowMovement)
HXDLIN( 919)		return !(this->zpp_inner->nomove);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_allowMovement,return )

bool Body_obj::set_allowMovement(bool allowMovement){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_921_set_allowMovement)
HXLINE( 922)		{
HXLINE( 923)			 ::zpp_nape::phys::ZPP_Body _hx_tmp = this->zpp_inner;
HXDLIN( 923)			_hx_tmp->immutable_midstep((HX_("Body::",02,8e,7d,8f) + ::Std_obj::string(allowMovement)));
HXLINE( 924)			if ((!(this->zpp_inner->nomove) != allowMovement)) {
HXLINE( 925)				this->zpp_inner->nomove = !(allowMovement);
HXLINE( 926)				this->zpp_inner->invalidate_mass();
            			}
            		}
HXLINE( 929)		return !(this->zpp_inner->nomove);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_allowMovement,return )

bool Body_obj::get_allowRotation(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_943_get_allowRotation)
HXDLIN( 943)		return !(this->zpp_inner->norotate);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_allowRotation,return )

bool Body_obj::set_allowRotation(bool allowRotation){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_945_set_allowRotation)
HXLINE( 946)		{
HXLINE( 947)			 ::zpp_nape::phys::ZPP_Body _hx_tmp = this->zpp_inner;
HXDLIN( 947)			_hx_tmp->immutable_midstep((HX_("Body::",02,8e,7d,8f) + ::Std_obj::string(allowRotation)));
HXLINE( 948)			if ((!(this->zpp_inner->norotate) != allowRotation)) {
HXLINE( 949)				this->zpp_inner->norotate = !(allowRotation);
HXLINE( 950)				this->zpp_inner->invalidate_inertia();
            			}
            		}
HXLINE( 953)		return !(this->zpp_inner->norotate);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_allowRotation,return )

 ::nape::phys::MassMode Body_obj::get_massMode(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_967_get_massMode)
HXDLIN( 967)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT )) {
HXDLIN( 967)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 967)			::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT =  ::nape::phys::MassMode_obj::__alloc( HX_CTX );
HXDLIN( 967)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN( 967)		 ::nape::phys::MassMode _hx_tmp = ::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT;
HXDLIN( 967)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::MassMode_FIXED )) {
HXDLIN( 967)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 967)			::zpp_nape::util::ZPP_Flags_obj::MassMode_FIXED =  ::nape::phys::MassMode_obj::__alloc( HX_CTX );
HXDLIN( 967)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN( 967)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1,::zpp_nape::util::ZPP_Flags_obj::MassMode_FIXED)->__get(this->zpp_inner->massMode).StaticCast<  ::nape::phys::MassMode >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_massMode,return )

 ::nape::phys::MassMode Body_obj::set_massMode( ::nape::phys::MassMode massMode){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_969_set_massMode)
HXLINE( 970)		{
HXLINE( 971)			this->zpp_inner->immutable_midstep(HX_("Body::massMode",79,2a,14,e4));
HXLINE( 973)			if (this->zpp_inner->world) {
HXLINE( 973)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE( 976)			if (hx::IsNull( massMode )) {
HXLINE( 976)				HX_STACK_DO_THROW(HX_("Error: cannot use null massMode",88,73,80,de));
            			}
HXLINE( 978)			int _hx_tmp;
HXDLIN( 978)			if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT )) {
HXLINE( 978)				::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 978)				::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT =  ::nape::phys::MassMode_obj::__alloc( HX_CTX );
HXDLIN( 978)				::zpp_nape::util::ZPP_Flags_obj::internal = false;
            			}
HXDLIN( 978)			if (hx::IsEq( massMode,::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT )) {
HXLINE( 978)				_hx_tmp = 0;
            			}
            			else {
HXLINE( 978)				_hx_tmp = 1;
            			}
HXDLIN( 978)			this->zpp_inner->massMode = _hx_tmp;
HXLINE( 979)			this->zpp_inner->invalidate_mass();
            		}
HXLINE( 981)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT )) {
HXLINE( 981)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 981)			::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT =  ::nape::phys::MassMode_obj::__alloc( HX_CTX );
HXDLIN( 981)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN( 981)		 ::nape::phys::MassMode _hx_tmp1 = ::zpp_nape::util::ZPP_Flags_obj::MassMode_DEFAULT;
HXDLIN( 981)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::MassMode_FIXED )) {
HXLINE( 981)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN( 981)			::zpp_nape::util::ZPP_Flags_obj::MassMode_FIXED =  ::nape::phys::MassMode_obj::__alloc( HX_CTX );
HXDLIN( 981)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN( 981)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp1)->init(1,::zpp_nape::util::ZPP_Flags_obj::MassMode_FIXED)->__get(this->zpp_inner->massMode).StaticCast<  ::nape::phys::MassMode >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_massMode,return )

Float Body_obj::get_constraintMass(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_992_get_constraintMass)
HXLINE( 993)		if (!(this->zpp_inner->world)) {
HXLINE( 993)			this->zpp_inner->validate_mass();
            		}
HXLINE( 994)		return this->zpp_inner->smass;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_constraintMass,return )

Float Body_obj::get_mass(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1010_get_mass)
HXLINE(1012)		if (this->zpp_inner->world) {
HXLINE(1012)			HX_STACK_DO_THROW(HX_("Error: Space::world has no mass",47,6a,54,2b));
            		}
HXLINE(1014)		this->zpp_inner->validate_mass();
HXLINE(1016)		bool _hx_tmp;
HXDLIN(1016)		if ((this->zpp_inner->massMode == 0)) {
HXLINE(1016)			_hx_tmp = hx::IsNull( this->zpp_inner->shapes->head );
            		}
            		else {
HXLINE(1016)			_hx_tmp = false;
            		}
HXDLIN(1016)		if (_hx_tmp) {
HXLINE(1016)			HX_STACK_DO_THROW(HX_("Error: Given current mass mode, Body::mass only makes sense if it contains shapes",3f,ab,6b,cb));
            		}
HXLINE(1018)		return this->zpp_inner->cmass;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_mass,return )

Float Body_obj::set_mass(Float mass){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1020_set_mass)
HXLINE(1021)		{
HXLINE(1022)			this->zpp_inner->immutable_midstep(HX_("Body::mass",f6,f7,7f,e7));
HXLINE(1024)			if (this->zpp_inner->world) {
HXLINE(1024)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE(1027)			if ((mass != mass)) {
HXLINE(1027)				HX_STACK_DO_THROW(HX_("Error: Mass cannot be NaN",fd,f2,be,8f));
            			}
HXLINE(1028)			if ((mass <= 0)) {
HXLINE(1028)				HX_STACK_DO_THROW(HX_("Error: Mass must be strictly positive",9f,d2,ed,97));
            			}
HXLINE(1029)			if ((mass >= ::Math_obj::POSITIVE_INFINITY)) {
HXLINE(1029)				HX_STACK_DO_THROW(HX_("Error: Mass cannot be infinite, use allowMovement = false instead",1b,22,ab,35));
            			}
HXLINE(1031)			this->zpp_inner->massMode = 1;
HXLINE(1032)			this->zpp_inner->cmass = mass;
HXLINE(1033)			this->zpp_inner->invalidate_mass();
            		}
HXLINE(1035)		if (this->zpp_inner->world) {
HXLINE(1035)			HX_STACK_DO_THROW(HX_("Error: Space::world has no mass",47,6a,54,2b));
            		}
HXDLIN(1035)		this->zpp_inner->validate_mass();
HXDLIN(1035)		bool _hx_tmp;
HXDLIN(1035)		if ((this->zpp_inner->massMode == 0)) {
HXLINE(1035)			_hx_tmp = hx::IsNull( this->zpp_inner->shapes->head );
            		}
            		else {
HXLINE(1035)			_hx_tmp = false;
            		}
HXDLIN(1035)		if (_hx_tmp) {
HXLINE(1035)			HX_STACK_DO_THROW(HX_("Error: Given current mass mode, Body::mass only makes sense if it contains shapes",3f,ab,6b,cb));
            		}
HXDLIN(1035)		return this->zpp_inner->cmass;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_mass,return )

 ::nape::phys::GravMassMode Body_obj::get_gravMassMode(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1047_get_gravMassMode)
HXDLIN(1047)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT )) {
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1047)		 ::nape::phys::GravMassMode _hx_tmp = ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT;
HXDLIN(1047)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_FIXED )) {
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::GravMassMode_FIXED =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1047)		 ::nape::phys::GravMassMode _hx_tmp1 = ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_FIXED;
HXDLIN(1047)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED )) {
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1047)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1047)		return ::Array_obj< ::Dynamic>::__new(3)->init(0,_hx_tmp)->init(1,_hx_tmp1)->init(2,::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED)->__get(this->zpp_inner->massMode).StaticCast<  ::nape::phys::GravMassMode >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_gravMassMode,return )

 ::nape::phys::GravMassMode Body_obj::set_gravMassMode( ::nape::phys::GravMassMode gravMassMode){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1049_set_gravMassMode)
HXLINE(1050)		{
HXLINE(1051)			this->zpp_inner->immutable_midstep(HX_("Body::gravMassMode",79,bf,d1,f1));
HXLINE(1053)			if (this->zpp_inner->world) {
HXLINE(1053)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE(1056)			if (hx::IsNull( gravMassMode )) {
HXLINE(1056)				HX_STACK_DO_THROW(HX_("Error: Cannot use null gravMassMode",28,c8,7d,c2));
            			}
HXLINE(1058)			int _hx_tmp;
HXDLIN(1058)			if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED )) {
HXLINE(1058)				::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1058)				::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1058)				::zpp_nape::util::ZPP_Flags_obj::internal = false;
            			}
HXDLIN(1058)			if (hx::IsEq( gravMassMode,::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED )) {
HXLINE(1058)				_hx_tmp = 2;
            			}
            			else {
HXLINE(1058)				if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT )) {
HXLINE(1058)					::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1058)					::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1058)					::zpp_nape::util::ZPP_Flags_obj::internal = false;
            				}
HXDLIN(1058)				if (hx::IsEq( gravMassMode,::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT )) {
HXLINE(1058)					_hx_tmp = 0;
            				}
            				else {
HXLINE(1058)					_hx_tmp = 1;
            				}
            			}
HXDLIN(1058)			this->zpp_inner->gravMassMode = _hx_tmp;
HXLINE(1059)			this->zpp_inner->invalidate_gravMass();
            		}
HXLINE(1061)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT )) {
HXLINE(1061)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1061)			::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1061)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1061)		 ::nape::phys::GravMassMode _hx_tmp1 = ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_DEFAULT;
HXDLIN(1061)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_FIXED )) {
HXLINE(1061)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1061)			::zpp_nape::util::ZPP_Flags_obj::GravMassMode_FIXED =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1061)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1061)		 ::nape::phys::GravMassMode _hx_tmp2 = ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_FIXED;
HXDLIN(1061)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED )) {
HXLINE(1061)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1061)			::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED =  ::nape::phys::GravMassMode_obj::__alloc( HX_CTX );
HXDLIN(1061)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1061)		return ::Array_obj< ::Dynamic>::__new(3)->init(0,_hx_tmp1)->init(1,_hx_tmp2)->init(2,::zpp_nape::util::ZPP_Flags_obj::GravMassMode_SCALED)->__get(this->zpp_inner->massMode).StaticCast<  ::nape::phys::GravMassMode >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_gravMassMode,return )

Float Body_obj::get_gravMass(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1072_get_gravMass)
HXLINE(1074)		if (this->zpp_inner->world) {
HXLINE(1074)			HX_STACK_DO_THROW(HX_("Error: Space::world has no gravMass",c7,7b,f9,e6));
            		}
HXLINE(1076)		this->zpp_inner->validate_gravMass();
HXLINE(1078)		if (hx::IsNull( this->zpp_inner->shapes->head )) {
HXLINE(1079)			bool _hx_tmp;
HXDLIN(1079)			if ((this->zpp_inner->massMode == 0)) {
HXLINE(1079)				_hx_tmp = (this->zpp_inner->gravMassMode != 1);
            			}
            			else {
HXLINE(1079)				_hx_tmp = false;
            			}
HXDLIN(1079)			if (_hx_tmp) {
HXLINE(1079)				HX_STACK_DO_THROW(HX_("Error: Given current mass/gravMass modes; Body::gravMass only makes sense if it contains Shapes",be,98,a4,72));
            			}
            		}
HXLINE(1082)		return this->zpp_inner->gravMass;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_gravMass,return )

Float Body_obj::set_gravMass(Float gravMass){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1084_set_gravMass)
HXLINE(1085)		{
HXLINE(1086)			this->zpp_inner->immutable_midstep(HX_("Body::gravMass",f6,0c,8f,d7));
HXLINE(1088)			if (this->zpp_inner->world) {
HXLINE(1088)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE(1091)			if ((gravMass != gravMass)) {
HXLINE(1091)				HX_STACK_DO_THROW(HX_("Error: gravMass cannot be NaN",dd,39,2d,37));
            			}
HXLINE(1093)			this->zpp_inner->gravMassMode = 1;
HXLINE(1094)			this->zpp_inner->gravMass = gravMass;
HXLINE(1095)			this->zpp_inner->invalidate_gravMass();
            		}
HXLINE(1097)		if (this->zpp_inner->world) {
HXLINE(1097)			HX_STACK_DO_THROW(HX_("Error: Space::world has no gravMass",c7,7b,f9,e6));
            		}
HXDLIN(1097)		this->zpp_inner->validate_gravMass();
HXDLIN(1097)		if (hx::IsNull( this->zpp_inner->shapes->head )) {
HXLINE(1097)			bool _hx_tmp;
HXDLIN(1097)			if ((this->zpp_inner->massMode == 0)) {
HXLINE(1097)				_hx_tmp = (this->zpp_inner->gravMassMode != 1);
            			}
            			else {
HXLINE(1097)				_hx_tmp = false;
            			}
HXDLIN(1097)			if (_hx_tmp) {
HXLINE(1097)				HX_STACK_DO_THROW(HX_("Error: Given current mass/gravMass modes; Body::gravMass only makes sense if it contains Shapes",be,98,a4,72));
            			}
            		}
HXDLIN(1097)		return this->zpp_inner->gravMass;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_gravMass,return )

Float Body_obj::get_gravMassScale(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1109_get_gravMassScale)
HXLINE(1110)		this->zpp_inner->validate_gravMassScale();
HXLINE(1112)		if (hx::IsNull( this->zpp_inner->shapes->head )) {
HXLINE(1113)			bool _hx_tmp;
HXDLIN(1113)			if ((this->zpp_inner->massMode == 0)) {
HXLINE(1113)				_hx_tmp = (this->zpp_inner->gravMassMode != 2);
            			}
            			else {
HXLINE(1113)				_hx_tmp = false;
            			}
HXDLIN(1113)			if (_hx_tmp) {
HXLINE(1113)				HX_STACK_DO_THROW(HX_("Error: Given current mass/gravMass modes; Body::gravMassScale only makes sense if it contains Shapes",58,a2,3a,09));
            			}
            		}
HXLINE(1116)		return this->zpp_inner->gravMassScale;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_gravMassScale,return )

Float Body_obj::set_gravMassScale(Float gravMassScale){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1118_set_gravMassScale)
HXLINE(1119)		{
HXLINE(1120)			this->zpp_inner->immutable_midstep(HX_("Body::gravMassScale",b4,75,2c,12));
HXLINE(1122)			if (this->zpp_inner->world) {
HXLINE(1122)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE(1125)			if ((gravMassScale != gravMassScale)) {
HXLINE(1125)				HX_STACK_DO_THROW(HX_("Error: gravMassScale cannot be NaN",03,59,ed,9c));
            			}
HXLINE(1127)			this->zpp_inner->gravMassMode = 2;
HXLINE(1128)			this->zpp_inner->gravMassScale = gravMassScale;
HXLINE(1129)			this->zpp_inner->invalidate_gravMassScale();
            		}
HXLINE(1131)		this->zpp_inner->validate_gravMassScale();
HXDLIN(1131)		if (hx::IsNull( this->zpp_inner->shapes->head )) {
HXLINE(1131)			bool _hx_tmp;
HXDLIN(1131)			if ((this->zpp_inner->massMode == 0)) {
HXLINE(1131)				_hx_tmp = (this->zpp_inner->gravMassMode != 2);
            			}
            			else {
HXLINE(1131)				_hx_tmp = false;
            			}
HXDLIN(1131)			if (_hx_tmp) {
HXLINE(1131)				HX_STACK_DO_THROW(HX_("Error: Given current mass/gravMass modes; Body::gravMassScale only makes sense if it contains Shapes",58,a2,3a,09));
            			}
            		}
HXDLIN(1131)		return this->zpp_inner->gravMassScale;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_gravMassScale,return )

 ::nape::phys::InertiaMode Body_obj::get_inertiaMode(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1143_get_inertiaMode)
HXDLIN(1143)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_DEFAULT )) {
HXDLIN(1143)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1143)			::zpp_nape::util::ZPP_Flags_obj::InertiaMode_DEFAULT =  ::nape::phys::InertiaMode_obj::__alloc( HX_CTX );
HXDLIN(1143)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1143)		 ::nape::phys::InertiaMode _hx_tmp = ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_DEFAULT;
HXDLIN(1143)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED )) {
HXDLIN(1143)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1143)			::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED =  ::nape::phys::InertiaMode_obj::__alloc( HX_CTX );
HXDLIN(1143)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1143)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp)->init(1,::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED)->__get(this->zpp_inner->inertiaMode).StaticCast<  ::nape::phys::InertiaMode >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_inertiaMode,return )

 ::nape::phys::InertiaMode Body_obj::set_inertiaMode( ::nape::phys::InertiaMode inertiaMode){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1145_set_inertiaMode)
HXLINE(1146)		{
HXLINE(1147)			this->zpp_inner->immutable_midstep(HX_("Body::inertiaMode",bb,c2,29,17));
HXLINE(1149)			if (this->zpp_inner->world) {
HXLINE(1149)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE(1152)			if (hx::IsNull( inertiaMode )) {
HXLINE(1152)				HX_STACK_DO_THROW(HX_("Error: Cannot use null InertiaMode",cc,3c,56,e5));
            			}
HXLINE(1154)			int _hx_tmp;
HXDLIN(1154)			if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED )) {
HXLINE(1154)				::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1154)				::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED =  ::nape::phys::InertiaMode_obj::__alloc( HX_CTX );
HXDLIN(1154)				::zpp_nape::util::ZPP_Flags_obj::internal = false;
            			}
HXDLIN(1154)			if (hx::IsEq( inertiaMode,::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED )) {
HXLINE(1154)				_hx_tmp = 1;
            			}
            			else {
HXLINE(1154)				_hx_tmp = 0;
            			}
HXDLIN(1154)			this->zpp_inner->inertiaMode = _hx_tmp;
HXLINE(1155)			this->zpp_inner->invalidate_inertia();
            		}
HXLINE(1157)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_DEFAULT )) {
HXLINE(1157)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1157)			::zpp_nape::util::ZPP_Flags_obj::InertiaMode_DEFAULT =  ::nape::phys::InertiaMode_obj::__alloc( HX_CTX );
HXDLIN(1157)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1157)		 ::nape::phys::InertiaMode _hx_tmp1 = ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_DEFAULT;
HXDLIN(1157)		if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED )) {
HXLINE(1157)			::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1157)			::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED =  ::nape::phys::InertiaMode_obj::__alloc( HX_CTX );
HXDLIN(1157)			::zpp_nape::util::ZPP_Flags_obj::internal = false;
            		}
HXDLIN(1157)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp1)->init(1,::zpp_nape::util::ZPP_Flags_obj::InertiaMode_FIXED)->__get(this->zpp_inner->inertiaMode).StaticCast<  ::nape::phys::InertiaMode >();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_inertiaMode,return )

Float Body_obj::get_constraintInertia(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1168_get_constraintInertia)
HXLINE(1169)		if (!(this->zpp_inner->world)) {
HXLINE(1169)			this->zpp_inner->validate_inertia();
            		}
HXLINE(1170)		return this->zpp_inner->sinertia;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_constraintInertia,return )

Float Body_obj::get_inertia(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1179_get_inertia)
HXLINE(1181)		if (this->zpp_inner->world) {
HXLINE(1181)			HX_STACK_DO_THROW(HX_("Error: Space::world has no inertia",87,dd,18,5d));
            		}
HXLINE(1183)		this->zpp_inner->validate_inertia();
HXLINE(1185)		bool _hx_tmp;
HXDLIN(1185)		if ((this->zpp_inner->inertiaMode == 0)) {
HXLINE(1185)			 ::nape::shape::ShapeList _this = this->zpp_inner->wrap_shapes;
HXDLIN(1185)			_hx_tmp = hx::IsNull( _this->zpp_inner->inner->head );
            		}
            		else {
HXLINE(1185)			_hx_tmp = false;
            		}
HXDLIN(1185)		if (_hx_tmp) {
HXLINE(1185)			HX_STACK_DO_THROW(HX_("Error: Given current inertia mode flag, Body::inertia only makes sense if Body contains Shapes",3e,00,35,76));
            		}
HXLINE(1187)		return this->zpp_inner->cinertia;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_inertia,return )

Float Body_obj::set_inertia(Float inertia){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1189_set_inertia)
HXLINE(1190)		{
HXLINE(1191)			this->zpp_inner->immutable_midstep(HX_("Body::inertia",38,c7,8f,f4));
HXLINE(1193)			if (this->zpp_inner->world) {
HXLINE(1193)				HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            			}
HXLINE(1196)			if ((inertia != inertia)) {
HXLINE(1196)				HX_STACK_DO_THROW(HX_("Error: Inertia cannot be NaN",67,5a,0a,96));
            			}
HXLINE(1197)			if ((inertia <= 0)) {
HXLINE(1197)				HX_STACK_DO_THROW(HX_("Error: Inertia must be strictly positive",09,b1,eb,b6));
            			}
HXLINE(1198)			if ((inertia >= ::Math_obj::POSITIVE_INFINITY)) {
HXLINE(1198)				HX_STACK_DO_THROW(HX_("Error: Inertia cannot be infinite, use allowRotation = false instead",94,f1,e8,1c));
            			}
HXLINE(1200)			this->zpp_inner->inertiaMode = 1;
HXLINE(1201)			this->zpp_inner->cinertia = inertia;
HXLINE(1202)			this->zpp_inner->invalidate_inertia();
            		}
HXLINE(1204)		if (this->zpp_inner->world) {
HXLINE(1204)			HX_STACK_DO_THROW(HX_("Error: Space::world has no inertia",87,dd,18,5d));
            		}
HXDLIN(1204)		this->zpp_inner->validate_inertia();
HXDLIN(1204)		bool _hx_tmp;
HXDLIN(1204)		if ((this->zpp_inner->inertiaMode == 0)) {
HXLINE(1204)			 ::nape::shape::ShapeList _this = this->zpp_inner->wrap_shapes;
HXDLIN(1204)			_hx_tmp = hx::IsNull( _this->zpp_inner->inner->head );
            		}
            		else {
HXLINE(1204)			_hx_tmp = false;
            		}
HXDLIN(1204)		if (_hx_tmp) {
HXLINE(1204)			HX_STACK_DO_THROW(HX_("Error: Given current inertia mode flag, Body::inertia only makes sense if Body contains Shapes",3e,00,35,76));
            		}
HXDLIN(1204)		return this->zpp_inner->cinertia;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,set_inertia,return )

 ::nape::phys::BodyList Body_obj::connectedBodies(hx::Null< int >  __o_depth, ::nape::phys::BodyList output){
            		int depth = __o_depth.Default(-1);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1224_connectedBodies)
HXDLIN(1224)		return this->zpp_inner->connectedBodies(depth,output);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,connectedBodies,return )

 ::nape::phys::BodyList Body_obj::interactingBodies( ::nape::callbacks::InteractionType type,hx::Null< int >  __o_depth, ::nape::phys::BodyList output){
            		int depth = __o_depth.Default(-1);
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1241_interactingBodies)
HXLINE(1242)		int arbiter_type;
HXDLIN(1242)		if (hx::IsNull( type )) {
HXLINE(1242)			arbiter_type = ((::zpp_nape::dynamics::ZPP_Arbiter_obj::COL | ::zpp_nape::dynamics::ZPP_Arbiter_obj::SENSOR) | ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID);
            		}
            		else {
HXLINE(1245)			if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InteractionType_COLLISION )) {
HXLINE(1245)				::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1245)				::zpp_nape::util::ZPP_Flags_obj::InteractionType_COLLISION =  ::nape::callbacks::InteractionType_obj::__alloc( HX_CTX );
HXDLIN(1245)				::zpp_nape::util::ZPP_Flags_obj::internal = false;
            			}
HXDLIN(1245)			if (hx::IsEq( type,::zpp_nape::util::ZPP_Flags_obj::InteractionType_COLLISION )) {
HXLINE(1242)				arbiter_type = ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL;
            			}
            			else {
HXLINE(1245)				if (hx::IsNull( ::zpp_nape::util::ZPP_Flags_obj::InteractionType_SENSOR )) {
HXLINE(1245)					::zpp_nape::util::ZPP_Flags_obj::internal = true;
HXDLIN(1245)					::zpp_nape::util::ZPP_Flags_obj::InteractionType_SENSOR =  ::nape::callbacks::InteractionType_obj::__alloc( HX_CTX );
HXDLIN(1245)					::zpp_nape::util::ZPP_Flags_obj::internal = false;
            				}
HXDLIN(1245)				if (hx::IsEq( type,::zpp_nape::util::ZPP_Flags_obj::InteractionType_SENSOR )) {
HXLINE(1242)					arbiter_type = ::zpp_nape::dynamics::ZPP_Arbiter_obj::SENSOR;
            				}
            				else {
HXLINE(1242)					arbiter_type = ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID;
            				}
            			}
            		}
HXLINE(1246)		return this->zpp_inner->interactingBodies(arbiter_type,depth,output);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Body_obj,interactingBodies,return )

Float Body_obj::crushFactor(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1263_crushFactor)
HXLINE(1265)		 ::nape::space::Space _hx_tmp;
HXDLIN(1265)		if (hx::IsNull( this->zpp_inner->space )) {
HXLINE(1265)			_hx_tmp = null();
            		}
            		else {
HXLINE(1265)			_hx_tmp = this->zpp_inner->space->outer;
            		}
HXDLIN(1265)		if (hx::IsNull( _hx_tmp )) {
HXLINE(1265)			HX_STACK_DO_THROW(HX_("Error: Makes no sense to see how much an object not taking part in a simulation is being crushed",c7,5c,55,de));
            		}
HXLINE(1267)		Float msum = ((Float)0.0);
HXLINE(1268)		Float x = ( (Float)(0) );
HXDLIN(1268)		Float y = ( (Float)(0) );
HXDLIN(1268)		bool _hx_tmp1;
HXDLIN(1268)		if ((x == x)) {
HXLINE(1268)			_hx_tmp1 = (y != y);
            		}
            		else {
HXLINE(1268)			_hx_tmp1 = true;
            		}
HXDLIN(1268)		if (_hx_tmp1) {
HXLINE(1268)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN(1268)		 ::nape::geom::Vec2 ret;
HXDLIN(1268)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1268)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE(1268)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1268)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1268)			ret->zpp_pool = null();
HXDLIN(1268)			ret->zpp_disp = false;
HXDLIN(1268)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1268)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN(1268)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1268)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1268)			{
HXLINE(1268)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1268)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE(1268)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1268)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1268)					ret1->next = null();
            				}
HXDLIN(1268)				ret1->weak = false;
            			}
HXDLIN(1268)			ret1->_immutable = false;
HXDLIN(1268)			{
HXLINE(1268)				ret1->x = x;
HXDLIN(1268)				ret1->y = y;
            			}
HXDLIN(1268)			ret->zpp_inner = ret1;
HXDLIN(1268)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE(1268)			bool _hx_tmp2;
HXDLIN(1268)			if (hx::IsNotNull( ret )) {
HXLINE(1268)				_hx_tmp2 = ret->zpp_disp;
            			}
            			else {
HXLINE(1268)				_hx_tmp2 = false;
            			}
HXDLIN(1268)			if (_hx_tmp2) {
HXLINE(1268)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1268)			{
HXLINE(1268)				 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN(1268)				if (_this->_immutable) {
HXLINE(1268)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1268)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(1268)					_this->_isimmutable();
            				}
            			}
HXDLIN(1268)			bool _hx_tmp3;
HXDLIN(1268)			if ((x == x)) {
HXLINE(1268)				_hx_tmp3 = (y != y);
            			}
            			else {
HXLINE(1268)				_hx_tmp3 = true;
            			}
HXDLIN(1268)			if (_hx_tmp3) {
HXLINE(1268)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1268)			bool _hx_tmp4;
HXDLIN(1268)			bool _hx_tmp5;
HXDLIN(1268)			if (hx::IsNotNull( ret )) {
HXLINE(1268)				_hx_tmp5 = ret->zpp_disp;
            			}
            			else {
HXLINE(1268)				_hx_tmp5 = false;
            			}
HXDLIN(1268)			if (_hx_tmp5) {
HXLINE(1268)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1268)			{
HXLINE(1268)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN(1268)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1268)					_this1->_validate();
            				}
            			}
HXDLIN(1268)			if ((ret->zpp_inner->x == x)) {
HXLINE(1268)				bool _hx_tmp6;
HXDLIN(1268)				if (hx::IsNotNull( ret )) {
HXLINE(1268)					_hx_tmp6 = ret->zpp_disp;
            				}
            				else {
HXLINE(1268)					_hx_tmp6 = false;
            				}
HXDLIN(1268)				if (_hx_tmp6) {
HXLINE(1268)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1268)				{
HXLINE(1268)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN(1268)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1268)						_this2->_validate();
            					}
            				}
HXDLIN(1268)				_hx_tmp4 = (ret->zpp_inner->y == y);
            			}
            			else {
HXLINE(1268)				_hx_tmp4 = false;
            			}
HXDLIN(1268)			if (!(_hx_tmp4)) {
HXLINE(1268)				{
HXLINE(1268)					ret->zpp_inner->x = x;
HXDLIN(1268)					ret->zpp_inner->y = y;
            				}
HXDLIN(1268)				{
HXLINE(1268)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN(1268)					if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE(1268)						_this3->_invalidate(_this3);
            					}
            				}
            			}
            		}
HXDLIN(1268)		ret->zpp_inner->weak = false;
HXDLIN(1268)		 ::nape::geom::Vec2 jsum = ret;
HXLINE(1269)		{
HXLINE(1269)			if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(1269)				this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            			}
HXDLIN(1269)			 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(1269)			while(true){
HXLINE(1269)				_g->zpp_inner->zpp_inner->valmod();
HXDLIN(1269)				int length = _g->zpp_inner->zpp_gl();
HXDLIN(1269)				_g->zpp_critical = true;
HXDLIN(1269)				bool _hx_tmp7;
HXDLIN(1269)				if ((_g->zpp_i < length)) {
HXLINE(1269)					_hx_tmp7 = true;
            				}
            				else {
HXLINE(1269)					{
HXLINE(1269)						_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(1269)						::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(1269)						_g->zpp_inner = null();
            					}
HXDLIN(1269)					_hx_tmp7 = false;
            				}
HXDLIN(1269)				if (!(_hx_tmp7)) {
HXLINE(1269)					goto _hx_goto_66;
            				}
HXDLIN(1269)				_g->zpp_critical = false;
HXDLIN(1269)				 ::nape::dynamics::Arbiter arb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(1270)				 ::nape::geom::Vec3 imp3 = arb->totalImpulse(hx::ObjectPtr<OBJ_>(this),null());
HXLINE(1271)				 ::nape::geom::Vec2 imp = imp3->xy(null());
HXLINE(1272)				jsum->addeq(imp);
HXLINE(1273)				bool msum1;
HXDLIN(1273)				if (hx::IsNotNull( imp )) {
HXLINE(1273)					msum1 = imp->zpp_disp;
            				}
            				else {
HXLINE(1273)					msum1 = false;
            				}
HXDLIN(1273)				if (msum1) {
HXLINE(1273)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1273)				bool msum2;
HXDLIN(1273)				if (hx::IsNotNull( imp )) {
HXLINE(1273)					msum2 = imp->zpp_disp;
            				}
            				else {
HXLINE(1273)					msum2 = false;
            				}
HXDLIN(1273)				if (msum2) {
HXLINE(1273)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1273)				{
HXLINE(1273)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = imp->zpp_inner;
HXDLIN(1273)					if (hx::IsNotNull( _this4->_validate )) {
HXLINE(1273)						_this4->_validate();
            					}
            				}
HXDLIN(1273)				Float msum3 = imp->zpp_inner->x;
HXDLIN(1273)				bool msum4;
HXDLIN(1273)				if (hx::IsNotNull( imp )) {
HXLINE(1273)					msum4 = imp->zpp_disp;
            				}
            				else {
HXLINE(1273)					msum4 = false;
            				}
HXDLIN(1273)				if (msum4) {
HXLINE(1273)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1273)				{
HXLINE(1273)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = imp->zpp_inner;
HXDLIN(1273)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE(1273)						_this5->_validate();
            					}
            				}
HXDLIN(1273)				Float msum5 = (msum3 * imp->zpp_inner->x);
HXDLIN(1273)				bool msum6;
HXDLIN(1273)				if (hx::IsNotNull( imp )) {
HXLINE(1273)					msum6 = imp->zpp_disp;
            				}
            				else {
HXLINE(1273)					msum6 = false;
            				}
HXDLIN(1273)				if (msum6) {
HXLINE(1273)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1273)				{
HXLINE(1273)					 ::zpp_nape::geom::ZPP_Vec2 _this6 = imp->zpp_inner;
HXDLIN(1273)					if (hx::IsNotNull( _this6->_validate )) {
HXLINE(1273)						_this6->_validate();
            					}
            				}
HXDLIN(1273)				Float msum7 = imp->zpp_inner->y;
HXDLIN(1273)				bool msum8;
HXDLIN(1273)				if (hx::IsNotNull( imp )) {
HXLINE(1273)					msum8 = imp->zpp_disp;
            				}
            				else {
HXLINE(1273)					msum8 = false;
            				}
HXDLIN(1273)				if (msum8) {
HXLINE(1273)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1273)				{
HXLINE(1273)					 ::zpp_nape::geom::ZPP_Vec2 _this7 = imp->zpp_inner;
HXDLIN(1273)					if (hx::IsNotNull( _this7->_validate )) {
HXLINE(1273)						_this7->_validate();
            					}
            				}
HXDLIN(1273)				msum = (msum + ::Math_obj::sqrt((msum5 + (msum7 * imp->zpp_inner->y))));
HXLINE(1274)				{
HXLINE(1274)					bool _hx_tmp8;
HXDLIN(1274)					if (hx::IsNotNull( imp )) {
HXLINE(1274)						_hx_tmp8 = imp->zpp_disp;
            					}
            					else {
HXLINE(1274)						_hx_tmp8 = false;
            					}
HXDLIN(1274)					if (_hx_tmp8) {
HXLINE(1274)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1274)					{
HXLINE(1274)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = imp->zpp_inner;
HXDLIN(1274)						if (_this8->_immutable) {
HXLINE(1274)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN(1274)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE(1274)							_this8->_isimmutable();
            						}
            					}
HXDLIN(1274)					if (imp->zpp_inner->_inuse) {
HXLINE(1274)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN(1274)					 ::zpp_nape::geom::ZPP_Vec2 inner = imp->zpp_inner;
HXDLIN(1274)					imp->zpp_inner->outer = null();
HXDLIN(1274)					imp->zpp_inner = null();
HXDLIN(1274)					{
HXLINE(1274)						 ::nape::geom::Vec2 o = imp;
HXDLIN(1274)						o->zpp_pool = null();
HXDLIN(1274)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1274)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE(1274)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN(1274)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1274)						o->zpp_disp = true;
            					}
HXDLIN(1274)					{
HXLINE(1274)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1274)						{
HXLINE(1274)							if (hx::IsNotNull( o1->outer )) {
HXLINE(1274)								o1->outer->zpp_inner = null();
HXDLIN(1274)								o1->outer = null();
            							}
HXDLIN(1274)							o1->_isimmutable = null();
HXDLIN(1274)							o1->_validate = null();
HXDLIN(1274)							o1->_invalidate = null();
            						}
HXDLIN(1274)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1274)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
HXLINE(1275)				imp3->dispose();
            			}
            			_hx_goto_66:;
            		}
HXLINE(1277)		{
HXLINE(1277)			if (hx::IsNull( this->zpp_inner->wrap_constraints )) {
HXLINE(1277)				this->zpp_inner->wrap_constraints = ::zpp_nape::util::ZPP_ConstraintList_obj::get(this->zpp_inner->constraints,true);
            			}
HXDLIN(1277)			 ::nape::constraint::ConstraintList _this9 = this->zpp_inner->wrap_constraints;
HXDLIN(1277)			_this9->zpp_inner->valmod();
HXDLIN(1277)			 ::nape::constraint::ConstraintIterator _g1 = ::nape::constraint::ConstraintIterator_obj::get(_this9);
HXDLIN(1277)			while(true){
HXLINE(1277)				_g1->zpp_inner->zpp_inner->valmod();
HXDLIN(1277)				 ::nape::constraint::ConstraintList _this10 = _g1->zpp_inner;
HXDLIN(1277)				_this10->zpp_inner->valmod();
HXDLIN(1277)				if (_this10->zpp_inner->zip_length) {
HXLINE(1277)					_this10->zpp_inner->zip_length = false;
HXDLIN(1277)					_this10->zpp_inner->user_length = _this10->zpp_inner->inner->length;
            				}
HXDLIN(1277)				int length1 = _this10->zpp_inner->user_length;
HXDLIN(1277)				_g1->zpp_critical = true;
HXDLIN(1277)				bool _hx_tmp9;
HXDLIN(1277)				if ((_g1->zpp_i < length1)) {
HXLINE(1277)					_hx_tmp9 = true;
            				}
            				else {
HXLINE(1277)					{
HXLINE(1277)						_g1->zpp_next = ::nape::constraint::ConstraintIterator_obj::zpp_pool;
HXDLIN(1277)						::nape::constraint::ConstraintIterator_obj::zpp_pool = _g1;
HXDLIN(1277)						_g1->zpp_inner = null();
            					}
HXDLIN(1277)					_hx_tmp9 = false;
            				}
HXDLIN(1277)				if (!(_hx_tmp9)) {
HXLINE(1277)					goto _hx_goto_67;
            				}
HXDLIN(1277)				_g1->zpp_critical = false;
HXDLIN(1277)				 ::nape::constraint::Constraint con = _g1->zpp_inner->at(_g1->zpp_i++);
HXLINE(1278)				 ::nape::geom::Vec3 imp31 = con->bodyImpulse(hx::ObjectPtr<OBJ_>(this));
HXLINE(1279)				 ::nape::geom::Vec2 imp1 = imp31->xy(null());
HXLINE(1280)				jsum->addeq(imp1);
HXLINE(1281)				bool msum9;
HXDLIN(1281)				if (hx::IsNotNull( imp1 )) {
HXLINE(1281)					msum9 = imp1->zpp_disp;
            				}
            				else {
HXLINE(1281)					msum9 = false;
            				}
HXDLIN(1281)				if (msum9) {
HXLINE(1281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1281)				bool msum10;
HXDLIN(1281)				if (hx::IsNotNull( imp1 )) {
HXLINE(1281)					msum10 = imp1->zpp_disp;
            				}
            				else {
HXLINE(1281)					msum10 = false;
            				}
HXDLIN(1281)				if (msum10) {
HXLINE(1281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1281)				{
HXLINE(1281)					 ::zpp_nape::geom::ZPP_Vec2 _this11 = imp1->zpp_inner;
HXDLIN(1281)					if (hx::IsNotNull( _this11->_validate )) {
HXLINE(1281)						_this11->_validate();
            					}
            				}
HXDLIN(1281)				Float msum11 = imp1->zpp_inner->x;
HXDLIN(1281)				bool msum12;
HXDLIN(1281)				if (hx::IsNotNull( imp1 )) {
HXLINE(1281)					msum12 = imp1->zpp_disp;
            				}
            				else {
HXLINE(1281)					msum12 = false;
            				}
HXDLIN(1281)				if (msum12) {
HXLINE(1281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1281)				{
HXLINE(1281)					 ::zpp_nape::geom::ZPP_Vec2 _this12 = imp1->zpp_inner;
HXDLIN(1281)					if (hx::IsNotNull( _this12->_validate )) {
HXLINE(1281)						_this12->_validate();
            					}
            				}
HXDLIN(1281)				Float msum13 = (msum11 * imp1->zpp_inner->x);
HXDLIN(1281)				bool msum14;
HXDLIN(1281)				if (hx::IsNotNull( imp1 )) {
HXLINE(1281)					msum14 = imp1->zpp_disp;
            				}
            				else {
HXLINE(1281)					msum14 = false;
            				}
HXDLIN(1281)				if (msum14) {
HXLINE(1281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1281)				{
HXLINE(1281)					 ::zpp_nape::geom::ZPP_Vec2 _this13 = imp1->zpp_inner;
HXDLIN(1281)					if (hx::IsNotNull( _this13->_validate )) {
HXLINE(1281)						_this13->_validate();
            					}
            				}
HXDLIN(1281)				Float msum15 = imp1->zpp_inner->y;
HXDLIN(1281)				bool msum16;
HXDLIN(1281)				if (hx::IsNotNull( imp1 )) {
HXLINE(1281)					msum16 = imp1->zpp_disp;
            				}
            				else {
HXLINE(1281)					msum16 = false;
            				}
HXDLIN(1281)				if (msum16) {
HXLINE(1281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1281)				{
HXLINE(1281)					 ::zpp_nape::geom::ZPP_Vec2 _this14 = imp1->zpp_inner;
HXDLIN(1281)					if (hx::IsNotNull( _this14->_validate )) {
HXLINE(1281)						_this14->_validate();
            					}
            				}
HXDLIN(1281)				msum = (msum + ::Math_obj::sqrt((msum13 + (msum15 * imp1->zpp_inner->y))));
HXLINE(1282)				{
HXLINE(1282)					bool _hx_tmp10;
HXDLIN(1282)					if (hx::IsNotNull( imp1 )) {
HXLINE(1282)						_hx_tmp10 = imp1->zpp_disp;
            					}
            					else {
HXLINE(1282)						_hx_tmp10 = false;
            					}
HXDLIN(1282)					if (_hx_tmp10) {
HXLINE(1282)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1282)					{
HXLINE(1282)						 ::zpp_nape::geom::ZPP_Vec2 _this15 = imp1->zpp_inner;
HXDLIN(1282)						if (_this15->_immutable) {
HXLINE(1282)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN(1282)						if (hx::IsNotNull( _this15->_isimmutable )) {
HXLINE(1282)							_this15->_isimmutable();
            						}
            					}
HXDLIN(1282)					if (imp1->zpp_inner->_inuse) {
HXLINE(1282)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN(1282)					 ::zpp_nape::geom::ZPP_Vec2 inner1 = imp1->zpp_inner;
HXDLIN(1282)					imp1->zpp_inner->outer = null();
HXDLIN(1282)					imp1->zpp_inner = null();
HXDLIN(1282)					{
HXLINE(1282)						 ::nape::geom::Vec2 o2 = imp1;
HXDLIN(1282)						o2->zpp_pool = null();
HXDLIN(1282)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1282)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            						}
            						else {
HXLINE(1282)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            						}
HXDLIN(1282)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN(1282)						o2->zpp_disp = true;
            					}
HXDLIN(1282)					{
HXLINE(1282)						 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN(1282)						{
HXLINE(1282)							if (hx::IsNotNull( o3->outer )) {
HXLINE(1282)								o3->outer->zpp_inner = null();
HXDLIN(1282)								o3->outer = null();
            							}
HXDLIN(1282)							o3->_isimmutable = null();
HXDLIN(1282)							o3->_validate = null();
HXDLIN(1282)							o3->_invalidate = null();
            						}
HXDLIN(1282)						o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1282)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            					}
            				}
HXLINE(1283)				imp31->dispose();
            			}
            			_hx_goto_67:;
            		}
HXLINE(1285)		bool ret2;
HXDLIN(1285)		if (hx::IsNotNull( jsum )) {
HXLINE(1285)			ret2 = jsum->zpp_disp;
            		}
            		else {
HXLINE(1285)			ret2 = false;
            		}
HXDLIN(1285)		if (ret2) {
HXLINE(1285)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(1285)		bool ret3;
HXDLIN(1285)		if (hx::IsNotNull( jsum )) {
HXLINE(1285)			ret3 = jsum->zpp_disp;
            		}
            		else {
HXLINE(1285)			ret3 = false;
            		}
HXDLIN(1285)		if (ret3) {
HXLINE(1285)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(1285)		{
HXLINE(1285)			 ::zpp_nape::geom::ZPP_Vec2 _this16 = jsum->zpp_inner;
HXDLIN(1285)			if (hx::IsNotNull( _this16->_validate )) {
HXLINE(1285)				_this16->_validate();
            			}
            		}
HXDLIN(1285)		Float ret4 = jsum->zpp_inner->x;
HXDLIN(1285)		bool ret5;
HXDLIN(1285)		if (hx::IsNotNull( jsum )) {
HXLINE(1285)			ret5 = jsum->zpp_disp;
            		}
            		else {
HXLINE(1285)			ret5 = false;
            		}
HXDLIN(1285)		if (ret5) {
HXLINE(1285)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(1285)		{
HXLINE(1285)			 ::zpp_nape::geom::ZPP_Vec2 _this17 = jsum->zpp_inner;
HXDLIN(1285)			if (hx::IsNotNull( _this17->_validate )) {
HXLINE(1285)				_this17->_validate();
            			}
            		}
HXDLIN(1285)		Float ret6 = (ret4 * jsum->zpp_inner->x);
HXDLIN(1285)		bool ret7;
HXDLIN(1285)		if (hx::IsNotNull( jsum )) {
HXLINE(1285)			ret7 = jsum->zpp_disp;
            		}
            		else {
HXLINE(1285)			ret7 = false;
            		}
HXDLIN(1285)		if (ret7) {
HXLINE(1285)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(1285)		{
HXLINE(1285)			 ::zpp_nape::geom::ZPP_Vec2 _this18 = jsum->zpp_inner;
HXDLIN(1285)			if (hx::IsNotNull( _this18->_validate )) {
HXLINE(1285)				_this18->_validate();
            			}
            		}
HXDLIN(1285)		Float ret8 = jsum->zpp_inner->y;
HXDLIN(1285)		bool ret9;
HXDLIN(1285)		if (hx::IsNotNull( jsum )) {
HXLINE(1285)			ret9 = jsum->zpp_disp;
            		}
            		else {
HXLINE(1285)			ret9 = false;
            		}
HXDLIN(1285)		if (ret9) {
HXLINE(1285)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(1285)		{
HXLINE(1285)			 ::zpp_nape::geom::ZPP_Vec2 _this19 = jsum->zpp_inner;
HXDLIN(1285)			if (hx::IsNotNull( _this19->_validate )) {
HXLINE(1285)				_this19->_validate();
            			}
            		}
HXDLIN(1285)		Float ret10 = (msum - ::Math_obj::sqrt((ret6 + (ret8 * jsum->zpp_inner->y))));
HXDLIN(1285)		if (this->zpp_inner->world) {
HXLINE(1285)			HX_STACK_DO_THROW(HX_("Error: Space::world has no mass",47,6a,54,2b));
            		}
HXDLIN(1285)		this->zpp_inner->validate_mass();
HXDLIN(1285)		bool ret11;
HXDLIN(1285)		if ((this->zpp_inner->massMode == 0)) {
HXLINE(1285)			ret11 = hx::IsNull( this->zpp_inner->shapes->head );
            		}
            		else {
HXLINE(1285)			ret11 = false;
            		}
HXDLIN(1285)		if (ret11) {
HXLINE(1285)			HX_STACK_DO_THROW(HX_("Error: Given current mass mode, Body::mass only makes sense if it contains shapes",3f,ab,6b,cb));
            		}
HXDLIN(1285)		 ::nape::space::Space ret12;
HXDLIN(1285)		if (hx::IsNull( this->zpp_inner->space )) {
HXLINE(1285)			ret12 = null();
            		}
            		else {
HXLINE(1285)			ret12 = this->zpp_inner->space->outer;
            		}
HXDLIN(1285)		Float ret13 = (ret10 / (this->zpp_inner->cmass * ret12->zpp_inner->pre_dt));
HXLINE(1286)		{
HXLINE(1286)			bool _hx_tmp11;
HXDLIN(1286)			if (hx::IsNotNull( jsum )) {
HXLINE(1286)				_hx_tmp11 = jsum->zpp_disp;
            			}
            			else {
HXLINE(1286)				_hx_tmp11 = false;
            			}
HXDLIN(1286)			if (_hx_tmp11) {
HXLINE(1286)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1286)			{
HXLINE(1286)				 ::zpp_nape::geom::ZPP_Vec2 _this20 = jsum->zpp_inner;
HXDLIN(1286)				if (_this20->_immutable) {
HXLINE(1286)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1286)				if (hx::IsNotNull( _this20->_isimmutable )) {
HXLINE(1286)					_this20->_isimmutable();
            				}
            			}
HXDLIN(1286)			if (jsum->zpp_inner->_inuse) {
HXLINE(1286)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1286)			 ::zpp_nape::geom::ZPP_Vec2 inner2 = jsum->zpp_inner;
HXDLIN(1286)			jsum->zpp_inner->outer = null();
HXDLIN(1286)			jsum->zpp_inner = null();
HXDLIN(1286)			{
HXLINE(1286)				 ::nape::geom::Vec2 o4 = jsum;
HXDLIN(1286)				o4->zpp_pool = null();
HXDLIN(1286)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1286)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o4;
            				}
            				else {
HXLINE(1286)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o4;
            				}
HXDLIN(1286)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o4;
HXDLIN(1286)				o4->zpp_disp = true;
            			}
HXDLIN(1286)			{
HXLINE(1286)				 ::zpp_nape::geom::ZPP_Vec2 o5 = inner2;
HXDLIN(1286)				{
HXLINE(1286)					if (hx::IsNotNull( o5->outer )) {
HXLINE(1286)						o5->outer->zpp_inner = null();
HXDLIN(1286)						o5->outer = null();
            					}
HXDLIN(1286)					o5->_isimmutable = null();
HXDLIN(1286)					o5->_validate = null();
HXDLIN(1286)					o5->_invalidate = null();
            				}
HXDLIN(1286)				o5->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1286)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o5;
            			}
            		}
HXLINE(1287)		return ret13;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,crushFactor,return )

 ::nape::geom::Vec2 Body_obj::localPointToWorld( ::nape::geom::Vec2 point,hx::Null< bool >  __o_weak){
            		bool weak = __o_weak.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1300_localPointToWorld)
HXLINE(1303)		bool _hx_tmp;
HXDLIN(1303)		if (hx::IsNotNull( point )) {
HXLINE(1303)			_hx_tmp = point->zpp_disp;
            		}
            		else {
HXLINE(1303)			_hx_tmp = false;
            		}
HXDLIN(1303)		if (_hx_tmp) {
HXLINE(1303)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1307)		if (hx::IsNull( point )) {
HXLINE(1307)			HX_STACK_DO_THROW(HX_("Error: Cannot transform null Vec2",54,10,c3,67));
            		}
HXLINE(1309)		{
HXLINE(1309)			 ::zpp_nape::phys::ZPP_Body _this = this->zpp_inner;
HXDLIN(1309)			if (_this->zip_axis) {
HXLINE(1309)				_this->zip_axis = false;
HXDLIN(1309)				{
HXLINE(1309)					_this->axisx = ::Math_obj::sin(_this->rot);
HXDLIN(1309)					_this->axisy = ::Math_obj::cos(_this->rot);
            				}
            			}
            		}
HXLINE(1310)		Float tempx = ((Float)0.0);
HXLINE(1311)		Float tempy = ((Float)0.0);
HXLINE(1312)		{
HXLINE(1313)			Float tempx1 = this->zpp_inner->axisy;
HXDLIN(1313)			bool tempx2;
HXDLIN(1313)			if (hx::IsNotNull( point )) {
HXLINE(1313)				tempx2 = point->zpp_disp;
            			}
            			else {
HXLINE(1313)				tempx2 = false;
            			}
HXDLIN(1313)			if (tempx2) {
HXLINE(1313)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1313)			{
HXLINE(1313)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = point->zpp_inner;
HXDLIN(1313)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1313)					_this1->_validate();
            				}
            			}
HXDLIN(1313)			Float tempx3 = (tempx1 * point->zpp_inner->x);
HXDLIN(1313)			Float tempx4 = this->zpp_inner->axisx;
HXDLIN(1313)			bool tempx5;
HXDLIN(1313)			if (hx::IsNotNull( point )) {
HXLINE(1313)				tempx5 = point->zpp_disp;
            			}
            			else {
HXLINE(1313)				tempx5 = false;
            			}
HXDLIN(1313)			if (tempx5) {
HXLINE(1313)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1313)			{
HXLINE(1313)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = point->zpp_inner;
HXDLIN(1313)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1313)					_this2->_validate();
            				}
            			}
HXDLIN(1313)			tempx = (tempx3 - (tempx4 * point->zpp_inner->y));
HXLINE(1314)			bool tempy1;
HXDLIN(1314)			if (hx::IsNotNull( point )) {
HXLINE(1314)				tempy1 = point->zpp_disp;
            			}
            			else {
HXLINE(1314)				tempy1 = false;
            			}
HXDLIN(1314)			if (tempy1) {
HXLINE(1314)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1314)			{
HXLINE(1314)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = point->zpp_inner;
HXDLIN(1314)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE(1314)					_this3->_validate();
            				}
            			}
HXDLIN(1314)			Float tempy2 = (point->zpp_inner->x * this->zpp_inner->axisx);
HXDLIN(1314)			bool tempy3;
HXDLIN(1314)			if (hx::IsNotNull( point )) {
HXLINE(1314)				tempy3 = point->zpp_disp;
            			}
            			else {
HXLINE(1314)				tempy3 = false;
            			}
HXDLIN(1314)			if (tempy3) {
HXLINE(1314)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1314)			{
HXLINE(1314)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = point->zpp_inner;
HXDLIN(1314)				if (hx::IsNotNull( _this4->_validate )) {
HXLINE(1314)					_this4->_validate();
            				}
            			}
HXDLIN(1314)			tempy = (tempy2 + (point->zpp_inner->y * this->zpp_inner->axisy));
            		}
HXLINE(1316)		if (point->zpp_inner->weak) {
HXLINE(1320)			bool _hx_tmp1;
HXDLIN(1320)			if (hx::IsNotNull( point )) {
HXLINE(1320)				_hx_tmp1 = point->zpp_disp;
            			}
            			else {
HXLINE(1320)				_hx_tmp1 = false;
            			}
HXDLIN(1320)			if (_hx_tmp1) {
HXLINE(1320)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1320)			{
HXLINE(1320)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = point->zpp_inner;
HXDLIN(1320)				if (_this5->_immutable) {
HXLINE(1320)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1320)				if (hx::IsNotNull( _this5->_isimmutable )) {
HXLINE(1320)					_this5->_isimmutable();
            				}
            			}
HXDLIN(1320)			if (point->zpp_inner->_inuse) {
HXLINE(1320)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1320)			 ::zpp_nape::geom::ZPP_Vec2 inner = point->zpp_inner;
HXDLIN(1320)			point->zpp_inner->outer = null();
HXDLIN(1320)			point->zpp_inner = null();
HXDLIN(1320)			{
HXLINE(1320)				 ::nape::geom::Vec2 o = point;
HXDLIN(1320)				o->zpp_pool = null();
HXDLIN(1320)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1320)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(1320)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(1320)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1320)				o->zpp_disp = true;
            			}
HXDLIN(1320)			{
HXLINE(1320)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1320)				{
HXLINE(1320)					if (hx::IsNotNull( o1->outer )) {
HXLINE(1320)						o1->outer->zpp_inner = null();
HXDLIN(1320)						o1->outer = null();
            					}
HXDLIN(1320)					o1->_isimmutable = null();
HXDLIN(1320)					o1->_validate = null();
HXDLIN(1320)					o1->_invalidate = null();
            				}
HXDLIN(1320)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1320)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(1327)		Float x = (tempx + this->zpp_inner->posx);
HXDLIN(1327)		Float y = (tempy + this->zpp_inner->posy);
HXDLIN(1327)		bool _hx_tmp2;
HXDLIN(1327)		if ((x == x)) {
HXLINE(1327)			_hx_tmp2 = (y != y);
            		}
            		else {
HXLINE(1327)			_hx_tmp2 = true;
            		}
HXDLIN(1327)		if (_hx_tmp2) {
HXLINE(1327)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN(1327)		 ::nape::geom::Vec2 ret;
HXDLIN(1327)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1327)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE(1327)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1327)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1327)			ret->zpp_pool = null();
HXDLIN(1327)			ret->zpp_disp = false;
HXDLIN(1327)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1327)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN(1327)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1327)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1327)			{
HXLINE(1327)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1327)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE(1327)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1327)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1327)					ret1->next = null();
            				}
HXDLIN(1327)				ret1->weak = false;
            			}
HXDLIN(1327)			ret1->_immutable = false;
HXDLIN(1327)			{
HXLINE(1327)				ret1->x = x;
HXDLIN(1327)				ret1->y = y;
            			}
HXDLIN(1327)			ret->zpp_inner = ret1;
HXDLIN(1327)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE(1327)			bool _hx_tmp3;
HXDLIN(1327)			if (hx::IsNotNull( ret )) {
HXLINE(1327)				_hx_tmp3 = ret->zpp_disp;
            			}
            			else {
HXLINE(1327)				_hx_tmp3 = false;
            			}
HXDLIN(1327)			if (_hx_tmp3) {
HXLINE(1327)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1327)			{
HXLINE(1327)				 ::zpp_nape::geom::ZPP_Vec2 _this6 = ret->zpp_inner;
HXDLIN(1327)				if (_this6->_immutable) {
HXLINE(1327)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1327)				if (hx::IsNotNull( _this6->_isimmutable )) {
HXLINE(1327)					_this6->_isimmutable();
            				}
            			}
HXDLIN(1327)			bool _hx_tmp4;
HXDLIN(1327)			if ((x == x)) {
HXLINE(1327)				_hx_tmp4 = (y != y);
            			}
            			else {
HXLINE(1327)				_hx_tmp4 = true;
            			}
HXDLIN(1327)			if (_hx_tmp4) {
HXLINE(1327)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1327)			bool _hx_tmp5;
HXDLIN(1327)			bool _hx_tmp6;
HXDLIN(1327)			if (hx::IsNotNull( ret )) {
HXLINE(1327)				_hx_tmp6 = ret->zpp_disp;
            			}
            			else {
HXLINE(1327)				_hx_tmp6 = false;
            			}
HXDLIN(1327)			if (_hx_tmp6) {
HXLINE(1327)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1327)			{
HXLINE(1327)				 ::zpp_nape::geom::ZPP_Vec2 _this7 = ret->zpp_inner;
HXDLIN(1327)				if (hx::IsNotNull( _this7->_validate )) {
HXLINE(1327)					_this7->_validate();
            				}
            			}
HXDLIN(1327)			if ((ret->zpp_inner->x == x)) {
HXLINE(1327)				bool _hx_tmp7;
HXDLIN(1327)				if (hx::IsNotNull( ret )) {
HXLINE(1327)					_hx_tmp7 = ret->zpp_disp;
            				}
            				else {
HXLINE(1327)					_hx_tmp7 = false;
            				}
HXDLIN(1327)				if (_hx_tmp7) {
HXLINE(1327)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1327)				{
HXLINE(1327)					 ::zpp_nape::geom::ZPP_Vec2 _this8 = ret->zpp_inner;
HXDLIN(1327)					if (hx::IsNotNull( _this8->_validate )) {
HXLINE(1327)						_this8->_validate();
            					}
            				}
HXDLIN(1327)				_hx_tmp5 = (ret->zpp_inner->y == y);
            			}
            			else {
HXLINE(1327)				_hx_tmp5 = false;
            			}
HXDLIN(1327)			if (!(_hx_tmp5)) {
HXLINE(1327)				{
HXLINE(1327)					ret->zpp_inner->x = x;
HXDLIN(1327)					ret->zpp_inner->y = y;
            				}
HXDLIN(1327)				{
HXLINE(1327)					 ::zpp_nape::geom::ZPP_Vec2 _this9 = ret->zpp_inner;
HXDLIN(1327)					if (hx::IsNotNull( _this9->_invalidate )) {
HXLINE(1327)						_this9->_invalidate(_this9);
            					}
            				}
            			}
            		}
HXDLIN(1327)		ret->zpp_inner->weak = weak;
HXDLIN(1327)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,localPointToWorld,return )

 ::nape::geom::Vec2 Body_obj::worldPointToLocal( ::nape::geom::Vec2 point,hx::Null< bool >  __o_weak){
            		bool weak = __o_weak.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1340_worldPointToLocal)
HXLINE(1343)		bool _hx_tmp;
HXDLIN(1343)		if (hx::IsNotNull( point )) {
HXLINE(1343)			_hx_tmp = point->zpp_disp;
            		}
            		else {
HXLINE(1343)			_hx_tmp = false;
            		}
HXDLIN(1343)		if (_hx_tmp) {
HXLINE(1343)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1347)		if (hx::IsNull( point )) {
HXLINE(1347)			HX_STACK_DO_THROW(HX_("Error: Cannot transform null Vec2",54,10,c3,67));
            		}
HXLINE(1349)		{
HXLINE(1349)			 ::zpp_nape::phys::ZPP_Body _this = this->zpp_inner;
HXDLIN(1349)			if (_this->zip_axis) {
HXLINE(1349)				_this->zip_axis = false;
HXDLIN(1349)				{
HXLINE(1349)					_this->axisx = ::Math_obj::sin(_this->rot);
HXDLIN(1349)					_this->axisy = ::Math_obj::cos(_this->rot);
            				}
            			}
            		}
HXLINE(1350)		Float tempx = ((Float)0.0);
HXLINE(1351)		Float tempy = ((Float)0.0);
HXLINE(1352)		Float pointx = ((Float)0.0);
HXLINE(1353)		Float pointy = ((Float)0.0);
HXLINE(1354)		{
HXLINE(1355)			bool pointx1;
HXDLIN(1355)			if (hx::IsNotNull( point )) {
HXLINE(1355)				pointx1 = point->zpp_disp;
            			}
            			else {
HXLINE(1355)				pointx1 = false;
            			}
HXDLIN(1355)			if (pointx1) {
HXLINE(1355)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1355)			{
HXLINE(1355)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = point->zpp_inner;
HXDLIN(1355)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1355)					_this1->_validate();
            				}
            			}
HXDLIN(1355)			pointx = (point->zpp_inner->x - this->zpp_inner->posx);
HXLINE(1356)			bool pointy1;
HXDLIN(1356)			if (hx::IsNotNull( point )) {
HXLINE(1356)				pointy1 = point->zpp_disp;
            			}
            			else {
HXLINE(1356)				pointy1 = false;
            			}
HXDLIN(1356)			if (pointy1) {
HXLINE(1356)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1356)			{
HXLINE(1356)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = point->zpp_inner;
HXDLIN(1356)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1356)					_this2->_validate();
            				}
            			}
HXDLIN(1356)			pointy = (point->zpp_inner->y - this->zpp_inner->posy);
            		}
HXLINE(1358)		{
HXLINE(1359)			tempx = ((pointx * this->zpp_inner->axisy) + (pointy * this->zpp_inner->axisx));
HXLINE(1360)			tempy = ((pointy * this->zpp_inner->axisy) - (pointx * this->zpp_inner->axisx));
            		}
HXLINE(1362)		if (point->zpp_inner->weak) {
HXLINE(1366)			bool _hx_tmp1;
HXDLIN(1366)			if (hx::IsNotNull( point )) {
HXLINE(1366)				_hx_tmp1 = point->zpp_disp;
            			}
            			else {
HXLINE(1366)				_hx_tmp1 = false;
            			}
HXDLIN(1366)			if (_hx_tmp1) {
HXLINE(1366)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1366)			{
HXLINE(1366)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = point->zpp_inner;
HXDLIN(1366)				if (_this3->_immutable) {
HXLINE(1366)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1366)				if (hx::IsNotNull( _this3->_isimmutable )) {
HXLINE(1366)					_this3->_isimmutable();
            				}
            			}
HXDLIN(1366)			if (point->zpp_inner->_inuse) {
HXLINE(1366)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1366)			 ::zpp_nape::geom::ZPP_Vec2 inner = point->zpp_inner;
HXDLIN(1366)			point->zpp_inner->outer = null();
HXDLIN(1366)			point->zpp_inner = null();
HXDLIN(1366)			{
HXLINE(1366)				 ::nape::geom::Vec2 o = point;
HXDLIN(1366)				o->zpp_pool = null();
HXDLIN(1366)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1366)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(1366)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(1366)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1366)				o->zpp_disp = true;
            			}
HXDLIN(1366)			{
HXLINE(1366)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1366)				{
HXLINE(1366)					if (hx::IsNotNull( o1->outer )) {
HXLINE(1366)						o1->outer->zpp_inner = null();
HXDLIN(1366)						o1->outer = null();
            					}
HXDLIN(1366)					o1->_isimmutable = null();
HXDLIN(1366)					o1->_validate = null();
HXDLIN(1366)					o1->_invalidate = null();
            				}
HXDLIN(1366)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1366)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(1373)		bool _hx_tmp2;
HXDLIN(1373)		if ((tempx == tempx)) {
HXLINE(1373)			_hx_tmp2 = (tempy != tempy);
            		}
            		else {
HXLINE(1373)			_hx_tmp2 = true;
            		}
HXDLIN(1373)		if (_hx_tmp2) {
HXLINE(1373)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN(1373)		 ::nape::geom::Vec2 ret;
HXDLIN(1373)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1373)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE(1373)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1373)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1373)			ret->zpp_pool = null();
HXDLIN(1373)			ret->zpp_disp = false;
HXDLIN(1373)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1373)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN(1373)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1373)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1373)			{
HXLINE(1373)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1373)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE(1373)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1373)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1373)					ret1->next = null();
            				}
HXDLIN(1373)				ret1->weak = false;
            			}
HXDLIN(1373)			ret1->_immutable = false;
HXDLIN(1373)			{
HXLINE(1373)				ret1->x = tempx;
HXDLIN(1373)				ret1->y = tempy;
            			}
HXDLIN(1373)			ret->zpp_inner = ret1;
HXDLIN(1373)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE(1373)			bool _hx_tmp3;
HXDLIN(1373)			if (hx::IsNotNull( ret )) {
HXLINE(1373)				_hx_tmp3 = ret->zpp_disp;
            			}
            			else {
HXLINE(1373)				_hx_tmp3 = false;
            			}
HXDLIN(1373)			if (_hx_tmp3) {
HXLINE(1373)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1373)			{
HXLINE(1373)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = ret->zpp_inner;
HXDLIN(1373)				if (_this4->_immutable) {
HXLINE(1373)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1373)				if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE(1373)					_this4->_isimmutable();
            				}
            			}
HXDLIN(1373)			bool _hx_tmp4;
HXDLIN(1373)			if ((tempx == tempx)) {
HXLINE(1373)				_hx_tmp4 = (tempy != tempy);
            			}
            			else {
HXLINE(1373)				_hx_tmp4 = true;
            			}
HXDLIN(1373)			if (_hx_tmp4) {
HXLINE(1373)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1373)			bool _hx_tmp5;
HXDLIN(1373)			bool _hx_tmp6;
HXDLIN(1373)			if (hx::IsNotNull( ret )) {
HXLINE(1373)				_hx_tmp6 = ret->zpp_disp;
            			}
            			else {
HXLINE(1373)				_hx_tmp6 = false;
            			}
HXDLIN(1373)			if (_hx_tmp6) {
HXLINE(1373)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1373)			{
HXLINE(1373)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = ret->zpp_inner;
HXDLIN(1373)				if (hx::IsNotNull( _this5->_validate )) {
HXLINE(1373)					_this5->_validate();
            				}
            			}
HXDLIN(1373)			if ((ret->zpp_inner->x == tempx)) {
HXLINE(1373)				bool _hx_tmp7;
HXDLIN(1373)				if (hx::IsNotNull( ret )) {
HXLINE(1373)					_hx_tmp7 = ret->zpp_disp;
            				}
            				else {
HXLINE(1373)					_hx_tmp7 = false;
            				}
HXDLIN(1373)				if (_hx_tmp7) {
HXLINE(1373)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1373)				{
HXLINE(1373)					 ::zpp_nape::geom::ZPP_Vec2 _this6 = ret->zpp_inner;
HXDLIN(1373)					if (hx::IsNotNull( _this6->_validate )) {
HXLINE(1373)						_this6->_validate();
            					}
            				}
HXDLIN(1373)				_hx_tmp5 = (ret->zpp_inner->y == tempy);
            			}
            			else {
HXLINE(1373)				_hx_tmp5 = false;
            			}
HXDLIN(1373)			if (!(_hx_tmp5)) {
HXLINE(1373)				{
HXLINE(1373)					ret->zpp_inner->x = tempx;
HXDLIN(1373)					ret->zpp_inner->y = tempy;
            				}
HXDLIN(1373)				{
HXLINE(1373)					 ::zpp_nape::geom::ZPP_Vec2 _this7 = ret->zpp_inner;
HXDLIN(1373)					if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE(1373)						_this7->_invalidate(_this7);
            					}
            				}
            			}
            		}
HXDLIN(1373)		ret->zpp_inner->weak = weak;
HXDLIN(1373)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,worldPointToLocal,return )

 ::nape::geom::Vec2 Body_obj::localVectorToWorld( ::nape::geom::Vec2 vector,hx::Null< bool >  __o_weak){
            		bool weak = __o_weak.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1387_localVectorToWorld)
HXLINE(1390)		bool _hx_tmp;
HXDLIN(1390)		if (hx::IsNotNull( vector )) {
HXLINE(1390)			_hx_tmp = vector->zpp_disp;
            		}
            		else {
HXLINE(1390)			_hx_tmp = false;
            		}
HXDLIN(1390)		if (_hx_tmp) {
HXLINE(1390)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1394)		if (hx::IsNull( vector )) {
HXLINE(1394)			HX_STACK_DO_THROW(HX_("Error: Cannot transform null Vec2",54,10,c3,67));
            		}
HXLINE(1396)		{
HXLINE(1396)			 ::zpp_nape::phys::ZPP_Body _this = this->zpp_inner;
HXDLIN(1396)			if (_this->zip_axis) {
HXLINE(1396)				_this->zip_axis = false;
HXDLIN(1396)				{
HXLINE(1396)					_this->axisx = ::Math_obj::sin(_this->rot);
HXDLIN(1396)					_this->axisy = ::Math_obj::cos(_this->rot);
            				}
            			}
            		}
HXLINE(1397)		Float tempx = ((Float)0.0);
HXLINE(1398)		Float tempy = ((Float)0.0);
HXLINE(1399)		{
HXLINE(1400)			Float tempx1 = this->zpp_inner->axisy;
HXDLIN(1400)			bool tempx2;
HXDLIN(1400)			if (hx::IsNotNull( vector )) {
HXLINE(1400)				tempx2 = vector->zpp_disp;
            			}
            			else {
HXLINE(1400)				tempx2 = false;
            			}
HXDLIN(1400)			if (tempx2) {
HXLINE(1400)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1400)			{
HXLINE(1400)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = vector->zpp_inner;
HXDLIN(1400)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1400)					_this1->_validate();
            				}
            			}
HXDLIN(1400)			Float tempx3 = (tempx1 * vector->zpp_inner->x);
HXDLIN(1400)			Float tempx4 = this->zpp_inner->axisx;
HXDLIN(1400)			bool tempx5;
HXDLIN(1400)			if (hx::IsNotNull( vector )) {
HXLINE(1400)				tempx5 = vector->zpp_disp;
            			}
            			else {
HXLINE(1400)				tempx5 = false;
            			}
HXDLIN(1400)			if (tempx5) {
HXLINE(1400)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1400)			{
HXLINE(1400)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = vector->zpp_inner;
HXDLIN(1400)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1400)					_this2->_validate();
            				}
            			}
HXDLIN(1400)			tempx = (tempx3 - (tempx4 * vector->zpp_inner->y));
HXLINE(1401)			bool tempy1;
HXDLIN(1401)			if (hx::IsNotNull( vector )) {
HXLINE(1401)				tempy1 = vector->zpp_disp;
            			}
            			else {
HXLINE(1401)				tempy1 = false;
            			}
HXDLIN(1401)			if (tempy1) {
HXLINE(1401)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1401)			{
HXLINE(1401)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = vector->zpp_inner;
HXDLIN(1401)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE(1401)					_this3->_validate();
            				}
            			}
HXDLIN(1401)			Float tempy2 = (vector->zpp_inner->x * this->zpp_inner->axisx);
HXDLIN(1401)			bool tempy3;
HXDLIN(1401)			if (hx::IsNotNull( vector )) {
HXLINE(1401)				tempy3 = vector->zpp_disp;
            			}
            			else {
HXLINE(1401)				tempy3 = false;
            			}
HXDLIN(1401)			if (tempy3) {
HXLINE(1401)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1401)			{
HXLINE(1401)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = vector->zpp_inner;
HXDLIN(1401)				if (hx::IsNotNull( _this4->_validate )) {
HXLINE(1401)					_this4->_validate();
            				}
            			}
HXDLIN(1401)			tempy = (tempy2 + (vector->zpp_inner->y * this->zpp_inner->axisy));
            		}
HXLINE(1403)		if (vector->zpp_inner->weak) {
HXLINE(1407)			bool _hx_tmp1;
HXDLIN(1407)			if (hx::IsNotNull( vector )) {
HXLINE(1407)				_hx_tmp1 = vector->zpp_disp;
            			}
            			else {
HXLINE(1407)				_hx_tmp1 = false;
            			}
HXDLIN(1407)			if (_hx_tmp1) {
HXLINE(1407)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1407)			{
HXLINE(1407)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = vector->zpp_inner;
HXDLIN(1407)				if (_this5->_immutable) {
HXLINE(1407)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1407)				if (hx::IsNotNull( _this5->_isimmutable )) {
HXLINE(1407)					_this5->_isimmutable();
            				}
            			}
HXDLIN(1407)			if (vector->zpp_inner->_inuse) {
HXLINE(1407)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1407)			 ::zpp_nape::geom::ZPP_Vec2 inner = vector->zpp_inner;
HXDLIN(1407)			vector->zpp_inner->outer = null();
HXDLIN(1407)			vector->zpp_inner = null();
HXDLIN(1407)			{
HXLINE(1407)				 ::nape::geom::Vec2 o = vector;
HXDLIN(1407)				o->zpp_pool = null();
HXDLIN(1407)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1407)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(1407)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(1407)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1407)				o->zpp_disp = true;
            			}
HXDLIN(1407)			{
HXLINE(1407)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1407)				{
HXLINE(1407)					if (hx::IsNotNull( o1->outer )) {
HXLINE(1407)						o1->outer->zpp_inner = null();
HXDLIN(1407)						o1->outer = null();
            					}
HXDLIN(1407)					o1->_isimmutable = null();
HXDLIN(1407)					o1->_validate = null();
HXDLIN(1407)					o1->_invalidate = null();
            				}
HXDLIN(1407)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1407)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(1414)		bool _hx_tmp2;
HXDLIN(1414)		if ((tempx == tempx)) {
HXLINE(1414)			_hx_tmp2 = (tempy != tempy);
            		}
            		else {
HXLINE(1414)			_hx_tmp2 = true;
            		}
HXDLIN(1414)		if (_hx_tmp2) {
HXLINE(1414)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN(1414)		 ::nape::geom::Vec2 ret;
HXDLIN(1414)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1414)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE(1414)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1414)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1414)			ret->zpp_pool = null();
HXDLIN(1414)			ret->zpp_disp = false;
HXDLIN(1414)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1414)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN(1414)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1414)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1414)			{
HXLINE(1414)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1414)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE(1414)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1414)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1414)					ret1->next = null();
            				}
HXDLIN(1414)				ret1->weak = false;
            			}
HXDLIN(1414)			ret1->_immutable = false;
HXDLIN(1414)			{
HXLINE(1414)				ret1->x = tempx;
HXDLIN(1414)				ret1->y = tempy;
            			}
HXDLIN(1414)			ret->zpp_inner = ret1;
HXDLIN(1414)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE(1414)			bool _hx_tmp3;
HXDLIN(1414)			if (hx::IsNotNull( ret )) {
HXLINE(1414)				_hx_tmp3 = ret->zpp_disp;
            			}
            			else {
HXLINE(1414)				_hx_tmp3 = false;
            			}
HXDLIN(1414)			if (_hx_tmp3) {
HXLINE(1414)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1414)			{
HXLINE(1414)				 ::zpp_nape::geom::ZPP_Vec2 _this6 = ret->zpp_inner;
HXDLIN(1414)				if (_this6->_immutable) {
HXLINE(1414)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1414)				if (hx::IsNotNull( _this6->_isimmutable )) {
HXLINE(1414)					_this6->_isimmutable();
            				}
            			}
HXDLIN(1414)			bool _hx_tmp4;
HXDLIN(1414)			if ((tempx == tempx)) {
HXLINE(1414)				_hx_tmp4 = (tempy != tempy);
            			}
            			else {
HXLINE(1414)				_hx_tmp4 = true;
            			}
HXDLIN(1414)			if (_hx_tmp4) {
HXLINE(1414)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1414)			bool _hx_tmp5;
HXDLIN(1414)			bool _hx_tmp6;
HXDLIN(1414)			if (hx::IsNotNull( ret )) {
HXLINE(1414)				_hx_tmp6 = ret->zpp_disp;
            			}
            			else {
HXLINE(1414)				_hx_tmp6 = false;
            			}
HXDLIN(1414)			if (_hx_tmp6) {
HXLINE(1414)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1414)			{
HXLINE(1414)				 ::zpp_nape::geom::ZPP_Vec2 _this7 = ret->zpp_inner;
HXDLIN(1414)				if (hx::IsNotNull( _this7->_validate )) {
HXLINE(1414)					_this7->_validate();
            				}
            			}
HXDLIN(1414)			if ((ret->zpp_inner->x == tempx)) {
HXLINE(1414)				bool _hx_tmp7;
HXDLIN(1414)				if (hx::IsNotNull( ret )) {
HXLINE(1414)					_hx_tmp7 = ret->zpp_disp;
            				}
            				else {
HXLINE(1414)					_hx_tmp7 = false;
            				}
HXDLIN(1414)				if (_hx_tmp7) {
HXLINE(1414)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1414)				{
HXLINE(1414)					 ::zpp_nape::geom::ZPP_Vec2 _this8 = ret->zpp_inner;
HXDLIN(1414)					if (hx::IsNotNull( _this8->_validate )) {
HXLINE(1414)						_this8->_validate();
            					}
            				}
HXDLIN(1414)				_hx_tmp5 = (ret->zpp_inner->y == tempy);
            			}
            			else {
HXLINE(1414)				_hx_tmp5 = false;
            			}
HXDLIN(1414)			if (!(_hx_tmp5)) {
HXLINE(1414)				{
HXLINE(1414)					ret->zpp_inner->x = tempx;
HXDLIN(1414)					ret->zpp_inner->y = tempy;
            				}
HXDLIN(1414)				{
HXLINE(1414)					 ::zpp_nape::geom::ZPP_Vec2 _this9 = ret->zpp_inner;
HXDLIN(1414)					if (hx::IsNotNull( _this9->_invalidate )) {
HXLINE(1414)						_this9->_invalidate(_this9);
            					}
            				}
            			}
            		}
HXDLIN(1414)		ret->zpp_inner->weak = weak;
HXDLIN(1414)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,localVectorToWorld,return )

 ::nape::geom::Vec2 Body_obj::worldVectorToLocal( ::nape::geom::Vec2 vector,hx::Null< bool >  __o_weak){
            		bool weak = __o_weak.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1428_worldVectorToLocal)
HXLINE(1431)		bool _hx_tmp;
HXDLIN(1431)		if (hx::IsNotNull( vector )) {
HXLINE(1431)			_hx_tmp = vector->zpp_disp;
            		}
            		else {
HXLINE(1431)			_hx_tmp = false;
            		}
HXDLIN(1431)		if (_hx_tmp) {
HXLINE(1431)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1435)		if (hx::IsNull( vector )) {
HXLINE(1435)			HX_STACK_DO_THROW(HX_("Error: Cannot transform null Vec2",54,10,c3,67));
            		}
HXLINE(1437)		{
HXLINE(1437)			 ::zpp_nape::phys::ZPP_Body _this = this->zpp_inner;
HXDLIN(1437)			if (_this->zip_axis) {
HXLINE(1437)				_this->zip_axis = false;
HXDLIN(1437)				{
HXLINE(1437)					_this->axisx = ::Math_obj::sin(_this->rot);
HXDLIN(1437)					_this->axisy = ::Math_obj::cos(_this->rot);
            				}
            			}
            		}
HXLINE(1438)		Float tempx = ((Float)0.0);
HXLINE(1439)		Float tempy = ((Float)0.0);
HXLINE(1440)		{
HXLINE(1441)			bool tempx1;
HXDLIN(1441)			if (hx::IsNotNull( vector )) {
HXLINE(1441)				tempx1 = vector->zpp_disp;
            			}
            			else {
HXLINE(1441)				tempx1 = false;
            			}
HXDLIN(1441)			if (tempx1) {
HXLINE(1441)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1441)			{
HXLINE(1441)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = vector->zpp_inner;
HXDLIN(1441)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1441)					_this1->_validate();
            				}
            			}
HXDLIN(1441)			Float tempx2 = (vector->zpp_inner->x * this->zpp_inner->axisy);
HXDLIN(1441)			bool tempx3;
HXDLIN(1441)			if (hx::IsNotNull( vector )) {
HXLINE(1441)				tempx3 = vector->zpp_disp;
            			}
            			else {
HXLINE(1441)				tempx3 = false;
            			}
HXDLIN(1441)			if (tempx3) {
HXLINE(1441)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1441)			{
HXLINE(1441)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = vector->zpp_inner;
HXDLIN(1441)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1441)					_this2->_validate();
            				}
            			}
HXDLIN(1441)			tempx = (tempx2 + (vector->zpp_inner->y * this->zpp_inner->axisx));
HXLINE(1442)			bool tempy1;
HXDLIN(1442)			if (hx::IsNotNull( vector )) {
HXLINE(1442)				tempy1 = vector->zpp_disp;
            			}
            			else {
HXLINE(1442)				tempy1 = false;
            			}
HXDLIN(1442)			if (tempy1) {
HXLINE(1442)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1442)			{
HXLINE(1442)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = vector->zpp_inner;
HXDLIN(1442)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE(1442)					_this3->_validate();
            				}
            			}
HXDLIN(1442)			Float tempy2 = (vector->zpp_inner->y * this->zpp_inner->axisy);
HXDLIN(1442)			bool tempy3;
HXDLIN(1442)			if (hx::IsNotNull( vector )) {
HXLINE(1442)				tempy3 = vector->zpp_disp;
            			}
            			else {
HXLINE(1442)				tempy3 = false;
            			}
HXDLIN(1442)			if (tempy3) {
HXLINE(1442)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1442)			{
HXLINE(1442)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = vector->zpp_inner;
HXDLIN(1442)				if (hx::IsNotNull( _this4->_validate )) {
HXLINE(1442)					_this4->_validate();
            				}
            			}
HXDLIN(1442)			tempy = (tempy2 - (vector->zpp_inner->x * this->zpp_inner->axisx));
            		}
HXLINE(1444)		if (vector->zpp_inner->weak) {
HXLINE(1448)			bool _hx_tmp1;
HXDLIN(1448)			if (hx::IsNotNull( vector )) {
HXLINE(1448)				_hx_tmp1 = vector->zpp_disp;
            			}
            			else {
HXLINE(1448)				_hx_tmp1 = false;
            			}
HXDLIN(1448)			if (_hx_tmp1) {
HXLINE(1448)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1448)			{
HXLINE(1448)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = vector->zpp_inner;
HXDLIN(1448)				if (_this5->_immutable) {
HXLINE(1448)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1448)				if (hx::IsNotNull( _this5->_isimmutable )) {
HXLINE(1448)					_this5->_isimmutable();
            				}
            			}
HXDLIN(1448)			if (vector->zpp_inner->_inuse) {
HXLINE(1448)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1448)			 ::zpp_nape::geom::ZPP_Vec2 inner = vector->zpp_inner;
HXDLIN(1448)			vector->zpp_inner->outer = null();
HXDLIN(1448)			vector->zpp_inner = null();
HXDLIN(1448)			{
HXLINE(1448)				 ::nape::geom::Vec2 o = vector;
HXDLIN(1448)				o->zpp_pool = null();
HXDLIN(1448)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1448)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(1448)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(1448)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1448)				o->zpp_disp = true;
            			}
HXDLIN(1448)			{
HXLINE(1448)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1448)				{
HXLINE(1448)					if (hx::IsNotNull( o1->outer )) {
HXLINE(1448)						o1->outer->zpp_inner = null();
HXDLIN(1448)						o1->outer = null();
            					}
HXDLIN(1448)					o1->_isimmutable = null();
HXDLIN(1448)					o1->_validate = null();
HXDLIN(1448)					o1->_invalidate = null();
            				}
HXDLIN(1448)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1448)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(1455)		bool _hx_tmp2;
HXDLIN(1455)		if ((tempx == tempx)) {
HXLINE(1455)			_hx_tmp2 = (tempy != tempy);
            		}
            		else {
HXLINE(1455)			_hx_tmp2 = true;
            		}
HXDLIN(1455)		if (_hx_tmp2) {
HXLINE(1455)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN(1455)		 ::nape::geom::Vec2 ret;
HXDLIN(1455)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1455)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE(1455)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1455)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1455)			ret->zpp_pool = null();
HXDLIN(1455)			ret->zpp_disp = false;
HXDLIN(1455)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1455)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN(1455)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1455)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1455)			{
HXLINE(1455)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1455)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE(1455)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1455)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1455)					ret1->next = null();
            				}
HXDLIN(1455)				ret1->weak = false;
            			}
HXDLIN(1455)			ret1->_immutable = false;
HXDLIN(1455)			{
HXLINE(1455)				ret1->x = tempx;
HXDLIN(1455)				ret1->y = tempy;
            			}
HXDLIN(1455)			ret->zpp_inner = ret1;
HXDLIN(1455)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE(1455)			bool _hx_tmp3;
HXDLIN(1455)			if (hx::IsNotNull( ret )) {
HXLINE(1455)				_hx_tmp3 = ret->zpp_disp;
            			}
            			else {
HXLINE(1455)				_hx_tmp3 = false;
            			}
HXDLIN(1455)			if (_hx_tmp3) {
HXLINE(1455)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1455)			{
HXLINE(1455)				 ::zpp_nape::geom::ZPP_Vec2 _this6 = ret->zpp_inner;
HXDLIN(1455)				if (_this6->_immutable) {
HXLINE(1455)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1455)				if (hx::IsNotNull( _this6->_isimmutable )) {
HXLINE(1455)					_this6->_isimmutable();
            				}
            			}
HXDLIN(1455)			bool _hx_tmp4;
HXDLIN(1455)			if ((tempx == tempx)) {
HXLINE(1455)				_hx_tmp4 = (tempy != tempy);
            			}
            			else {
HXLINE(1455)				_hx_tmp4 = true;
            			}
HXDLIN(1455)			if (_hx_tmp4) {
HXLINE(1455)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1455)			bool _hx_tmp5;
HXDLIN(1455)			bool _hx_tmp6;
HXDLIN(1455)			if (hx::IsNotNull( ret )) {
HXLINE(1455)				_hx_tmp6 = ret->zpp_disp;
            			}
            			else {
HXLINE(1455)				_hx_tmp6 = false;
            			}
HXDLIN(1455)			if (_hx_tmp6) {
HXLINE(1455)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1455)			{
HXLINE(1455)				 ::zpp_nape::geom::ZPP_Vec2 _this7 = ret->zpp_inner;
HXDLIN(1455)				if (hx::IsNotNull( _this7->_validate )) {
HXLINE(1455)					_this7->_validate();
            				}
            			}
HXDLIN(1455)			if ((ret->zpp_inner->x == tempx)) {
HXLINE(1455)				bool _hx_tmp7;
HXDLIN(1455)				if (hx::IsNotNull( ret )) {
HXLINE(1455)					_hx_tmp7 = ret->zpp_disp;
            				}
            				else {
HXLINE(1455)					_hx_tmp7 = false;
            				}
HXDLIN(1455)				if (_hx_tmp7) {
HXLINE(1455)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1455)				{
HXLINE(1455)					 ::zpp_nape::geom::ZPP_Vec2 _this8 = ret->zpp_inner;
HXDLIN(1455)					if (hx::IsNotNull( _this8->_validate )) {
HXLINE(1455)						_this8->_validate();
            					}
            				}
HXDLIN(1455)				_hx_tmp5 = (ret->zpp_inner->y == tempy);
            			}
            			else {
HXLINE(1455)				_hx_tmp5 = false;
            			}
HXDLIN(1455)			if (!(_hx_tmp5)) {
HXLINE(1455)				{
HXLINE(1455)					ret->zpp_inner->x = tempx;
HXDLIN(1455)					ret->zpp_inner->y = tempy;
            				}
HXDLIN(1455)				{
HXLINE(1455)					 ::zpp_nape::geom::ZPP_Vec2 _this9 = ret->zpp_inner;
HXDLIN(1455)					if (hx::IsNotNull( _this9->_invalidate )) {
HXLINE(1455)						_this9->_invalidate(_this9);
            					}
            				}
            			}
            		}
HXDLIN(1455)		ret->zpp_inner->weak = weak;
HXDLIN(1455)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,worldVectorToLocal,return )

 ::nape::phys::Body Body_obj::applyImpulse( ::nape::geom::Vec2 impulse, ::nape::geom::Vec2 pos,hx::Null< bool >  __o_sleepable){
            		bool sleepable = __o_sleepable.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1478_applyImpulse)
HXLINE(1481)		bool _hx_tmp;
HXDLIN(1481)		if (hx::IsNotNull( impulse )) {
HXLINE(1481)			_hx_tmp = impulse->zpp_disp;
            		}
            		else {
HXLINE(1481)			_hx_tmp = false;
            		}
HXDLIN(1481)		if (_hx_tmp) {
HXLINE(1481)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1486)		bool _hx_tmp1;
HXDLIN(1486)		if (hx::IsNotNull( pos )) {
HXLINE(1486)			_hx_tmp1 = pos->zpp_disp;
            		}
            		else {
HXLINE(1486)			_hx_tmp1 = false;
            		}
HXDLIN(1486)		if (_hx_tmp1) {
HXLINE(1486)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1490)		if (this->zpp_inner->world) {
HXLINE(1490)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1493)		if (hx::IsNull( impulse )) {
HXLINE(1493)			HX_STACK_DO_THROW(HX_("Error: Cannot apply null impulse to Body",44,f5,e1,71));
            		}
HXLINE(1495)		bool _hx_tmp2;
HXDLIN(1495)		if (sleepable) {
HXLINE(1495)			if (hx::IsNull( this->zpp_inner->space )) {
HXLINE(1495)				HX_STACK_DO_THROW(HX_("Error: isSleeping makes no sense if the object is not contained within a Space",1a,c1,d3,eb));
            			}
HXDLIN(1495)			_hx_tmp2 = this->zpp_inner->component->sleeping;
            		}
            		else {
HXLINE(1495)			_hx_tmp2 = false;
            		}
HXDLIN(1495)		if (_hx_tmp2) {
HXLINE(1496)			if (impulse->zpp_inner->weak) {
HXLINE(1500)				bool _hx_tmp3;
HXDLIN(1500)				if (hx::IsNotNull( impulse )) {
HXLINE(1500)					_hx_tmp3 = impulse->zpp_disp;
            				}
            				else {
HXLINE(1500)					_hx_tmp3 = false;
            				}
HXDLIN(1500)				if (_hx_tmp3) {
HXLINE(1500)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1500)				{
HXLINE(1500)					 ::zpp_nape::geom::ZPP_Vec2 _this = impulse->zpp_inner;
HXDLIN(1500)					if (_this->_immutable) {
HXLINE(1500)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN(1500)					if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(1500)						_this->_isimmutable();
            					}
            				}
HXDLIN(1500)				if (impulse->zpp_inner->_inuse) {
HXLINE(1500)					HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            				}
HXDLIN(1500)				 ::zpp_nape::geom::ZPP_Vec2 inner = impulse->zpp_inner;
HXDLIN(1500)				impulse->zpp_inner->outer = null();
HXDLIN(1500)				impulse->zpp_inner = null();
HXDLIN(1500)				{
HXLINE(1500)					 ::nape::geom::Vec2 o = impulse;
HXDLIN(1500)					o->zpp_pool = null();
HXDLIN(1500)					if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1500)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            					}
            					else {
HXLINE(1500)						::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            					}
HXDLIN(1500)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1500)					o->zpp_disp = true;
            				}
HXDLIN(1500)				{
HXLINE(1500)					 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1500)					{
HXLINE(1500)						if (hx::IsNotNull( o1->outer )) {
HXLINE(1500)							o1->outer->zpp_inner = null();
HXDLIN(1500)							o1->outer = null();
            						}
HXDLIN(1500)						o1->_isimmutable = null();
HXDLIN(1500)						o1->_validate = null();
HXDLIN(1500)						o1->_invalidate = null();
            					}
HXDLIN(1500)					o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1500)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            				}
            			}
HXLINE(1507)			if (hx::IsNotNull( pos )) {
HXLINE(1508)				if (pos->zpp_inner->weak) {
HXLINE(1512)					bool _hx_tmp4;
HXDLIN(1512)					if (hx::IsNotNull( pos )) {
HXLINE(1512)						_hx_tmp4 = pos->zpp_disp;
            					}
            					else {
HXLINE(1512)						_hx_tmp4 = false;
            					}
HXDLIN(1512)					if (_hx_tmp4) {
HXLINE(1512)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1512)					{
HXLINE(1512)						 ::zpp_nape::geom::ZPP_Vec2 _this1 = pos->zpp_inner;
HXDLIN(1512)						if (_this1->_immutable) {
HXLINE(1512)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN(1512)						if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE(1512)							_this1->_isimmutable();
            						}
            					}
HXDLIN(1512)					if (pos->zpp_inner->_inuse) {
HXLINE(1512)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN(1512)					 ::zpp_nape::geom::ZPP_Vec2 inner1 = pos->zpp_inner;
HXDLIN(1512)					pos->zpp_inner->outer = null();
HXDLIN(1512)					pos->zpp_inner = null();
HXDLIN(1512)					{
HXLINE(1512)						 ::nape::geom::Vec2 o2 = pos;
HXDLIN(1512)						o2->zpp_pool = null();
HXDLIN(1512)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1512)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            						}
            						else {
HXLINE(1512)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            						}
HXDLIN(1512)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN(1512)						o2->zpp_disp = true;
            					}
HXDLIN(1512)					{
HXLINE(1512)						 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN(1512)						{
HXLINE(1512)							if (hx::IsNotNull( o3->outer )) {
HXLINE(1512)								o3->outer->zpp_inner = null();
HXDLIN(1512)								o3->outer = null();
            							}
HXDLIN(1512)							o3->_isimmutable = null();
HXDLIN(1512)							o3->_validate = null();
HXDLIN(1512)							o3->_invalidate = null();
            						}
HXDLIN(1512)						o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1512)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            					}
            				}
            			}
HXLINE(1520)			return hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE(1522)		this->zpp_inner->validate_mass();
HXLINE(1523)		{
HXLINE(1524)			Float t = this->zpp_inner->imass;
HXLINE(1533)			 ::zpp_nape::phys::ZPP_Body _hx_tmp5 = this->zpp_inner;
HXDLIN(1533)			Float _hx_tmp6 = _hx_tmp5->velx;
HXDLIN(1533)			bool _hx_tmp7;
HXDLIN(1533)			if (hx::IsNotNull( impulse )) {
HXLINE(1533)				_hx_tmp7 = impulse->zpp_disp;
            			}
            			else {
HXLINE(1533)				_hx_tmp7 = false;
            			}
HXDLIN(1533)			if (_hx_tmp7) {
HXLINE(1533)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1533)			{
HXLINE(1533)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = impulse->zpp_inner;
HXDLIN(1533)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1533)					_this2->_validate();
            				}
            			}
HXDLIN(1533)			_hx_tmp5->velx = (_hx_tmp6 + (impulse->zpp_inner->x * t));
HXLINE(1534)			 ::zpp_nape::phys::ZPP_Body _hx_tmp8 = this->zpp_inner;
HXDLIN(1534)			Float _hx_tmp9 = _hx_tmp8->vely;
HXDLIN(1534)			bool _hx_tmp10;
HXDLIN(1534)			if (hx::IsNotNull( impulse )) {
HXLINE(1534)				_hx_tmp10 = impulse->zpp_disp;
            			}
            			else {
HXLINE(1534)				_hx_tmp10 = false;
            			}
HXDLIN(1534)			if (_hx_tmp10) {
HXLINE(1534)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1534)			{
HXLINE(1534)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = impulse->zpp_inner;
HXDLIN(1534)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE(1534)					_this3->_validate();
            				}
            			}
HXDLIN(1534)			_hx_tmp8->vely = (_hx_tmp9 + (impulse->zpp_inner->y * t));
            		}
HXLINE(1536)		if (hx::IsNotNull( pos )) {
HXLINE(1537)			Float rx = ((Float)0.0);
HXLINE(1538)			Float ry = ((Float)0.0);
HXLINE(1539)			{
HXLINE(1540)				bool rx1;
HXDLIN(1540)				if (hx::IsNotNull( pos )) {
HXLINE(1540)					rx1 = pos->zpp_disp;
            				}
            				else {
HXLINE(1540)					rx1 = false;
            				}
HXDLIN(1540)				if (rx1) {
HXLINE(1540)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1540)				{
HXLINE(1540)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = pos->zpp_inner;
HXDLIN(1540)					if (hx::IsNotNull( _this4->_validate )) {
HXLINE(1540)						_this4->_validate();
            					}
            				}
HXDLIN(1540)				rx = (pos->zpp_inner->x - this->zpp_inner->posx);
HXLINE(1541)				bool ry1;
HXDLIN(1541)				if (hx::IsNotNull( pos )) {
HXLINE(1541)					ry1 = pos->zpp_disp;
            				}
            				else {
HXLINE(1541)					ry1 = false;
            				}
HXDLIN(1541)				if (ry1) {
HXLINE(1541)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1541)				{
HXLINE(1541)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = pos->zpp_inner;
HXDLIN(1541)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE(1541)						_this5->_validate();
            					}
            				}
HXDLIN(1541)				ry = (pos->zpp_inner->y - this->zpp_inner->posy);
            			}
HXLINE(1543)			this->zpp_inner->validate_inertia();
HXLINE(1544)			 ::zpp_nape::phys::ZPP_Body _hx_tmp11 = this->zpp_inner;
HXDLIN(1544)			Float _hx_tmp12 = _hx_tmp11->angvel;
HXDLIN(1544)			bool _hx_tmp13;
HXDLIN(1544)			if (hx::IsNotNull( impulse )) {
HXLINE(1544)				_hx_tmp13 = impulse->zpp_disp;
            			}
            			else {
HXLINE(1544)				_hx_tmp13 = false;
            			}
HXDLIN(1544)			if (_hx_tmp13) {
HXLINE(1544)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1544)			{
HXLINE(1544)				 ::zpp_nape::geom::ZPP_Vec2 _this6 = impulse->zpp_inner;
HXDLIN(1544)				if (hx::IsNotNull( _this6->_validate )) {
HXLINE(1544)					_this6->_validate();
            				}
            			}
HXDLIN(1544)			Float _hx_tmp14 = (impulse->zpp_inner->y * rx);
HXDLIN(1544)			bool _hx_tmp15;
HXDLIN(1544)			if (hx::IsNotNull( impulse )) {
HXLINE(1544)				_hx_tmp15 = impulse->zpp_disp;
            			}
            			else {
HXLINE(1544)				_hx_tmp15 = false;
            			}
HXDLIN(1544)			if (_hx_tmp15) {
HXLINE(1544)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1544)			{
HXLINE(1544)				 ::zpp_nape::geom::ZPP_Vec2 _this7 = impulse->zpp_inner;
HXDLIN(1544)				if (hx::IsNotNull( _this7->_validate )) {
HXLINE(1544)					_this7->_validate();
            				}
            			}
HXDLIN(1544)			_hx_tmp11->angvel = (_hx_tmp12 + ((_hx_tmp14 - (impulse->zpp_inner->x * ry)) * this->zpp_inner->iinertia));
HXLINE(1545)			if (pos->zpp_inner->weak) {
HXLINE(1549)				bool _hx_tmp16;
HXDLIN(1549)				if (hx::IsNotNull( pos )) {
HXLINE(1549)					_hx_tmp16 = pos->zpp_disp;
            				}
            				else {
HXLINE(1549)					_hx_tmp16 = false;
            				}
HXDLIN(1549)				if (_hx_tmp16) {
HXLINE(1549)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1549)				{
HXLINE(1549)					 ::zpp_nape::geom::ZPP_Vec2 _this8 = pos->zpp_inner;
HXDLIN(1549)					if (_this8->_immutable) {
HXLINE(1549)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN(1549)					if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE(1549)						_this8->_isimmutable();
            					}
            				}
HXDLIN(1549)				if (pos->zpp_inner->_inuse) {
HXLINE(1549)					HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            				}
HXDLIN(1549)				 ::zpp_nape::geom::ZPP_Vec2 inner2 = pos->zpp_inner;
HXDLIN(1549)				pos->zpp_inner->outer = null();
HXDLIN(1549)				pos->zpp_inner = null();
HXDLIN(1549)				{
HXLINE(1549)					 ::nape::geom::Vec2 o4 = pos;
HXDLIN(1549)					o4->zpp_pool = null();
HXDLIN(1549)					if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1549)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o4;
            					}
            					else {
HXLINE(1549)						::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o4;
            					}
HXDLIN(1549)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o4;
HXDLIN(1549)					o4->zpp_disp = true;
            				}
HXDLIN(1549)				{
HXLINE(1549)					 ::zpp_nape::geom::ZPP_Vec2 o5 = inner2;
HXDLIN(1549)					{
HXLINE(1549)						if (hx::IsNotNull( o5->outer )) {
HXLINE(1549)							o5->outer->zpp_inner = null();
HXDLIN(1549)							o5->outer = null();
            						}
HXDLIN(1549)						o5->_isimmutable = null();
HXDLIN(1549)						o5->_validate = null();
HXDLIN(1549)						o5->_invalidate = null();
            					}
HXDLIN(1549)					o5->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1549)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o5;
            				}
            			}
            		}
HXLINE(1557)		if (!(sleepable)) {
HXLINE(1558)			if ((this->zpp_inner->type == 2)) {
HXLINE(1558)				this->zpp_inner->wake();
            			}
            		}
HXLINE(1560)		if (impulse->zpp_inner->weak) {
HXLINE(1564)			bool _hx_tmp17;
HXDLIN(1564)			if (hx::IsNotNull( impulse )) {
HXLINE(1564)				_hx_tmp17 = impulse->zpp_disp;
            			}
            			else {
HXLINE(1564)				_hx_tmp17 = false;
            			}
HXDLIN(1564)			if (_hx_tmp17) {
HXLINE(1564)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1564)			{
HXLINE(1564)				 ::zpp_nape::geom::ZPP_Vec2 _this9 = impulse->zpp_inner;
HXDLIN(1564)				if (_this9->_immutable) {
HXLINE(1564)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1564)				if (hx::IsNotNull( _this9->_isimmutable )) {
HXLINE(1564)					_this9->_isimmutable();
            				}
            			}
HXDLIN(1564)			if (impulse->zpp_inner->_inuse) {
HXLINE(1564)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1564)			 ::zpp_nape::geom::ZPP_Vec2 inner3 = impulse->zpp_inner;
HXDLIN(1564)			impulse->zpp_inner->outer = null();
HXDLIN(1564)			impulse->zpp_inner = null();
HXDLIN(1564)			{
HXLINE(1564)				 ::nape::geom::Vec2 o6 = impulse;
HXDLIN(1564)				o6->zpp_pool = null();
HXDLIN(1564)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1564)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o6;
            				}
            				else {
HXLINE(1564)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o6;
            				}
HXDLIN(1564)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o6;
HXDLIN(1564)				o6->zpp_disp = true;
            			}
HXDLIN(1564)			{
HXLINE(1564)				 ::zpp_nape::geom::ZPP_Vec2 o7 = inner3;
HXDLIN(1564)				{
HXLINE(1564)					if (hx::IsNotNull( o7->outer )) {
HXLINE(1564)						o7->outer->zpp_inner = null();
HXDLIN(1564)						o7->outer = null();
            					}
HXDLIN(1564)					o7->_isimmutable = null();
HXDLIN(1564)					o7->_validate = null();
HXDLIN(1564)					o7->_invalidate = null();
            				}
HXDLIN(1564)				o7->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1564)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o7;
            			}
            		}
HXLINE(1571)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Body_obj,applyImpulse,return )

 ::nape::phys::Body Body_obj::applyAngularImpulse(Float impulse,hx::Null< bool >  __o_sleepable){
            		bool sleepable = __o_sleepable.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1587_applyAngularImpulse)
HXLINE(1589)		if (this->zpp_inner->world) {
HXLINE(1589)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1591)		bool _hx_tmp;
HXDLIN(1591)		if (sleepable) {
HXLINE(1591)			if (hx::IsNull( this->zpp_inner->space )) {
HXLINE(1591)				HX_STACK_DO_THROW(HX_("Error: isSleeping makes no sense if the object is not contained within a Space",1a,c1,d3,eb));
            			}
HXDLIN(1591)			_hx_tmp = this->zpp_inner->component->sleeping;
            		}
            		else {
HXLINE(1591)			_hx_tmp = false;
            		}
HXDLIN(1591)		if (_hx_tmp) {
HXLINE(1592)			return hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE(1594)		this->zpp_inner->validate_inertia();
HXLINE(1595)		 ::zpp_nape::phys::ZPP_Body _hx_tmp1 = this->zpp_inner;
HXDLIN(1595)		_hx_tmp1->angvel = (_hx_tmp1->angvel + (impulse * this->zpp_inner->iinertia));
HXLINE(1596)		if (!(sleepable)) {
HXLINE(1597)			if ((this->zpp_inner->type == 2)) {
HXLINE(1597)				this->zpp_inner->wake();
            			}
            		}
HXLINE(1599)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,applyAngularImpulse,return )

 ::nape::phys::Body Body_obj::translateShapes( ::nape::geom::Vec2 translation){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1613_translateShapes)
HXLINE(1614)		this->zpp_inner->immutable_midstep(HX_("Body::translateShapes()",df,8e,13,25));
HXLINE(1617)		bool _hx_tmp;
HXDLIN(1617)		if (hx::IsNotNull( translation )) {
HXLINE(1617)			_hx_tmp = translation->zpp_disp;
            		}
            		else {
HXLINE(1617)			_hx_tmp = false;
            		}
HXDLIN(1617)		if (_hx_tmp) {
HXLINE(1617)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1621)		if (this->zpp_inner->world) {
HXLINE(1621)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1624)		if (hx::IsNull( translation )) {
HXLINE(1624)			HX_STACK_DO_THROW(HX_("Error: Cannot displace by null Vec2",86,36,3a,52));
            		}
HXLINE(1626)		bool weak = translation->zpp_inner->weak;
HXLINE(1627)		translation->zpp_inner->weak = false;
HXLINE(1628)		{
HXLINE(1629)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1630)			while(hx::IsNotNull( cx_ite )){
HXLINE(1631)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1632)				s->outer->translate(translation);
HXLINE(1633)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1636)		translation->zpp_inner->weak = weak;
HXLINE(1637)		if (translation->zpp_inner->weak) {
HXLINE(1641)			bool _hx_tmp1;
HXDLIN(1641)			if (hx::IsNotNull( translation )) {
HXLINE(1641)				_hx_tmp1 = translation->zpp_disp;
            			}
            			else {
HXLINE(1641)				_hx_tmp1 = false;
            			}
HXDLIN(1641)			if (_hx_tmp1) {
HXLINE(1641)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1641)			{
HXLINE(1641)				 ::zpp_nape::geom::ZPP_Vec2 _this = translation->zpp_inner;
HXDLIN(1641)				if (_this->_immutable) {
HXLINE(1641)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1641)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(1641)					_this->_isimmutable();
            				}
            			}
HXDLIN(1641)			if (translation->zpp_inner->_inuse) {
HXLINE(1641)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1641)			 ::zpp_nape::geom::ZPP_Vec2 inner = translation->zpp_inner;
HXDLIN(1641)			translation->zpp_inner->outer = null();
HXDLIN(1641)			translation->zpp_inner = null();
HXDLIN(1641)			{
HXLINE(1641)				 ::nape::geom::Vec2 o = translation;
HXDLIN(1641)				o->zpp_pool = null();
HXDLIN(1641)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1641)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(1641)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(1641)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1641)				o->zpp_disp = true;
            			}
HXDLIN(1641)			{
HXLINE(1641)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1641)				{
HXLINE(1641)					if (hx::IsNotNull( o1->outer )) {
HXLINE(1641)						o1->outer->zpp_inner = null();
HXDLIN(1641)						o1->outer = null();
            					}
HXDLIN(1641)					o1->_isimmutable = null();
HXDLIN(1641)					o1->_validate = null();
HXDLIN(1641)					o1->_invalidate = null();
            				}
HXDLIN(1641)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1641)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(1648)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,translateShapes,return )

 ::nape::phys::Body Body_obj::rotateShapes(Float angle){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1661_rotateShapes)
HXLINE(1662)		this->zpp_inner->immutable_midstep(HX_("Body::rotateShapes()",b0,10,24,6f));
HXLINE(1664)		if (this->zpp_inner->world) {
HXLINE(1664)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1666)		{
HXLINE(1667)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1668)			while(hx::IsNotNull( cx_ite )){
HXLINE(1669)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1670)				s->outer->rotate(angle);
HXLINE(1671)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1674)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,rotateShapes,return )

 ::nape::phys::Body Body_obj::scaleShapes(Float scaleX,Float scaleY){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1689_scaleShapes)
HXLINE(1690)		this->zpp_inner->immutable_midstep(HX_("Body::scaleShapes()",1b,eb,17,58));
HXLINE(1692)		if (this->zpp_inner->world) {
HXLINE(1692)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1694)		{
HXLINE(1695)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1696)			while(hx::IsNotNull( cx_ite )){
HXLINE(1697)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1698)				s->outer->scale(scaleX,scaleY);
HXLINE(1699)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1702)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,scaleShapes,return )

 ::nape::phys::Body Body_obj::transformShapes( ::nape::geom::Mat23 matrix){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1718_transformShapes)
HXLINE(1719)		this->zpp_inner->immutable_midstep(HX_("Body::transformShapes()",fd,32,b7,bd));
HXLINE(1721)		if (this->zpp_inner->world) {
HXLINE(1721)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1723)		{
HXLINE(1724)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1725)			while(hx::IsNotNull( cx_ite )){
HXLINE(1726)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1727)				s->outer->transform(matrix);
HXLINE(1728)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1731)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,transformShapes,return )

 ::nape::phys::Body Body_obj::align(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1749_align)
HXLINE(1750)		this->zpp_inner->immutable_midstep(HX_("Body::align()",44,8b,7d,21));
HXLINE(1752)		if (this->zpp_inner->world) {
HXLINE(1752)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1755)		if (hx::IsNull( this->zpp_inner->shapes->head )) {
HXLINE(1755)			HX_STACK_DO_THROW(HX_("Error: Cannot align empty Body",bf,31,d9,0a));
            		}
HXLINE(1757)		this->zpp_inner->validate_localCOM();
HXLINE(1758)		Float x = -(this->zpp_inner->localCOMx);
HXDLIN(1758)		Float y = -(this->zpp_inner->localCOMy);
HXDLIN(1758)		bool _hx_tmp;
HXDLIN(1758)		if ((x == x)) {
HXLINE(1758)			_hx_tmp = (y != y);
            		}
            		else {
HXLINE(1758)			_hx_tmp = true;
            		}
HXDLIN(1758)		if (_hx_tmp) {
HXLINE(1758)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN(1758)		 ::nape::geom::Vec2 ret;
HXDLIN(1758)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1758)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE(1758)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1758)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1758)			ret->zpp_pool = null();
HXDLIN(1758)			ret->zpp_disp = false;
HXDLIN(1758)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1758)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN(1758)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1758)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1758)			{
HXLINE(1758)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1758)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE(1758)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1758)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1758)					ret1->next = null();
            				}
HXDLIN(1758)				ret1->weak = false;
            			}
HXDLIN(1758)			ret1->_immutable = false;
HXDLIN(1758)			{
HXLINE(1758)				ret1->x = x;
HXDLIN(1758)				ret1->y = y;
            			}
HXDLIN(1758)			ret->zpp_inner = ret1;
HXDLIN(1758)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE(1758)			bool _hx_tmp1;
HXDLIN(1758)			if (hx::IsNotNull( ret )) {
HXLINE(1758)				_hx_tmp1 = ret->zpp_disp;
            			}
            			else {
HXLINE(1758)				_hx_tmp1 = false;
            			}
HXDLIN(1758)			if (_hx_tmp1) {
HXLINE(1758)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1758)			{
HXLINE(1758)				 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN(1758)				if (_this->_immutable) {
HXLINE(1758)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1758)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(1758)					_this->_isimmutable();
            				}
            			}
HXDLIN(1758)			bool _hx_tmp2;
HXDLIN(1758)			if ((x == x)) {
HXLINE(1758)				_hx_tmp2 = (y != y);
            			}
            			else {
HXLINE(1758)				_hx_tmp2 = true;
            			}
HXDLIN(1758)			if (_hx_tmp2) {
HXLINE(1758)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1758)			bool _hx_tmp3;
HXDLIN(1758)			bool _hx_tmp4;
HXDLIN(1758)			if (hx::IsNotNull( ret )) {
HXLINE(1758)				_hx_tmp4 = ret->zpp_disp;
            			}
            			else {
HXLINE(1758)				_hx_tmp4 = false;
            			}
HXDLIN(1758)			if (_hx_tmp4) {
HXLINE(1758)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1758)			{
HXLINE(1758)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN(1758)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1758)					_this1->_validate();
            				}
            			}
HXDLIN(1758)			if ((ret->zpp_inner->x == x)) {
HXLINE(1758)				bool _hx_tmp5;
HXDLIN(1758)				if (hx::IsNotNull( ret )) {
HXLINE(1758)					_hx_tmp5 = ret->zpp_disp;
            				}
            				else {
HXLINE(1758)					_hx_tmp5 = false;
            				}
HXDLIN(1758)				if (_hx_tmp5) {
HXLINE(1758)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1758)				{
HXLINE(1758)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN(1758)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1758)						_this2->_validate();
            					}
            				}
HXDLIN(1758)				_hx_tmp3 = (ret->zpp_inner->y == y);
            			}
            			else {
HXLINE(1758)				_hx_tmp3 = false;
            			}
HXDLIN(1758)			if (!(_hx_tmp3)) {
HXLINE(1758)				{
HXLINE(1758)					ret->zpp_inner->x = x;
HXDLIN(1758)					ret->zpp_inner->y = y;
            				}
HXDLIN(1758)				{
HXLINE(1758)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN(1758)					if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE(1758)						_this3->_invalidate(_this3);
            					}
            				}
            			}
            		}
HXDLIN(1758)		ret->zpp_inner->weak = false;
HXDLIN(1758)		 ::nape::geom::Vec2 dx = ret;
HXLINE(1759)		this->translateShapes(dx);
HXLINE(1760)		 ::nape::geom::Vec2 dx2 = this->localVectorToWorld(dx,null());
HXLINE(1761)		if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE(1761)			this->zpp_inner->setupPosition();
            		}
HXDLIN(1761)		this->zpp_inner->wrap_pos->subeq(dx2);
HXLINE(1762)		if ((this->zpp_inner->pre_posx < ::Math_obj::POSITIVE_INFINITY)) {
HXLINE(1763)			Float t = ((Float)1.0);
HXLINE(1772)			 ::zpp_nape::phys::ZPP_Body _hx_tmp6 = this->zpp_inner;
HXDLIN(1772)			Float _hx_tmp7 = _hx_tmp6->pre_posx;
HXDLIN(1772)			bool _hx_tmp8;
HXDLIN(1772)			if (hx::IsNotNull( dx2 )) {
HXLINE(1772)				_hx_tmp8 = dx2->zpp_disp;
            			}
            			else {
HXLINE(1772)				_hx_tmp8 = false;
            			}
HXDLIN(1772)			if (_hx_tmp8) {
HXLINE(1772)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1772)			{
HXLINE(1772)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = dx2->zpp_inner;
HXDLIN(1772)				if (hx::IsNotNull( _this4->_validate )) {
HXLINE(1772)					_this4->_validate();
            				}
            			}
HXDLIN(1772)			_hx_tmp6->pre_posx = (_hx_tmp7 - (dx2->zpp_inner->x * t));
HXLINE(1773)			 ::zpp_nape::phys::ZPP_Body _hx_tmp9 = this->zpp_inner;
HXDLIN(1773)			Float _hx_tmp10 = _hx_tmp9->pre_posy;
HXDLIN(1773)			bool _hx_tmp11;
HXDLIN(1773)			if (hx::IsNotNull( dx2 )) {
HXLINE(1773)				_hx_tmp11 = dx2->zpp_disp;
            			}
            			else {
HXLINE(1773)				_hx_tmp11 = false;
            			}
HXDLIN(1773)			if (_hx_tmp11) {
HXLINE(1773)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1773)			{
HXLINE(1773)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = dx2->zpp_inner;
HXDLIN(1773)				if (hx::IsNotNull( _this5->_validate )) {
HXLINE(1773)					_this5->_validate();
            				}
            			}
HXDLIN(1773)			_hx_tmp9->pre_posy = (_hx_tmp10 - (dx2->zpp_inner->y * t));
            		}
HXLINE(1775)		{
HXLINE(1775)			bool _hx_tmp12;
HXDLIN(1775)			if (hx::IsNotNull( dx )) {
HXLINE(1775)				_hx_tmp12 = dx->zpp_disp;
            			}
            			else {
HXLINE(1775)				_hx_tmp12 = false;
            			}
HXDLIN(1775)			if (_hx_tmp12) {
HXLINE(1775)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1775)			{
HXLINE(1775)				 ::zpp_nape::geom::ZPP_Vec2 _this6 = dx->zpp_inner;
HXDLIN(1775)				if (_this6->_immutable) {
HXLINE(1775)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1775)				if (hx::IsNotNull( _this6->_isimmutable )) {
HXLINE(1775)					_this6->_isimmutable();
            				}
            			}
HXDLIN(1775)			if (dx->zpp_inner->_inuse) {
HXLINE(1775)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1775)			 ::zpp_nape::geom::ZPP_Vec2 inner = dx->zpp_inner;
HXDLIN(1775)			dx->zpp_inner->outer = null();
HXDLIN(1775)			dx->zpp_inner = null();
HXDLIN(1775)			{
HXLINE(1775)				 ::nape::geom::Vec2 o = dx;
HXDLIN(1775)				o->zpp_pool = null();
HXDLIN(1775)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1775)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(1775)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(1775)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1775)				o->zpp_disp = true;
            			}
HXDLIN(1775)			{
HXLINE(1775)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1775)				{
HXLINE(1775)					if (hx::IsNotNull( o1->outer )) {
HXLINE(1775)						o1->outer->zpp_inner = null();
HXDLIN(1775)						o1->outer = null();
            					}
HXDLIN(1775)					o1->_isimmutable = null();
HXDLIN(1775)					o1->_validate = null();
HXDLIN(1775)					o1->_invalidate = null();
            				}
HXDLIN(1775)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1775)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(1776)		{
HXLINE(1776)			bool _hx_tmp13;
HXDLIN(1776)			if (hx::IsNotNull( dx2 )) {
HXLINE(1776)				_hx_tmp13 = dx2->zpp_disp;
            			}
            			else {
HXLINE(1776)				_hx_tmp13 = false;
            			}
HXDLIN(1776)			if (_hx_tmp13) {
HXLINE(1776)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1776)			{
HXLINE(1776)				 ::zpp_nape::geom::ZPP_Vec2 _this7 = dx2->zpp_inner;
HXDLIN(1776)				if (_this7->_immutable) {
HXLINE(1776)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1776)				if (hx::IsNotNull( _this7->_isimmutable )) {
HXLINE(1776)					_this7->_isimmutable();
            				}
            			}
HXDLIN(1776)			if (dx2->zpp_inner->_inuse) {
HXLINE(1776)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1776)			 ::zpp_nape::geom::ZPP_Vec2 inner1 = dx2->zpp_inner;
HXDLIN(1776)			dx2->zpp_inner->outer = null();
HXDLIN(1776)			dx2->zpp_inner = null();
HXDLIN(1776)			{
HXLINE(1776)				 ::nape::geom::Vec2 o2 = dx2;
HXDLIN(1776)				o2->zpp_pool = null();
HXDLIN(1776)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1776)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            				}
            				else {
HXLINE(1776)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            				}
HXDLIN(1776)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN(1776)				o2->zpp_disp = true;
            			}
HXDLIN(1776)			{
HXLINE(1776)				 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN(1776)				{
HXLINE(1776)					if (hx::IsNotNull( o3->outer )) {
HXLINE(1776)						o3->outer->zpp_inner = null();
HXDLIN(1776)						o3->outer = null();
            					}
HXDLIN(1776)					o3->_isimmutable = null();
HXDLIN(1776)					o3->_validate = null();
HXDLIN(1776)					o3->_invalidate = null();
            				}
HXDLIN(1776)				o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1776)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            			}
            		}
HXLINE(1777)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,align,return )

 ::nape::phys::Body Body_obj::rotate( ::nape::geom::Vec2 centre,Float angle){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1792_rotate)
HXLINE(1795)		bool _hx_tmp;
HXDLIN(1795)		if (hx::IsNotNull( centre )) {
HXLINE(1795)			_hx_tmp = centre->zpp_disp;
            		}
            		else {
HXLINE(1795)			_hx_tmp = false;
            		}
HXDLIN(1795)		if (_hx_tmp) {
HXLINE(1795)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(1799)		if (hx::IsNull( centre )) {
HXLINE(1799)			HX_STACK_DO_THROW(HX_("Error: Cannot rotate about a null Vec2",ef,7f,59,a6));
            		}
HXLINE(1802)		if ((angle != angle)) {
HXLINE(1802)			HX_STACK_DO_THROW(HX_("Error: Cannot rotate by NaN radians",da,44,34,35));
            		}
HXLINE(1804)		bool weak = centre->zpp_inner->weak;
HXLINE(1805)		centre->zpp_inner->weak = false;
HXLINE(1806)		if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE(1806)			this->zpp_inner->setupPosition();
            		}
HXDLIN(1806)		 ::nape::geom::Vec2 del = this->zpp_inner->wrap_pos->sub(centre,null());
HXLINE(1807)		del->rotate(angle);
HXLINE(1808)		{
HXLINE(1808)			 ::nape::geom::Vec2 position = centre->add(del,true);
HXDLIN(1808)			{
HXLINE(1808)				bool _hx_tmp1;
HXDLIN(1808)				if (hx::IsNotNull( position )) {
HXLINE(1808)					_hx_tmp1 = position->zpp_disp;
            				}
            				else {
HXLINE(1808)					_hx_tmp1 = false;
            				}
HXDLIN(1808)				if (_hx_tmp1) {
HXLINE(1808)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1808)				if (hx::IsNull( position )) {
HXLINE(1808)					HX_STACK_DO_THROW(((HX_("Error: Body::",d0,64,91,7e) + HX_("position",a9,a0,fa,ca)) + HX_(" cannot be null",07,dc,5d,15)));
            				}
HXDLIN(1808)				{
HXLINE(1808)					if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE(1808)						this->zpp_inner->setupPosition();
            					}
HXDLIN(1808)					 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_pos;
HXDLIN(1808)					bool _hx_tmp2;
HXDLIN(1808)					if (hx::IsNotNull( _this )) {
HXLINE(1808)						_hx_tmp2 = _this->zpp_disp;
            					}
            					else {
HXLINE(1808)						_hx_tmp2 = false;
            					}
HXDLIN(1808)					if (_hx_tmp2) {
HXLINE(1808)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1808)					bool _hx_tmp3;
HXDLIN(1808)					if (hx::IsNotNull( position )) {
HXLINE(1808)						_hx_tmp3 = position->zpp_disp;
            					}
            					else {
HXLINE(1808)						_hx_tmp3 = false;
            					}
HXDLIN(1808)					if (_hx_tmp3) {
HXLINE(1808)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1808)					{
HXLINE(1808)						 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN(1808)						if (_this1->_immutable) {
HXLINE(1808)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN(1808)						if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE(1808)							_this1->_isimmutable();
            						}
            					}
HXDLIN(1808)					if (hx::IsNull( position )) {
HXLINE(1808)						HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            					}
HXDLIN(1808)					bool _hx_tmp4;
HXDLIN(1808)					if (hx::IsNotNull( position )) {
HXLINE(1808)						_hx_tmp4 = position->zpp_disp;
            					}
            					else {
HXLINE(1808)						_hx_tmp4 = false;
            					}
HXDLIN(1808)					if (_hx_tmp4) {
HXLINE(1808)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1808)					{
HXLINE(1808)						 ::zpp_nape::geom::ZPP_Vec2 _this2 = position->zpp_inner;
HXDLIN(1808)						if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1808)							_this2->_validate();
            						}
            					}
HXDLIN(1808)					Float x = position->zpp_inner->x;
HXDLIN(1808)					bool _hx_tmp5;
HXDLIN(1808)					if (hx::IsNotNull( position )) {
HXLINE(1808)						_hx_tmp5 = position->zpp_disp;
            					}
            					else {
HXLINE(1808)						_hx_tmp5 = false;
            					}
HXDLIN(1808)					if (_hx_tmp5) {
HXLINE(1808)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1808)					{
HXLINE(1808)						 ::zpp_nape::geom::ZPP_Vec2 _this3 = position->zpp_inner;
HXDLIN(1808)						if (hx::IsNotNull( _this3->_validate )) {
HXLINE(1808)							_this3->_validate();
            						}
            					}
HXDLIN(1808)					Float y = position->zpp_inner->y;
HXDLIN(1808)					bool _hx_tmp6;
HXDLIN(1808)					if (hx::IsNotNull( _this )) {
HXLINE(1808)						_hx_tmp6 = _this->zpp_disp;
            					}
            					else {
HXLINE(1808)						_hx_tmp6 = false;
            					}
HXDLIN(1808)					if (_hx_tmp6) {
HXLINE(1808)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1808)					{
HXLINE(1808)						 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN(1808)						if (_this4->_immutable) {
HXLINE(1808)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN(1808)						if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE(1808)							_this4->_isimmutable();
            						}
            					}
HXDLIN(1808)					bool _hx_tmp7;
HXDLIN(1808)					if ((x == x)) {
HXLINE(1808)						_hx_tmp7 = (y != y);
            					}
            					else {
HXLINE(1808)						_hx_tmp7 = true;
            					}
HXDLIN(1808)					if (_hx_tmp7) {
HXLINE(1808)						HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            					}
HXDLIN(1808)					bool _hx_tmp8;
HXDLIN(1808)					bool _hx_tmp9;
HXDLIN(1808)					if (hx::IsNotNull( _this )) {
HXLINE(1808)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE(1808)						_hx_tmp9 = false;
            					}
HXDLIN(1808)					if (_hx_tmp9) {
HXLINE(1808)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1808)					{
HXLINE(1808)						 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN(1808)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE(1808)							_this5->_validate();
            						}
            					}
HXDLIN(1808)					if ((_this->zpp_inner->x == x)) {
HXLINE(1808)						bool _hx_tmp10;
HXDLIN(1808)						if (hx::IsNotNull( _this )) {
HXLINE(1808)							_hx_tmp10 = _this->zpp_disp;
            						}
            						else {
HXLINE(1808)							_hx_tmp10 = false;
            						}
HXDLIN(1808)						if (_hx_tmp10) {
HXLINE(1808)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN(1808)						{
HXLINE(1808)							 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN(1808)							if (hx::IsNotNull( _this6->_validate )) {
HXLINE(1808)								_this6->_validate();
            							}
            						}
HXDLIN(1808)						_hx_tmp8 = (_this->zpp_inner->y == y);
            					}
            					else {
HXLINE(1808)						_hx_tmp8 = false;
            					}
HXDLIN(1808)					if (!(_hx_tmp8)) {
HXLINE(1808)						{
HXLINE(1808)							_this->zpp_inner->x = x;
HXDLIN(1808)							_this->zpp_inner->y = y;
            						}
HXDLIN(1808)						{
HXLINE(1808)							 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN(1808)							if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE(1808)								_this7->_invalidate(_this7);
            							}
            						}
            					}
HXDLIN(1808)					 ::nape::geom::Vec2 ret = _this;
HXDLIN(1808)					if (position->zpp_inner->weak) {
HXLINE(1808)						bool _hx_tmp11;
HXDLIN(1808)						if (hx::IsNotNull( position )) {
HXLINE(1808)							_hx_tmp11 = position->zpp_disp;
            						}
            						else {
HXLINE(1808)							_hx_tmp11 = false;
            						}
HXDLIN(1808)						if (_hx_tmp11) {
HXLINE(1808)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN(1808)						{
HXLINE(1808)							 ::zpp_nape::geom::ZPP_Vec2 _this8 = position->zpp_inner;
HXDLIN(1808)							if (_this8->_immutable) {
HXLINE(1808)								HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            							}
HXDLIN(1808)							if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE(1808)								_this8->_isimmutable();
            							}
            						}
HXDLIN(1808)						if (position->zpp_inner->_inuse) {
HXLINE(1808)							HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            						}
HXDLIN(1808)						 ::zpp_nape::geom::ZPP_Vec2 inner = position->zpp_inner;
HXDLIN(1808)						position->zpp_inner->outer = null();
HXDLIN(1808)						position->zpp_inner = null();
HXDLIN(1808)						{
HXLINE(1808)							 ::nape::geom::Vec2 o = position;
HXDLIN(1808)							o->zpp_pool = null();
HXDLIN(1808)							if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1808)								::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            							}
            							else {
HXLINE(1808)								::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            							}
HXDLIN(1808)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(1808)							o->zpp_disp = true;
            						}
HXDLIN(1808)						{
HXLINE(1808)							 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(1808)							{
HXLINE(1808)								if (hx::IsNotNull( o1->outer )) {
HXLINE(1808)									o1->outer->zpp_inner = null();
HXDLIN(1808)									o1->outer = null();
            								}
HXDLIN(1808)								o1->_isimmutable = null();
HXDLIN(1808)								o1->_validate = null();
HXDLIN(1808)								o1->_invalidate = null();
            							}
HXDLIN(1808)							o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1808)							::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            						}
            					}
            				}
            			}
HXDLIN(1808)			if (hx::IsNull( this->zpp_inner->wrap_pos )) {
HXLINE(1808)				this->zpp_inner->setupPosition();
            			}
            		}
HXLINE(1809)		{
HXLINE(1809)			bool _hx_tmp12;
HXDLIN(1809)			if (hx::IsNotNull( del )) {
HXLINE(1809)				_hx_tmp12 = del->zpp_disp;
            			}
            			else {
HXLINE(1809)				_hx_tmp12 = false;
            			}
HXDLIN(1809)			if (_hx_tmp12) {
HXLINE(1809)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1809)			{
HXLINE(1809)				 ::zpp_nape::geom::ZPP_Vec2 _this9 = del->zpp_inner;
HXDLIN(1809)				if (_this9->_immutable) {
HXLINE(1809)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1809)				if (hx::IsNotNull( _this9->_isimmutable )) {
HXLINE(1809)					_this9->_isimmutable();
            				}
            			}
HXDLIN(1809)			if (del->zpp_inner->_inuse) {
HXLINE(1809)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1809)			 ::zpp_nape::geom::ZPP_Vec2 inner1 = del->zpp_inner;
HXDLIN(1809)			del->zpp_inner->outer = null();
HXDLIN(1809)			del->zpp_inner = null();
HXDLIN(1809)			{
HXLINE(1809)				 ::nape::geom::Vec2 o2 = del;
HXDLIN(1809)				o2->zpp_pool = null();
HXDLIN(1809)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1809)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            				}
            				else {
HXLINE(1809)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            				}
HXDLIN(1809)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN(1809)				o2->zpp_disp = true;
            			}
HXDLIN(1809)			{
HXLINE(1809)				 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN(1809)				{
HXLINE(1809)					if (hx::IsNotNull( o3->outer )) {
HXLINE(1809)						o3->outer->zpp_inner = null();
HXDLIN(1809)						o3->outer = null();
            					}
HXDLIN(1809)					o3->_isimmutable = null();
HXDLIN(1809)					o3->_validate = null();
HXDLIN(1809)					o3->_invalidate = null();
            				}
HXDLIN(1809)				o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1809)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            			}
            		}
HXLINE(1810)		{
HXLINE(1810)			 ::nape::phys::Body _g = hx::ObjectPtr<OBJ_>(this);
HXDLIN(1810)			{
HXLINE(1810)				Float rotation = (_g->zpp_inner->rot + angle);
HXDLIN(1810)				{
HXLINE(1810)					_g->zpp_inner->immutable_midstep(HX_("Body::rotation",40,9d,24,6b));
HXDLIN(1810)					if (_g->zpp_inner->world) {
HXLINE(1810)						HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            					}
HXDLIN(1810)					bool _hx_tmp13;
HXDLIN(1810)					if ((_g->zpp_inner->type == 1)) {
HXLINE(1810)						_hx_tmp13 = hx::IsNotNull( _g->zpp_inner->space );
            					}
            					else {
HXLINE(1810)						_hx_tmp13 = false;
            					}
HXDLIN(1810)					if (_hx_tmp13) {
HXLINE(1810)						HX_STACK_DO_THROW(HX_("Error: Static objects cannot be rotated once inside a Space",1b,e2,01,c9));
            					}
HXDLIN(1810)					if ((_g->zpp_inner->rot != rotation)) {
HXLINE(1810)						if ((rotation != rotation)) {
HXLINE(1810)							HX_STACK_DO_THROW(HX_("Error: Body::rotation cannot be NaN",a9,a5,47,9c));
            						}
HXDLIN(1810)						_g->zpp_inner->rot = rotation;
HXDLIN(1810)						{
HXLINE(1810)							 ::zpp_nape::phys::ZPP_Body _this10 = _g->zpp_inner;
HXDLIN(1810)							_this10->zip_axis = true;
HXDLIN(1810)							{
HXLINE(1810)								 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = _this10->shapes->head;
HXDLIN(1810)								while(hx::IsNotNull( cx_ite )){
HXLINE(1810)									 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXDLIN(1810)									{
HXLINE(1810)										if ((s->type == 1)) {
HXLINE(1810)											s->polygon->invalidate_gverts();
HXDLIN(1810)											s->polygon->invalidate_gaxi();
            										}
HXDLIN(1810)										s->invalidate_worldCOM();
            									}
HXDLIN(1810)									cx_ite = cx_ite->next;
            								}
            							}
HXDLIN(1810)							_this10->zip_worldCOM = true;
            						}
HXDLIN(1810)						_g->zpp_inner->wake();
            					}
            				}
            			}
            		}
HXLINE(1811)		centre->zpp_inner->weak = weak;
HXLINE(1812)		if (centre->zpp_inner->weak) {
HXLINE(1816)			bool _hx_tmp14;
HXDLIN(1816)			if (hx::IsNotNull( centre )) {
HXLINE(1816)				_hx_tmp14 = centre->zpp_disp;
            			}
            			else {
HXLINE(1816)				_hx_tmp14 = false;
            			}
HXDLIN(1816)			if (_hx_tmp14) {
HXLINE(1816)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(1816)			{
HXLINE(1816)				 ::zpp_nape::geom::ZPP_Vec2 _this11 = centre->zpp_inner;
HXDLIN(1816)				if (_this11->_immutable) {
HXLINE(1816)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(1816)				if (hx::IsNotNull( _this11->_isimmutable )) {
HXLINE(1816)					_this11->_isimmutable();
            				}
            			}
HXDLIN(1816)			if (centre->zpp_inner->_inuse) {
HXLINE(1816)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(1816)			 ::zpp_nape::geom::ZPP_Vec2 inner2 = centre->zpp_inner;
HXDLIN(1816)			centre->zpp_inner->outer = null();
HXDLIN(1816)			centre->zpp_inner = null();
HXDLIN(1816)			{
HXLINE(1816)				 ::nape::geom::Vec2 o4 = centre;
HXDLIN(1816)				o4->zpp_pool = null();
HXDLIN(1816)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1816)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o4;
            				}
            				else {
HXLINE(1816)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o4;
            				}
HXDLIN(1816)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o4;
HXDLIN(1816)				o4->zpp_disp = true;
            			}
HXDLIN(1816)			{
HXLINE(1816)				 ::zpp_nape::geom::ZPP_Vec2 o5 = inner2;
HXDLIN(1816)				{
HXLINE(1816)					if (hx::IsNotNull( o5->outer )) {
HXLINE(1816)						o5->outer->zpp_inner = null();
HXDLIN(1816)						o5->outer = null();
            					}
HXDLIN(1816)					o5->_isimmutable = null();
HXDLIN(1816)					o5->_validate = null();
HXDLIN(1816)					o5->_invalidate = null();
            				}
HXDLIN(1816)				o5->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1816)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o5;
            			}
            		}
HXLINE(1823)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,rotate,return )

 ::nape::phys::Body Body_obj::setShapeMaterials( ::nape::phys::Material material){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1834_setShapeMaterials)
HXLINE(1835)		this->zpp_inner->immutable_midstep(HX_("Body::setShapeMaterials()",4c,b9,cd,69));
HXLINE(1837)		if (this->zpp_inner->world) {
HXLINE(1837)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1839)		{
HXLINE(1840)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1841)			while(hx::IsNotNull( cx_ite )){
HXLINE(1842)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1843)				{
HXLINE(1843)					 ::nape::shape::Shape _this = s->outer;
HXDLIN(1843)					{
HXLINE(1843)						_this->zpp_inner->immutable_midstep(HX_("Shape::material",a8,cd,a4,b9));
HXDLIN(1843)						if (hx::IsNull( material )) {
HXLINE(1843)							HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape material",9d,c0,89,99));
            						}
HXDLIN(1843)						_this->zpp_inner->setMaterial(material->zpp_inner);
            					}
HXDLIN(1843)					_this->zpp_inner->material->wrapper();
            				}
HXLINE(1844)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1847)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,setShapeMaterials,return )

 ::nape::phys::Body Body_obj::setShapeFilters( ::nape::dynamics::InteractionFilter filter){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1858_setShapeFilters)
HXLINE(1859)		this->zpp_inner->immutable_midstep(HX_("Body::setShapeFilters()",1b,11,a6,d2));
HXLINE(1861)		if (this->zpp_inner->world) {
HXLINE(1861)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1863)		{
HXLINE(1864)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1865)			while(hx::IsNotNull( cx_ite )){
HXLINE(1866)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1867)				{
HXLINE(1867)					 ::nape::shape::Shape _this = s->outer;
HXDLIN(1867)					{
HXLINE(1867)						_this->zpp_inner->immutable_midstep(HX_("Shape::filter",79,9e,c6,67));
HXDLIN(1867)						if (hx::IsNull( filter )) {
HXLINE(1867)							HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape filter",2e,7a,75,59));
            						}
HXDLIN(1867)						_this->zpp_inner->setFilter(filter->zpp_inner);
            					}
HXDLIN(1867)					_this->zpp_inner->filter->wrapper();
            				}
HXLINE(1868)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1871)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,setShapeFilters,return )

 ::nape::phys::Body Body_obj::setShapeFluidProperties( ::nape::phys::FluidProperties fluidProperties){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1882_setShapeFluidProperties)
HXLINE(1883)		this->zpp_inner->immutable_midstep(HX_("Body::setShapeFluidProperties()",7d,2d,a4,e7));
HXLINE(1885)		if (this->zpp_inner->world) {
HXLINE(1885)			HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            		}
HXLINE(1887)		{
HXLINE(1888)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(1889)			while(hx::IsNotNull( cx_ite )){
HXLINE(1890)				 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(1891)				{
HXLINE(1891)					 ::nape::shape::Shape _this = s->outer;
HXDLIN(1891)					{
HXLINE(1891)						if (hx::IsNull( fluidProperties )) {
HXLINE(1891)							HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape fluidProperties, disable fluids by setting fluidEnabled to false",b2,c7,28,b5));
            						}
HXDLIN(1891)						_this->zpp_inner->setFluid(fluidProperties->zpp_inner);
            					}
HXDLIN(1891)					{
HXLINE(1891)						_this->zpp_inner->immutable_midstep(HX_("Shape::fluidProperties",bc,2b,f3,66));
HXDLIN(1891)						if (hx::IsNull( _this->zpp_inner->fluidProperties )) {
HXLINE(1891)							 ::zpp_nape::shape::ZPP_Shape _this1 = _this->zpp_inner;
HXDLIN(1891)							_this1->setFluid( ::nape::phys::FluidProperties_obj::__alloc( HX_CTX ,null(),null())->zpp_inner);
            						}
HXDLIN(1891)						_this->zpp_inner->fluidProperties->wrapper();
            					}
            				}
HXLINE(1892)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(1895)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,setShapeFluidProperties,return )

 ::nape::geom::Vec2 Body_obj::get_localCOM(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1907_get_localCOM)
HXLINE(1909)		if (this->zpp_inner->world) {
HXLINE(1909)			HX_STACK_DO_THROW((HX_("Error: Space::world has no ",d3,43,94,b2) + HX_("localCOM",96,c7,df,df)));
            		}
HXLINE(1911)		if (hx::IsNull( this->zpp_inner->wrap_localCOM )) {
HXLINE(1912)			Float x = this->zpp_inner->localCOMx;
HXDLIN(1912)			Float y = this->zpp_inner->localCOMy;
HXDLIN(1912)			bool _hx_tmp;
HXDLIN(1912)			if ((x == x)) {
HXLINE(1912)				_hx_tmp = (y != y);
            			}
            			else {
HXLINE(1912)				_hx_tmp = true;
            			}
HXDLIN(1912)			if (_hx_tmp) {
HXLINE(1912)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1912)			 ::nape::geom::Vec2 ret;
HXDLIN(1912)			if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1912)				ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            			}
            			else {
HXLINE(1912)				ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1912)				::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1912)				ret->zpp_pool = null();
HXDLIN(1912)				ret->zpp_disp = false;
HXDLIN(1912)				if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1912)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            				}
            			}
HXDLIN(1912)			if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1912)				 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1912)				{
HXLINE(1912)					if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1912)						ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            					}
            					else {
HXLINE(1912)						ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1912)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1912)						ret1->next = null();
            					}
HXDLIN(1912)					ret1->weak = false;
            				}
HXDLIN(1912)				ret1->_immutable = false;
HXDLIN(1912)				{
HXLINE(1912)					ret1->x = x;
HXDLIN(1912)					ret1->y = y;
            				}
HXDLIN(1912)				ret->zpp_inner = ret1;
HXDLIN(1912)				ret->zpp_inner->outer = ret;
            			}
            			else {
HXLINE(1912)				bool _hx_tmp1;
HXDLIN(1912)				if (hx::IsNotNull( ret )) {
HXLINE(1912)					_hx_tmp1 = ret->zpp_disp;
            				}
            				else {
HXLINE(1912)					_hx_tmp1 = false;
            				}
HXDLIN(1912)				if (_hx_tmp1) {
HXLINE(1912)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1912)				{
HXLINE(1912)					 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN(1912)					if (_this->_immutable) {
HXLINE(1912)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN(1912)					if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(1912)						_this->_isimmutable();
            					}
            				}
HXDLIN(1912)				bool _hx_tmp2;
HXDLIN(1912)				if ((x == x)) {
HXLINE(1912)					_hx_tmp2 = (y != y);
            				}
            				else {
HXLINE(1912)					_hx_tmp2 = true;
            				}
HXDLIN(1912)				if (_hx_tmp2) {
HXLINE(1912)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN(1912)				bool _hx_tmp3;
HXDLIN(1912)				bool _hx_tmp4;
HXDLIN(1912)				if (hx::IsNotNull( ret )) {
HXLINE(1912)					_hx_tmp4 = ret->zpp_disp;
            				}
            				else {
HXLINE(1912)					_hx_tmp4 = false;
            				}
HXDLIN(1912)				if (_hx_tmp4) {
HXLINE(1912)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1912)				{
HXLINE(1912)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN(1912)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1912)						_this1->_validate();
            					}
            				}
HXDLIN(1912)				if ((ret->zpp_inner->x == x)) {
HXLINE(1912)					bool _hx_tmp5;
HXDLIN(1912)					if (hx::IsNotNull( ret )) {
HXLINE(1912)						_hx_tmp5 = ret->zpp_disp;
            					}
            					else {
HXLINE(1912)						_hx_tmp5 = false;
            					}
HXDLIN(1912)					if (_hx_tmp5) {
HXLINE(1912)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1912)					{
HXLINE(1912)						 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN(1912)						if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1912)							_this2->_validate();
            						}
            					}
HXDLIN(1912)					_hx_tmp3 = (ret->zpp_inner->y == y);
            				}
            				else {
HXLINE(1912)					_hx_tmp3 = false;
            				}
HXDLIN(1912)				if (!(_hx_tmp3)) {
HXLINE(1912)					{
HXLINE(1912)						ret->zpp_inner->x = x;
HXDLIN(1912)						ret->zpp_inner->y = y;
            					}
HXDLIN(1912)					{
HXLINE(1912)						 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN(1912)						if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE(1912)							_this3->_invalidate(_this3);
            						}
            					}
            				}
            			}
HXDLIN(1912)			ret->zpp_inner->weak = false;
HXDLIN(1912)			this->zpp_inner->wrap_localCOM = ret;
HXLINE(1913)			this->zpp_inner->wrap_localCOM->zpp_inner->_inuse = true;
HXLINE(1914)			this->zpp_inner->wrap_localCOM->zpp_inner->_immutable = true;
HXLINE(1915)			this->zpp_inner->wrap_localCOM->zpp_inner->_validate = this->zpp_inner->getlocalCOM_dyn();
            		}
HXLINE(1917)		return this->zpp_inner->wrap_localCOM;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_localCOM,return )

 ::nape::geom::Vec2 Body_obj::get_worldCOM(){
            	HX_GC_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1929_get_worldCOM)
HXLINE(1931)		if (this->zpp_inner->world) {
HXLINE(1931)			HX_STACK_DO_THROW((HX_("Error: Space::world has no ",d3,43,94,b2) + HX_("worldCOM",0f,c5,83,a4)));
            		}
HXLINE(1933)		if (hx::IsNull( this->zpp_inner->wrap_worldCOM )) {
HXLINE(1934)			Float x = this->zpp_inner->worldCOMx;
HXDLIN(1934)			Float y = this->zpp_inner->worldCOMy;
HXDLIN(1934)			bool _hx_tmp;
HXDLIN(1934)			if ((x == x)) {
HXLINE(1934)				_hx_tmp = (y != y);
            			}
            			else {
HXLINE(1934)				_hx_tmp = true;
            			}
HXDLIN(1934)			if (_hx_tmp) {
HXLINE(1934)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(1934)			 ::nape::geom::Vec2 ret;
HXDLIN(1934)			if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE(1934)				ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            			}
            			else {
HXLINE(1934)				ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN(1934)				::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN(1934)				ret->zpp_pool = null();
HXDLIN(1934)				ret->zpp_disp = false;
HXDLIN(1934)				if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(1934)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            				}
            			}
HXDLIN(1934)			if (hx::IsNull( ret->zpp_inner )) {
HXLINE(1934)				 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN(1934)				{
HXLINE(1934)					if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE(1934)						ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            					}
            					else {
HXLINE(1934)						ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(1934)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN(1934)						ret1->next = null();
            					}
HXDLIN(1934)					ret1->weak = false;
            				}
HXDLIN(1934)				ret1->_immutable = false;
HXDLIN(1934)				{
HXLINE(1934)					ret1->x = x;
HXDLIN(1934)					ret1->y = y;
            				}
HXDLIN(1934)				ret->zpp_inner = ret1;
HXDLIN(1934)				ret->zpp_inner->outer = ret;
            			}
            			else {
HXLINE(1934)				bool _hx_tmp1;
HXDLIN(1934)				if (hx::IsNotNull( ret )) {
HXLINE(1934)					_hx_tmp1 = ret->zpp_disp;
            				}
            				else {
HXLINE(1934)					_hx_tmp1 = false;
            				}
HXDLIN(1934)				if (_hx_tmp1) {
HXLINE(1934)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1934)				{
HXLINE(1934)					 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN(1934)					if (_this->_immutable) {
HXLINE(1934)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN(1934)					if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(1934)						_this->_isimmutable();
            					}
            				}
HXDLIN(1934)				bool _hx_tmp2;
HXDLIN(1934)				if ((x == x)) {
HXLINE(1934)					_hx_tmp2 = (y != y);
            				}
            				else {
HXLINE(1934)					_hx_tmp2 = true;
            				}
HXDLIN(1934)				if (_hx_tmp2) {
HXLINE(1934)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN(1934)				bool _hx_tmp3;
HXDLIN(1934)				bool _hx_tmp4;
HXDLIN(1934)				if (hx::IsNotNull( ret )) {
HXLINE(1934)					_hx_tmp4 = ret->zpp_disp;
            				}
            				else {
HXLINE(1934)					_hx_tmp4 = false;
            				}
HXDLIN(1934)				if (_hx_tmp4) {
HXLINE(1934)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(1934)				{
HXLINE(1934)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN(1934)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1934)						_this1->_validate();
            					}
            				}
HXDLIN(1934)				if ((ret->zpp_inner->x == x)) {
HXLINE(1934)					bool _hx_tmp5;
HXDLIN(1934)					if (hx::IsNotNull( ret )) {
HXLINE(1934)						_hx_tmp5 = ret->zpp_disp;
            					}
            					else {
HXLINE(1934)						_hx_tmp5 = false;
            					}
HXDLIN(1934)					if (_hx_tmp5) {
HXLINE(1934)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(1934)					{
HXLINE(1934)						 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN(1934)						if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1934)							_this2->_validate();
            						}
            					}
HXDLIN(1934)					_hx_tmp3 = (ret->zpp_inner->y == y);
            				}
            				else {
HXLINE(1934)					_hx_tmp3 = false;
            				}
HXDLIN(1934)				if (!(_hx_tmp3)) {
HXLINE(1934)					{
HXLINE(1934)						ret->zpp_inner->x = x;
HXDLIN(1934)						ret->zpp_inner->y = y;
            					}
HXDLIN(1934)					{
HXLINE(1934)						 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN(1934)						if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE(1934)							_this3->_invalidate(_this3);
            						}
            					}
            				}
            			}
HXDLIN(1934)			ret->zpp_inner->weak = false;
HXDLIN(1934)			this->zpp_inner->wrap_worldCOM = ret;
HXLINE(1935)			this->zpp_inner->wrap_worldCOM->zpp_inner->_inuse = true;
HXLINE(1936)			this->zpp_inner->wrap_worldCOM->zpp_inner->_immutable = true;
HXLINE(1937)			this->zpp_inner->wrap_worldCOM->zpp_inner->_validate = this->zpp_inner->getworldCOM_dyn();
            		}
HXLINE(1939)		return this->zpp_inner->wrap_worldCOM;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,get_worldCOM,return )

 ::nape::geom::Vec3 Body_obj::normalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_1954_normalImpulse)
HXLINE(1955)		Float retx = ( (Float)(0) );
HXLINE(1956)		Float rety = ( (Float)(0) );
HXLINE(1973)		Float retz = ( (Float)(0) );
HXLINE(1974)		{
HXLINE(1975)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(1976)			{
HXLINE(1976)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(1976)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(1976)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(1976)				while(true){
HXLINE(1976)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(1976)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(1976)					_g->zpp_critical = true;
HXDLIN(1976)					bool _hx_tmp;
HXDLIN(1976)					if ((_g->zpp_i < length)) {
HXLINE(1976)						_hx_tmp = true;
            					}
            					else {
HXLINE(1976)						{
HXLINE(1976)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(1976)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(1976)							_g->zpp_inner = null();
            						}
HXDLIN(1976)						_hx_tmp = false;
            					}
HXDLIN(1976)					if (!(_hx_tmp)) {
HXLINE(1976)						goto _hx_goto_94;
            					}
HXDLIN(1976)					_g->zpp_critical = false;
HXDLIN(1976)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(1977)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(1978)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(1978)						continue;
            					}
HXLINE(1979)					bool _hx_tmp1;
HXDLIN(1979)					bool _hx_tmp2;
HXDLIN(1979)					if (hx::IsNotNull( body )) {
HXLINE(1979)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(1979)						_hx_tmp2 = false;
            					}
HXDLIN(1979)					if (_hx_tmp2) {
HXLINE(1979)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(1979)						_hx_tmp1 = false;
            					}
HXDLIN(1979)					if (_hx_tmp1) {
HXLINE(1979)						continue;
            					}
HXLINE(1980)					{
HXLINE(1981)						 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(1981)						 ::nape::dynamics::CollisionArbiter imp;
HXDLIN(1981)						if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(1981)							imp = _this->zpp_inner->colarb->outer_zn;
            						}
            						else {
HXLINE(1981)							imp = null();
            						}
HXDLIN(1981)						 ::nape::geom::Vec3 imp1 = imp->normalImpulse(hx::ObjectPtr<OBJ_>(this),freshOnly);
HXLINE(1982)						{
HXLINE(1983)							int t = 1;
HXLINE(1984)							{
HXLINE(1985)								int t1 = t;
HXLINE(1994)								bool retx1;
HXDLIN(1994)								if (hx::IsNotNull( imp1 )) {
HXLINE(1994)									retx1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(1994)									retx1 = false;
            								}
HXDLIN(1994)								if (retx1) {
HXLINE(1994)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(1994)								{
HXLINE(1994)									 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp1->zpp_inner;
HXDLIN(1994)									if (hx::IsNotNull( _this1->_validate )) {
HXLINE(1994)										_this1->_validate();
            									}
            								}
HXDLIN(1994)								retx = (retx + (imp1->zpp_inner->x * ( (Float)(t1) )));
HXLINE(1995)								bool rety1;
HXDLIN(1995)								if (hx::IsNotNull( imp1 )) {
HXLINE(1995)									rety1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(1995)									rety1 = false;
            								}
HXDLIN(1995)								if (rety1) {
HXLINE(1995)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(1995)								{
HXLINE(1995)									 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp1->zpp_inner;
HXDLIN(1995)									if (hx::IsNotNull( _this2->_validate )) {
HXLINE(1995)										_this2->_validate();
            									}
            								}
HXDLIN(1995)								rety = (rety + (imp1->zpp_inner->y * ( (Float)(t1) )));
            							}
HXLINE(1997)							bool retz1;
HXDLIN(1997)							if (hx::IsNotNull( imp1 )) {
HXLINE(1997)								retz1 = imp1->zpp_disp;
            							}
            							else {
HXLINE(1997)								retz1 = false;
            							}
HXDLIN(1997)							if (retz1) {
HXLINE(1997)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(1997)							{
HXLINE(1997)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(1997)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(1997)									_this3->_validate();
            								}
            							}
HXDLIN(1997)							retz = (retz + (imp1->zpp_inner->z * ( (Float)(t) )));
            						}
HXLINE(1999)						imp1->dispose();
            					}
            				}
            				_hx_goto_94:;
            			}
            		}
HXLINE(2003)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,normalImpulse,return )

 ::nape::geom::Vec3 Body_obj::tangentImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2018_tangentImpulse)
HXLINE(2019)		Float retx = ( (Float)(0) );
HXLINE(2020)		Float rety = ( (Float)(0) );
HXLINE(2037)		Float retz = ( (Float)(0) );
HXLINE(2038)		{
HXLINE(2039)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2040)			{
HXLINE(2040)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2040)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(2040)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2040)				while(true){
HXLINE(2040)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2040)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(2040)					_g->zpp_critical = true;
HXDLIN(2040)					bool _hx_tmp;
HXDLIN(2040)					if ((_g->zpp_i < length)) {
HXLINE(2040)						_hx_tmp = true;
            					}
            					else {
HXLINE(2040)						{
HXLINE(2040)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2040)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2040)							_g->zpp_inner = null();
            						}
HXDLIN(2040)						_hx_tmp = false;
            					}
HXDLIN(2040)					if (!(_hx_tmp)) {
HXLINE(2040)						goto _hx_goto_96;
            					}
HXDLIN(2040)					_g->zpp_critical = false;
HXDLIN(2040)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2041)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2042)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(2042)						continue;
            					}
HXLINE(2043)					bool _hx_tmp1;
HXDLIN(2043)					bool _hx_tmp2;
HXDLIN(2043)					if (hx::IsNotNull( body )) {
HXLINE(2043)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(2043)						_hx_tmp2 = false;
            					}
HXDLIN(2043)					if (_hx_tmp2) {
HXLINE(2043)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(2043)						_hx_tmp1 = false;
            					}
HXDLIN(2043)					if (_hx_tmp1) {
HXLINE(2043)						continue;
            					}
HXLINE(2044)					{
HXLINE(2045)						 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(2045)						 ::nape::dynamics::CollisionArbiter imp;
HXDLIN(2045)						if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(2045)							imp = _this->zpp_inner->colarb->outer_zn;
            						}
            						else {
HXLINE(2045)							imp = null();
            						}
HXDLIN(2045)						 ::nape::geom::Vec3 imp1 = imp->tangentImpulse(hx::ObjectPtr<OBJ_>(this),freshOnly);
HXLINE(2046)						{
HXLINE(2047)							int t = 1;
HXLINE(2048)							{
HXLINE(2049)								int t1 = t;
HXLINE(2058)								bool retx1;
HXDLIN(2058)								if (hx::IsNotNull( imp1 )) {
HXLINE(2058)									retx1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2058)									retx1 = false;
            								}
HXDLIN(2058)								if (retx1) {
HXLINE(2058)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2058)								{
HXLINE(2058)									 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp1->zpp_inner;
HXDLIN(2058)									if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2058)										_this1->_validate();
            									}
            								}
HXDLIN(2058)								retx = (retx + (imp1->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2059)								bool rety1;
HXDLIN(2059)								if (hx::IsNotNull( imp1 )) {
HXLINE(2059)									rety1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2059)									rety1 = false;
            								}
HXDLIN(2059)								if (rety1) {
HXLINE(2059)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2059)								{
HXLINE(2059)									 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp1->zpp_inner;
HXDLIN(2059)									if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2059)										_this2->_validate();
            									}
            								}
HXDLIN(2059)								rety = (rety + (imp1->zpp_inner->y * ( (Float)(t1) )));
            							}
HXLINE(2061)							bool retz1;
HXDLIN(2061)							if (hx::IsNotNull( imp1 )) {
HXLINE(2061)								retz1 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2061)								retz1 = false;
            							}
HXDLIN(2061)							if (retz1) {
HXLINE(2061)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2061)							{
HXLINE(2061)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(2061)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(2061)									_this3->_validate();
            								}
            							}
HXDLIN(2061)							retz = (retz + (imp1->zpp_inner->z * ( (Float)(t) )));
            						}
HXLINE(2063)						imp1->dispose();
            					}
            				}
            				_hx_goto_96:;
            			}
            		}
HXLINE(2067)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,tangentImpulse,return )

 ::nape::geom::Vec3 Body_obj::totalContactsImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2082_totalContactsImpulse)
HXLINE(2083)		Float retx = ( (Float)(0) );
HXLINE(2084)		Float rety = ( (Float)(0) );
HXLINE(2101)		Float retz = ( (Float)(0) );
HXLINE(2102)		{
HXLINE(2103)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2104)			{
HXLINE(2104)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2104)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(2104)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2104)				while(true){
HXLINE(2104)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2104)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(2104)					_g->zpp_critical = true;
HXDLIN(2104)					bool _hx_tmp;
HXDLIN(2104)					if ((_g->zpp_i < length)) {
HXLINE(2104)						_hx_tmp = true;
            					}
            					else {
HXLINE(2104)						{
HXLINE(2104)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2104)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2104)							_g->zpp_inner = null();
            						}
HXDLIN(2104)						_hx_tmp = false;
            					}
HXDLIN(2104)					if (!(_hx_tmp)) {
HXLINE(2104)						goto _hx_goto_98;
            					}
HXDLIN(2104)					_g->zpp_critical = false;
HXDLIN(2104)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2105)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2106)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(2106)						continue;
            					}
HXLINE(2107)					bool _hx_tmp1;
HXDLIN(2107)					bool _hx_tmp2;
HXDLIN(2107)					if (hx::IsNotNull( body )) {
HXLINE(2107)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(2107)						_hx_tmp2 = false;
            					}
HXDLIN(2107)					if (_hx_tmp2) {
HXLINE(2107)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(2107)						_hx_tmp1 = false;
            					}
HXDLIN(2107)					if (_hx_tmp1) {
HXLINE(2107)						continue;
            					}
HXLINE(2108)					{
HXLINE(2109)						 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(2109)						 ::nape::dynamics::CollisionArbiter imp;
HXDLIN(2109)						if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(2109)							imp = _this->zpp_inner->colarb->outer_zn;
            						}
            						else {
HXLINE(2109)							imp = null();
            						}
HXDLIN(2109)						 ::nape::geom::Vec3 imp1 = imp->totalImpulse(hx::ObjectPtr<OBJ_>(this),freshOnly);
HXLINE(2110)						{
HXLINE(2111)							int t = 1;
HXLINE(2112)							{
HXLINE(2113)								int t1 = t;
HXLINE(2122)								bool retx1;
HXDLIN(2122)								if (hx::IsNotNull( imp1 )) {
HXLINE(2122)									retx1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2122)									retx1 = false;
            								}
HXDLIN(2122)								if (retx1) {
HXLINE(2122)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2122)								{
HXLINE(2122)									 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp1->zpp_inner;
HXDLIN(2122)									if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2122)										_this1->_validate();
            									}
            								}
HXDLIN(2122)								retx = (retx + (imp1->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2123)								bool rety1;
HXDLIN(2123)								if (hx::IsNotNull( imp1 )) {
HXLINE(2123)									rety1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2123)									rety1 = false;
            								}
HXDLIN(2123)								if (rety1) {
HXLINE(2123)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2123)								{
HXLINE(2123)									 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp1->zpp_inner;
HXDLIN(2123)									if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2123)										_this2->_validate();
            									}
            								}
HXDLIN(2123)								rety = (rety + (imp1->zpp_inner->y * ( (Float)(t1) )));
            							}
HXLINE(2125)							bool retz1;
HXDLIN(2125)							if (hx::IsNotNull( imp1 )) {
HXLINE(2125)								retz1 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2125)								retz1 = false;
            							}
HXDLIN(2125)							if (retz1) {
HXLINE(2125)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2125)							{
HXLINE(2125)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(2125)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(2125)									_this3->_validate();
            								}
            							}
HXDLIN(2125)							retz = (retz + (imp1->zpp_inner->z * ( (Float)(t) )));
            						}
HXLINE(2127)						imp1->dispose();
            					}
            				}
            				_hx_goto_98:;
            			}
            		}
HXLINE(2131)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,totalContactsImpulse,return )

Float Body_obj::rollingImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2146_rollingImpulse)
HXLINE(2147)		Float ret = ((Float)0.0);
HXLINE(2148)		{
HXLINE(2149)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2150)			{
HXLINE(2150)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2150)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(2150)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2150)				while(true){
HXLINE(2150)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2150)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(2150)					_g->zpp_critical = true;
HXDLIN(2150)					bool _hx_tmp;
HXDLIN(2150)					if ((_g->zpp_i < length)) {
HXLINE(2150)						_hx_tmp = true;
            					}
            					else {
HXLINE(2150)						{
HXLINE(2150)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2150)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2150)							_g->zpp_inner = null();
            						}
HXDLIN(2150)						_hx_tmp = false;
            					}
HXDLIN(2150)					if (!(_hx_tmp)) {
HXLINE(2150)						goto _hx_goto_100;
            					}
HXDLIN(2150)					_g->zpp_critical = false;
HXDLIN(2150)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2151)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2152)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(2152)						continue;
            					}
HXLINE(2153)					bool _hx_tmp1;
HXDLIN(2153)					bool _hx_tmp2;
HXDLIN(2153)					if (hx::IsNotNull( body )) {
HXLINE(2153)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(2153)						_hx_tmp2 = false;
            					}
HXDLIN(2153)					if (_hx_tmp2) {
HXLINE(2153)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(2153)						_hx_tmp1 = false;
            					}
HXDLIN(2153)					if (_hx_tmp1) {
HXLINE(2153)						continue;
            					}
HXLINE(2155)					 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(2155)					 ::nape::dynamics::CollisionArbiter ret1;
HXDLIN(2155)					if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::COL)) {
HXLINE(2155)						ret1 = _this->zpp_inner->colarb->outer_zn;
            					}
            					else {
HXLINE(2155)						ret1 = null();
            					}
HXDLIN(2155)					ret = (ret + ret1->rollingImpulse(hx::ObjectPtr<OBJ_>(this),freshOnly));
            				}
            				_hx_goto_100:;
            			}
            		}
HXLINE(2159)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,rollingImpulse,return )

 ::nape::geom::Vec3 Body_obj::buoyancyImpulse( ::nape::phys::Body body){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2172_buoyancyImpulse)
HXLINE(2173)		Float retx = ( (Float)(0) );
HXLINE(2174)		Float rety = ( (Float)(0) );
HXLINE(2191)		Float retz = ( (Float)(0) );
HXLINE(2192)		{
HXLINE(2193)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2194)			{
HXLINE(2194)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2194)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(2194)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2194)				while(true){
HXLINE(2194)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2194)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(2194)					_g->zpp_critical = true;
HXDLIN(2194)					bool _hx_tmp;
HXDLIN(2194)					if ((_g->zpp_i < length)) {
HXLINE(2194)						_hx_tmp = true;
            					}
            					else {
HXLINE(2194)						{
HXLINE(2194)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2194)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2194)							_g->zpp_inner = null();
            						}
HXDLIN(2194)						_hx_tmp = false;
            					}
HXDLIN(2194)					if (!(_hx_tmp)) {
HXLINE(2194)						goto _hx_goto_102;
            					}
HXDLIN(2194)					_g->zpp_critical = false;
HXDLIN(2194)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2195)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2196)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID)) {
HXLINE(2196)						continue;
            					}
HXLINE(2197)					bool _hx_tmp1;
HXDLIN(2197)					bool _hx_tmp2;
HXDLIN(2197)					if (hx::IsNotNull( body )) {
HXLINE(2197)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(2197)						_hx_tmp2 = false;
            					}
HXDLIN(2197)					if (_hx_tmp2) {
HXLINE(2197)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(2197)						_hx_tmp1 = false;
            					}
HXDLIN(2197)					if (_hx_tmp1) {
HXLINE(2197)						continue;
            					}
HXLINE(2198)					{
HXLINE(2199)						 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(2199)						 ::nape::dynamics::FluidArbiter imp;
HXDLIN(2199)						if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID)) {
HXLINE(2199)							imp = _this->zpp_inner->fluidarb->outer_zn;
            						}
            						else {
HXLINE(2199)							imp = null();
            						}
HXDLIN(2199)						 ::nape::geom::Vec3 imp1 = imp->buoyancyImpulse(hx::ObjectPtr<OBJ_>(this));
HXLINE(2200)						{
HXLINE(2201)							int t = 1;
HXLINE(2202)							{
HXLINE(2203)								int t1 = t;
HXLINE(2212)								bool retx1;
HXDLIN(2212)								if (hx::IsNotNull( imp1 )) {
HXLINE(2212)									retx1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2212)									retx1 = false;
            								}
HXDLIN(2212)								if (retx1) {
HXLINE(2212)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2212)								{
HXLINE(2212)									 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp1->zpp_inner;
HXDLIN(2212)									if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2212)										_this1->_validate();
            									}
            								}
HXDLIN(2212)								retx = (retx + (imp1->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2213)								bool rety1;
HXDLIN(2213)								if (hx::IsNotNull( imp1 )) {
HXLINE(2213)									rety1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2213)									rety1 = false;
            								}
HXDLIN(2213)								if (rety1) {
HXLINE(2213)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2213)								{
HXLINE(2213)									 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp1->zpp_inner;
HXDLIN(2213)									if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2213)										_this2->_validate();
            									}
            								}
HXDLIN(2213)								rety = (rety + (imp1->zpp_inner->y * ( (Float)(t1) )));
            							}
HXLINE(2215)							bool retz1;
HXDLIN(2215)							if (hx::IsNotNull( imp1 )) {
HXLINE(2215)								retz1 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2215)								retz1 = false;
            							}
HXDLIN(2215)							if (retz1) {
HXLINE(2215)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2215)							{
HXLINE(2215)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(2215)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(2215)									_this3->_validate();
            								}
            							}
HXDLIN(2215)							retz = (retz + (imp1->zpp_inner->z * ( (Float)(t) )));
            						}
HXLINE(2217)						imp1->dispose();
            					}
            				}
            				_hx_goto_102:;
            			}
            		}
HXLINE(2221)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,buoyancyImpulse,return )

 ::nape::geom::Vec3 Body_obj::dragImpulse( ::nape::phys::Body body){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2234_dragImpulse)
HXLINE(2235)		Float retx = ( (Float)(0) );
HXLINE(2236)		Float rety = ( (Float)(0) );
HXLINE(2253)		Float retz = ( (Float)(0) );
HXLINE(2254)		{
HXLINE(2255)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2256)			{
HXLINE(2256)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2256)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(2256)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2256)				while(true){
HXLINE(2256)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2256)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(2256)					_g->zpp_critical = true;
HXDLIN(2256)					bool _hx_tmp;
HXDLIN(2256)					if ((_g->zpp_i < length)) {
HXLINE(2256)						_hx_tmp = true;
            					}
            					else {
HXLINE(2256)						{
HXLINE(2256)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2256)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2256)							_g->zpp_inner = null();
            						}
HXDLIN(2256)						_hx_tmp = false;
            					}
HXDLIN(2256)					if (!(_hx_tmp)) {
HXLINE(2256)						goto _hx_goto_104;
            					}
HXDLIN(2256)					_g->zpp_critical = false;
HXDLIN(2256)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2257)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2258)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID)) {
HXLINE(2258)						continue;
            					}
HXLINE(2259)					bool _hx_tmp1;
HXDLIN(2259)					bool _hx_tmp2;
HXDLIN(2259)					if (hx::IsNotNull( body )) {
HXLINE(2259)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(2259)						_hx_tmp2 = false;
            					}
HXDLIN(2259)					if (_hx_tmp2) {
HXLINE(2259)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(2259)						_hx_tmp1 = false;
            					}
HXDLIN(2259)					if (_hx_tmp1) {
HXLINE(2259)						continue;
            					}
HXLINE(2260)					{
HXLINE(2261)						 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(2261)						 ::nape::dynamics::FluidArbiter imp;
HXDLIN(2261)						if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID)) {
HXLINE(2261)							imp = _this->zpp_inner->fluidarb->outer_zn;
            						}
            						else {
HXLINE(2261)							imp = null();
            						}
HXDLIN(2261)						 ::nape::geom::Vec3 imp1 = imp->dragImpulse(hx::ObjectPtr<OBJ_>(this));
HXLINE(2262)						{
HXLINE(2263)							int t = 1;
HXLINE(2264)							{
HXLINE(2265)								int t1 = t;
HXLINE(2274)								bool retx1;
HXDLIN(2274)								if (hx::IsNotNull( imp1 )) {
HXLINE(2274)									retx1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2274)									retx1 = false;
            								}
HXDLIN(2274)								if (retx1) {
HXLINE(2274)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2274)								{
HXLINE(2274)									 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp1->zpp_inner;
HXDLIN(2274)									if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2274)										_this1->_validate();
            									}
            								}
HXDLIN(2274)								retx = (retx + (imp1->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2275)								bool rety1;
HXDLIN(2275)								if (hx::IsNotNull( imp1 )) {
HXLINE(2275)									rety1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2275)									rety1 = false;
            								}
HXDLIN(2275)								if (rety1) {
HXLINE(2275)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2275)								{
HXLINE(2275)									 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp1->zpp_inner;
HXDLIN(2275)									if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2275)										_this2->_validate();
            									}
            								}
HXDLIN(2275)								rety = (rety + (imp1->zpp_inner->y * ( (Float)(t1) )));
            							}
HXLINE(2277)							bool retz1;
HXDLIN(2277)							if (hx::IsNotNull( imp1 )) {
HXLINE(2277)								retz1 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2277)								retz1 = false;
            							}
HXDLIN(2277)							if (retz1) {
HXLINE(2277)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2277)							{
HXLINE(2277)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(2277)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(2277)									_this3->_validate();
            								}
            							}
HXDLIN(2277)							retz = (retz + (imp1->zpp_inner->z * ( (Float)(t) )));
            						}
HXLINE(2279)						imp1->dispose();
            					}
            				}
            				_hx_goto_104:;
            			}
            		}
HXLINE(2283)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,dragImpulse,return )

 ::nape::geom::Vec3 Body_obj::totalFluidImpulse( ::nape::phys::Body body){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2296_totalFluidImpulse)
HXLINE(2297)		Float retx = ( (Float)(0) );
HXLINE(2298)		Float rety = ( (Float)(0) );
HXLINE(2315)		Float retz = ( (Float)(0) );
HXLINE(2316)		{
HXLINE(2317)			 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2318)			{
HXLINE(2318)				if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2318)					this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            				}
HXDLIN(2318)				 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2318)				while(true){
HXLINE(2318)					_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2318)					int length = _g->zpp_inner->zpp_gl();
HXDLIN(2318)					_g->zpp_critical = true;
HXDLIN(2318)					bool _hx_tmp;
HXDLIN(2318)					if ((_g->zpp_i < length)) {
HXLINE(2318)						_hx_tmp = true;
            					}
            					else {
HXLINE(2318)						{
HXLINE(2318)							_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2318)							::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2318)							_g->zpp_inner = null();
            						}
HXDLIN(2318)						_hx_tmp = false;
            					}
HXDLIN(2318)					if (!(_hx_tmp)) {
HXLINE(2318)						goto _hx_goto_106;
            					}
HXDLIN(2318)					_g->zpp_critical = false;
HXDLIN(2318)					 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2319)					 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2320)					if ((arb->type != ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID)) {
HXLINE(2320)						continue;
            					}
HXLINE(2321)					bool _hx_tmp1;
HXDLIN(2321)					bool _hx_tmp2;
HXDLIN(2321)					if (hx::IsNotNull( body )) {
HXLINE(2321)						_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            					}
            					else {
HXLINE(2321)						_hx_tmp2 = false;
            					}
HXDLIN(2321)					if (_hx_tmp2) {
HXLINE(2321)						_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            					}
            					else {
HXLINE(2321)						_hx_tmp1 = false;
            					}
HXDLIN(2321)					if (_hx_tmp1) {
HXLINE(2321)						continue;
            					}
HXLINE(2322)					{
HXLINE(2323)						 ::nape::dynamics::Arbiter _this = arb->wrapper();
HXDLIN(2323)						 ::nape::dynamics::FluidArbiter imp;
HXDLIN(2323)						if ((_this->zpp_inner->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::FLUID)) {
HXLINE(2323)							imp = _this->zpp_inner->fluidarb->outer_zn;
            						}
            						else {
HXLINE(2323)							imp = null();
            						}
HXDLIN(2323)						 ::nape::geom::Vec3 imp1 = imp->totalImpulse(hx::ObjectPtr<OBJ_>(this),null());
HXLINE(2324)						{
HXLINE(2325)							int t = 1;
HXLINE(2326)							{
HXLINE(2327)								int t1 = t;
HXLINE(2336)								bool retx1;
HXDLIN(2336)								if (hx::IsNotNull( imp1 )) {
HXLINE(2336)									retx1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2336)									retx1 = false;
            								}
HXDLIN(2336)								if (retx1) {
HXLINE(2336)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2336)								{
HXLINE(2336)									 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp1->zpp_inner;
HXDLIN(2336)									if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2336)										_this1->_validate();
            									}
            								}
HXDLIN(2336)								retx = (retx + (imp1->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2337)								bool rety1;
HXDLIN(2337)								if (hx::IsNotNull( imp1 )) {
HXLINE(2337)									rety1 = imp1->zpp_disp;
            								}
            								else {
HXLINE(2337)									rety1 = false;
            								}
HXDLIN(2337)								if (rety1) {
HXLINE(2337)									HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            								}
HXDLIN(2337)								{
HXLINE(2337)									 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp1->zpp_inner;
HXDLIN(2337)									if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2337)										_this2->_validate();
            									}
            								}
HXDLIN(2337)								rety = (rety + (imp1->zpp_inner->y * ( (Float)(t1) )));
            							}
HXLINE(2339)							bool retz1;
HXDLIN(2339)							if (hx::IsNotNull( imp1 )) {
HXLINE(2339)								retz1 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2339)								retz1 = false;
            							}
HXDLIN(2339)							if (retz1) {
HXLINE(2339)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2339)							{
HXLINE(2339)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(2339)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(2339)									_this3->_validate();
            								}
            							}
HXDLIN(2339)							retz = (retz + (imp1->zpp_inner->z * ( (Float)(t) )));
            						}
HXLINE(2341)						imp1->dispose();
            					}
            				}
            				_hx_goto_106:;
            			}
            		}
HXLINE(2345)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,totalFluidImpulse,return )

 ::nape::geom::Vec3 Body_obj::constraintsImpulse(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2353_constraintsImpulse)
HXLINE(2354)		Float retx = ( (Float)(0) );
HXLINE(2355)		Float rety = ( (Float)(0) );
HXLINE(2372)		Float retz = ( (Float)(0) );
HXLINE(2373)		{
HXLINE(2374)			 ::zpp_nape::util::ZNPNode_ZPP_Constraint cx_ite = this->zpp_inner->constraints->head;
HXLINE(2375)			while(hx::IsNotNull( cx_ite )){
HXLINE(2376)				 ::zpp_nape::constraint::ZPP_Constraint con = cx_ite->elt;
HXLINE(2377)				{
HXLINE(2378)					 ::nape::geom::Vec3 imp = con->outer->bodyImpulse(hx::ObjectPtr<OBJ_>(this));
HXLINE(2379)					{
HXLINE(2380)						int t = 1;
HXLINE(2381)						{
HXLINE(2382)							int t1 = t;
HXLINE(2391)							bool retx1;
HXDLIN(2391)							if (hx::IsNotNull( imp )) {
HXLINE(2391)								retx1 = imp->zpp_disp;
            							}
            							else {
HXLINE(2391)								retx1 = false;
            							}
HXDLIN(2391)							if (retx1) {
HXLINE(2391)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2391)							{
HXLINE(2391)								 ::zpp_nape::geom::ZPP_Vec3 _this = imp->zpp_inner;
HXDLIN(2391)								if (hx::IsNotNull( _this->_validate )) {
HXLINE(2391)									_this->_validate();
            								}
            							}
HXDLIN(2391)							retx = (retx + (imp->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2392)							bool rety1;
HXDLIN(2392)							if (hx::IsNotNull( imp )) {
HXLINE(2392)								rety1 = imp->zpp_disp;
            							}
            							else {
HXLINE(2392)								rety1 = false;
            							}
HXDLIN(2392)							if (rety1) {
HXLINE(2392)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2392)							{
HXLINE(2392)								 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp->zpp_inner;
HXDLIN(2392)								if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2392)									_this1->_validate();
            								}
            							}
HXDLIN(2392)							rety = (rety + (imp->zpp_inner->y * ( (Float)(t1) )));
            						}
HXLINE(2394)						bool retz1;
HXDLIN(2394)						if (hx::IsNotNull( imp )) {
HXLINE(2394)							retz1 = imp->zpp_disp;
            						}
            						else {
HXLINE(2394)							retz1 = false;
            						}
HXDLIN(2394)						if (retz1) {
HXLINE(2394)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN(2394)						{
HXLINE(2394)							 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp->zpp_inner;
HXDLIN(2394)							if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2394)								_this2->_validate();
            							}
            						}
HXDLIN(2394)						retz = (retz + (imp->zpp_inner->z * ( (Float)(t) )));
            					}
HXLINE(2396)					imp->dispose();
            				}
HXLINE(2398)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(2401)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Body_obj,constraintsImpulse,return )

 ::nape::geom::Vec3 Body_obj::totalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2419_totalImpulse)
HXLINE(2420)		Float retx = ( (Float)(0) );
HXLINE(2421)		Float rety = ( (Float)(0) );
HXLINE(2438)		Float retz = ( (Float)(0) );
HXLINE(2439)		 ::zpp_nape::util::ZNPList_ZPP_Arbiter arbs = this->zpp_inner->arbiters;
HXLINE(2440)		{
HXLINE(2440)			if (hx::IsNull( this->zpp_inner->wrap_arbiters )) {
HXLINE(2440)				this->zpp_inner->wrap_arbiters = ::zpp_nape::util::ZPP_ArbiterList_obj::get(this->zpp_inner->arbiters,true);
            			}
HXDLIN(2440)			 ::nape::dynamics::ArbiterIterator _g = this->zpp_inner->wrap_arbiters->iterator();
HXDLIN(2440)			while(true){
HXLINE(2440)				_g->zpp_inner->zpp_inner->valmod();
HXDLIN(2440)				int length = _g->zpp_inner->zpp_gl();
HXDLIN(2440)				_g->zpp_critical = true;
HXDLIN(2440)				bool _hx_tmp;
HXDLIN(2440)				if ((_g->zpp_i < length)) {
HXLINE(2440)					_hx_tmp = true;
            				}
            				else {
HXLINE(2440)					{
HXLINE(2440)						_g->zpp_next = ::nape::dynamics::ArbiterIterator_obj::zpp_pool;
HXDLIN(2440)						::nape::dynamics::ArbiterIterator_obj::zpp_pool = _g;
HXDLIN(2440)						_g->zpp_inner = null();
            					}
HXDLIN(2440)					_hx_tmp = false;
            				}
HXDLIN(2440)				if (!(_hx_tmp)) {
HXLINE(2440)					goto _hx_goto_110;
            				}
HXDLIN(2440)				_g->zpp_critical = false;
HXDLIN(2440)				 ::nape::dynamics::Arbiter oarb = _g->zpp_inner->at(_g->zpp_i++);
HXLINE(2441)				 ::zpp_nape::dynamics::ZPP_Arbiter arb = oarb->zpp_inner;
HXLINE(2442)				if ((arb->type == ::zpp_nape::dynamics::ZPP_Arbiter_obj::SENSOR)) {
HXLINE(2442)					continue;
            				}
HXLINE(2443)				bool _hx_tmp1;
HXDLIN(2443)				bool _hx_tmp2;
HXDLIN(2443)				if (hx::IsNotNull( body )) {
HXLINE(2443)					_hx_tmp2 = hx::IsNotEq( arb->b2,body->zpp_inner );
            				}
            				else {
HXLINE(2443)					_hx_tmp2 = false;
            				}
HXDLIN(2443)				if (_hx_tmp2) {
HXLINE(2443)					_hx_tmp1 = hx::IsNotEq( arb->b1,body->zpp_inner );
            				}
            				else {
HXLINE(2443)					_hx_tmp1 = false;
            				}
HXDLIN(2443)				if (_hx_tmp1) {
HXLINE(2443)					continue;
            				}
HXLINE(2444)				 ::nape::geom::Vec3 imp = arb->wrapper()->totalImpulse(hx::ObjectPtr<OBJ_>(this),freshOnly);
HXLINE(2445)				{
HXLINE(2446)					int t = 1;
HXLINE(2447)					{
HXLINE(2448)						int t1 = t;
HXLINE(2457)						bool retx1;
HXDLIN(2457)						if (hx::IsNotNull( imp )) {
HXLINE(2457)							retx1 = imp->zpp_disp;
            						}
            						else {
HXLINE(2457)							retx1 = false;
            						}
HXDLIN(2457)						if (retx1) {
HXLINE(2457)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN(2457)						{
HXLINE(2457)							 ::zpp_nape::geom::ZPP_Vec3 _this = imp->zpp_inner;
HXDLIN(2457)							if (hx::IsNotNull( _this->_validate )) {
HXLINE(2457)								_this->_validate();
            							}
            						}
HXDLIN(2457)						retx = (retx + (imp->zpp_inner->x * ( (Float)(t1) )));
HXLINE(2458)						bool rety1;
HXDLIN(2458)						if (hx::IsNotNull( imp )) {
HXLINE(2458)							rety1 = imp->zpp_disp;
            						}
            						else {
HXLINE(2458)							rety1 = false;
            						}
HXDLIN(2458)						if (rety1) {
HXLINE(2458)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN(2458)						{
HXLINE(2458)							 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp->zpp_inner;
HXDLIN(2458)							if (hx::IsNotNull( _this1->_validate )) {
HXLINE(2458)								_this1->_validate();
            							}
            						}
HXDLIN(2458)						rety = (rety + (imp->zpp_inner->y * ( (Float)(t1) )));
            					}
HXLINE(2460)					bool retz1;
HXDLIN(2460)					if (hx::IsNotNull( imp )) {
HXLINE(2460)						retz1 = imp->zpp_disp;
            					}
            					else {
HXLINE(2460)						retz1 = false;
            					}
HXDLIN(2460)					if (retz1) {
HXLINE(2460)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN(2460)					{
HXLINE(2460)						 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp->zpp_inner;
HXDLIN(2460)						if (hx::IsNotNull( _this2->_validate )) {
HXLINE(2460)							_this2->_validate();
            						}
            					}
HXDLIN(2460)					retz = (retz + (imp->zpp_inner->z * ( (Float)(t) )));
            				}
HXLINE(2462)				imp->dispose();
            			}
            			_hx_goto_110:;
            		}
HXLINE(2464)		{
HXLINE(2465)			 ::zpp_nape::util::ZNPNode_ZPP_Constraint cx_ite = this->zpp_inner->constraints->head;
HXLINE(2466)			while(hx::IsNotNull( cx_ite )){
HXLINE(2467)				 ::zpp_nape::constraint::ZPP_Constraint con = cx_ite->elt;
HXLINE(2469)				if (con->active) {
HXLINE(2470)					 ::nape::geom::Vec3 imp1 = con->outer->bodyImpulse(hx::ObjectPtr<OBJ_>(this));
HXLINE(2471)					{
HXLINE(2472)						int t2 = 1;
HXLINE(2473)						{
HXLINE(2474)							int t3 = t2;
HXLINE(2483)							bool retx2;
HXDLIN(2483)							if (hx::IsNotNull( imp1 )) {
HXLINE(2483)								retx2 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2483)								retx2 = false;
            							}
HXDLIN(2483)							if (retx2) {
HXLINE(2483)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2483)							{
HXLINE(2483)								 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN(2483)								if (hx::IsNotNull( _this3->_validate )) {
HXLINE(2483)									_this3->_validate();
            								}
            							}
HXDLIN(2483)							retx = (retx + (imp1->zpp_inner->x * ( (Float)(t3) )));
HXLINE(2484)							bool rety2;
HXDLIN(2484)							if (hx::IsNotNull( imp1 )) {
HXLINE(2484)								rety2 = imp1->zpp_disp;
            							}
            							else {
HXLINE(2484)								rety2 = false;
            							}
HXDLIN(2484)							if (rety2) {
HXLINE(2484)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN(2484)							{
HXLINE(2484)								 ::zpp_nape::geom::ZPP_Vec3 _this4 = imp1->zpp_inner;
HXDLIN(2484)								if (hx::IsNotNull( _this4->_validate )) {
HXLINE(2484)									_this4->_validate();
            								}
            							}
HXDLIN(2484)							rety = (rety + (imp1->zpp_inner->y * ( (Float)(t3) )));
            						}
HXLINE(2486)						bool retz2;
HXDLIN(2486)						if (hx::IsNotNull( imp1 )) {
HXLINE(2486)							retz2 = imp1->zpp_disp;
            						}
            						else {
HXLINE(2486)							retz2 = false;
            						}
HXDLIN(2486)						if (retz2) {
HXLINE(2486)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN(2486)						{
HXLINE(2486)							 ::zpp_nape::geom::ZPP_Vec3 _this5 = imp1->zpp_inner;
HXDLIN(2486)							if (hx::IsNotNull( _this5->_validate )) {
HXLINE(2486)								_this5->_validate();
            							}
            						}
HXDLIN(2486)						retz = (retz + (imp1->zpp_inner->z * ( (Float)(t2) )));
            					}
HXLINE(2488)					imp1->dispose();
            				}
HXLINE(2491)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE(2494)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Body_obj,totalImpulse,return )

bool Body_obj::contains( ::nape::geom::Vec2 point){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2504_contains)
HXLINE(2507)		bool _hx_tmp;
HXDLIN(2507)		if (hx::IsNotNull( point )) {
HXLINE(2507)			_hx_tmp = point->zpp_disp;
            		}
            		else {
HXLINE(2507)			_hx_tmp = false;
            		}
HXDLIN(2507)		if (_hx_tmp) {
HXLINE(2507)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE(2511)		if (hx::IsNull( point )) {
HXLINE(2511)			HX_STACK_DO_THROW(HX_("Error: Cannot check containment of null point",ab,9d,c9,26));
            		}
HXLINE(2513)		bool wasWeak = point->zpp_inner->weak;
HXLINE(2514)		point->zpp_inner->weak = false;
HXLINE(2515)		bool retvar;
HXLINE(2516)		{
HXLINE(2517)			retvar = false;
HXLINE(2518)			{
HXLINE(2519)				 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = this->zpp_inner->shapes->head;
HXLINE(2520)				while(hx::IsNotNull( cx_ite )){
HXLINE(2521)					 ::zpp_nape::shape::ZPP_Shape s = cx_ite->elt;
HXLINE(2523)					if (s->outer->contains(point)) {
HXLINE(2524)						retvar = true;
HXLINE(2525)						goto _hx_goto_113;
            					}
HXLINE(2528)					cx_ite = cx_ite->next;
            				}
            				_hx_goto_113:;
            			}
            		}
HXLINE(2532)		point->zpp_inner->weak = wasWeak;
HXLINE(2533)		if (point->zpp_inner->weak) {
HXLINE(2537)			bool _hx_tmp1;
HXDLIN(2537)			if (hx::IsNotNull( point )) {
HXLINE(2537)				_hx_tmp1 = point->zpp_disp;
            			}
            			else {
HXLINE(2537)				_hx_tmp1 = false;
            			}
HXDLIN(2537)			if (_hx_tmp1) {
HXLINE(2537)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(2537)			{
HXLINE(2537)				 ::zpp_nape::geom::ZPP_Vec2 _this = point->zpp_inner;
HXDLIN(2537)				if (_this->_immutable) {
HXLINE(2537)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(2537)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE(2537)					_this->_isimmutable();
            				}
            			}
HXDLIN(2537)			if (point->zpp_inner->_inuse) {
HXLINE(2537)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN(2537)			 ::zpp_nape::geom::ZPP_Vec2 inner = point->zpp_inner;
HXDLIN(2537)			point->zpp_inner->outer = null();
HXDLIN(2537)			point->zpp_inner = null();
HXDLIN(2537)			{
HXLINE(2537)				 ::nape::geom::Vec2 o = point;
HXDLIN(2537)				o->zpp_pool = null();
HXDLIN(2537)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE(2537)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE(2537)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN(2537)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN(2537)				o->zpp_disp = true;
            			}
HXDLIN(2537)			{
HXLINE(2537)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN(2537)				{
HXLINE(2537)					if (hx::IsNotNull( o1->outer )) {
HXLINE(2537)						o1->outer->zpp_inner = null();
HXDLIN(2537)						o1->outer = null();
            					}
HXDLIN(2537)					o1->_isimmutable = null();
HXDLIN(2537)					o1->_validate = null();
HXDLIN(2537)					o1->_invalidate = null();
            				}
HXDLIN(2537)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN(2537)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE(2544)		return retvar;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Body_obj,contains,return )

::String Body_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_276b1c0c2f1cb053_2550_toString)
HXDLIN(2550)		::String _hx_tmp;
HXDLIN(2550)		if (this->zpp_inner->world) {
HXDLIN(2550)			_hx_tmp = HX_("(space::world",b4,3f,cf,3b);
            		}
            		else {
HXDLIN(2550)			::String _hx_tmp1;
HXDLIN(2550)			if ((this->zpp_inner->type == 2)) {
HXDLIN(2550)				_hx_tmp1 = HX_("dynamic",7f,9f,15,36);
            			}
            			else {
HXDLIN(2550)				if ((this->zpp_inner->type == 1)) {
HXDLIN(2550)					_hx_tmp1 = HX_("static",ae,dc,fb,05);
            				}
            				else {
HXDLIN(2550)					_hx_tmp1 = HX_("kinematic",05,79,ff,e3);
            				}
            			}
HXDLIN(2550)			_hx_tmp = (HX_("(",28,00,00,00) + _hx_tmp1);
            		}
HXDLIN(2550)		return ((_hx_tmp + HX_(")#",da,23,00,00)) + this->zpp_inner_i->id);
            	}



hx::ObjectPtr< Body_obj > Body_obj::__new( ::nape::phys::BodyType type, ::nape::geom::Vec2 position) {
	hx::ObjectPtr< Body_obj > __this = new Body_obj();
	__this->__construct(type,position);
	return __this;
}

hx::ObjectPtr< Body_obj > Body_obj::__alloc(hx::Ctx *_hx_ctx, ::nape::phys::BodyType type, ::nape::geom::Vec2 position) {
	Body_obj *__this = (Body_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Body_obj), true, "nape.phys.Body"));
	*(void **)__this = Body_obj::_hx_vtable;
	__this->__construct(type,position);
	return __this;
}

Body_obj::Body_obj()
{
}

void Body_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Body);
	HX_MARK_MEMBER_NAME(zpp_inner,"zpp_inner");
	HX_MARK_MEMBER_NAME(debugDraw,"debugDraw");
	 ::nape::phys::Interactor_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Body_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(zpp_inner,"zpp_inner");
	HX_VISIT_MEMBER_NAME(debugDraw,"debugDraw");
	 ::nape::phys::Interactor_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Body_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_type() ); }
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		if (HX_FIELD_EQ(inName,"mass") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_mass() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_space() ); }
		if (HX_FIELD_EQ(inName,"force") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_force() ); }
		if (HX_FIELD_EQ(inName,"align") ) { return hx::Val( align_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"shapes") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_shapes() ); }
		if (HX_FIELD_EQ(inName,"torque") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_torque() ); }
		if (HX_FIELD_EQ(inName,"bounds") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_bounds() ); }
		if (HX_FIELD_EQ(inName,"rotate") ) { return hx::Val( rotate_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"inertia") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_inertia() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"get_type") ) { return hx::Val( get_type_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_type") ) { return hx::Val( set_type_dyn() ); }
		if (HX_FIELD_EQ(inName,"isBullet") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_isBullet() ); }
		if (HX_FIELD_EQ(inName,"isStatic") ) { return hx::Val( isStatic_dyn() ); }
		if (HX_FIELD_EQ(inName,"compound") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_compound() ); }
		if (HX_FIELD_EQ(inName,"arbiters") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_arbiters() ); }
		if (HX_FIELD_EQ(inName,"position") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_position() ); }
		if (HX_FIELD_EQ(inName,"velocity") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_velocity() ); }
		if (HX_FIELD_EQ(inName,"rotation") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_rotation() ); }
		if (HX_FIELD_EQ(inName,"massMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_massMode() ); }
		if (HX_FIELD_EQ(inName,"get_mass") ) { return hx::Val( get_mass_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_mass") ) { return hx::Val( set_mass_dyn() ); }
		if (HX_FIELD_EQ(inName,"gravMass") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_gravMass() ); }
		if (HX_FIELD_EQ(inName,"localCOM") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_localCOM() ); }
		if (HX_FIELD_EQ(inName,"worldCOM") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_worldCOM() ); }
		if (HX_FIELD_EQ(inName,"contains") ) { return hx::Val( contains_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { return hx::Val( zpp_inner ); }
		if (HX_FIELD_EQ(inName,"debugDraw") ) { return hx::Val( debugDraw ); }
		if (HX_FIELD_EQ(inName,"integrate") ) { return hx::Val( integrate_dyn() ); }
		if (HX_FIELD_EQ(inName,"isDynamic") ) { return hx::Val( isDynamic_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_space") ) { return hx::Val( get_space_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_space") ) { return hx::Val( set_space_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_force") ) { return hx::Val( get_force_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_force") ) { return hx::Val( set_force_dyn() ); }
		if (HX_FIELD_EQ(inName,"kinAngVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_kinAngVel() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"disableCCD") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_disableCCD() ); }
		if (HX_FIELD_EQ(inName,"get_shapes") ) { return hx::Val( get_shapes_dyn() ); }
		if (HX_FIELD_EQ(inName,"isSleeping") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_isSleeping() ); }
		if (HX_FIELD_EQ(inName,"surfaceVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_surfaceVel() ); }
		if (HX_FIELD_EQ(inName,"angularVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_angularVel() ); }
		if (HX_FIELD_EQ(inName,"get_torque") ) { return hx::Val( get_torque_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_torque") ) { return hx::Val( set_torque_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_bounds") ) { return hx::Val( get_bounds_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"isKinematic") ) { return hx::Val( isKinematic_dyn() ); }
		if (HX_FIELD_EQ(inName,"constraints") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_constraints() ); }
		if (HX_FIELD_EQ(inName,"inertiaMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_inertiaMode() ); }
		if (HX_FIELD_EQ(inName,"get_inertia") ) { return hx::Val( get_inertia_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_inertia") ) { return hx::Val( set_inertia_dyn() ); }
		if (HX_FIELD_EQ(inName,"crushFactor") ) { return hx::Val( crushFactor_dyn() ); }
		if (HX_FIELD_EQ(inName,"scaleShapes") ) { return hx::Val( scaleShapes_dyn() ); }
		if (HX_FIELD_EQ(inName,"dragImpulse") ) { return hx::Val( dragImpulse_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_isBullet") ) { return hx::Val( get_isBullet_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_isBullet") ) { return hx::Val( set_isBullet_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_compound") ) { return hx::Val( get_compound_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_compound") ) { return hx::Val( set_compound_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_arbiters") ) { return hx::Val( get_arbiters_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_position") ) { return hx::Val( get_position_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_position") ) { return hx::Val( set_position_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_velocity") ) { return hx::Val( get_velocity_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_velocity") ) { return hx::Val( set_velocity_dyn() ); }
		if (HX_FIELD_EQ(inName,"kinematicVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_kinematicVel() ); }
		if (HX_FIELD_EQ(inName,"get_rotation") ) { return hx::Val( get_rotation_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_rotation") ) { return hx::Val( set_rotation_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_massMode") ) { return hx::Val( get_massMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_massMode") ) { return hx::Val( set_massMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"gravMassMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_gravMassMode() ); }
		if (HX_FIELD_EQ(inName,"get_gravMass") ) { return hx::Val( get_gravMass_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_gravMass") ) { return hx::Val( set_gravMass_dyn() ); }
		if (HX_FIELD_EQ(inName,"applyImpulse") ) { return hx::Val( applyImpulse_dyn() ); }
		if (HX_FIELD_EQ(inName,"rotateShapes") ) { return hx::Val( rotateShapes_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_localCOM") ) { return hx::Val( get_localCOM_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_worldCOM") ) { return hx::Val( get_worldCOM_dyn() ); }
		if (HX_FIELD_EQ(inName,"totalImpulse") ) { return hx::Val( totalImpulse_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"get_kinAngVel") ) { return hx::Val( get_kinAngVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_kinAngVel") ) { return hx::Val( set_kinAngVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"allowMovement") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_allowMovement() ); }
		if (HX_FIELD_EQ(inName,"allowRotation") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_allowRotation() ); }
		if (HX_FIELD_EQ(inName,"gravMassScale") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_gravMassScale() ); }
		if (HX_FIELD_EQ(inName,"normalImpulse") ) { return hx::Val( normalImpulse_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"get_disableCCD") ) { return hx::Val( get_disableCCD_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_disableCCD") ) { return hx::Val( set_disableCCD_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_isSleeping") ) { return hx::Val( get_isSleeping_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_surfaceVel") ) { return hx::Val( get_surfaceVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_surfaceVel") ) { return hx::Val( set_surfaceVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_angularVel") ) { return hx::Val( get_angularVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_angularVel") ) { return hx::Val( set_angularVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"constraintMass") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_constraintMass() ); }
		if (HX_FIELD_EQ(inName,"tangentImpulse") ) { return hx::Val( tangentImpulse_dyn() ); }
		if (HX_FIELD_EQ(inName,"rollingImpulse") ) { return hx::Val( rollingImpulse_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_constraints") ) { return hx::Val( get_constraints_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_inertiaMode") ) { return hx::Val( get_inertiaMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_inertiaMode") ) { return hx::Val( set_inertiaMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"connectedBodies") ) { return hx::Val( connectedBodies_dyn() ); }
		if (HX_FIELD_EQ(inName,"translateShapes") ) { return hx::Val( translateShapes_dyn() ); }
		if (HX_FIELD_EQ(inName,"transformShapes") ) { return hx::Val( transformShapes_dyn() ); }
		if (HX_FIELD_EQ(inName,"setShapeFilters") ) { return hx::Val( setShapeFilters_dyn() ); }
		if (HX_FIELD_EQ(inName,"buoyancyImpulse") ) { return hx::Val( buoyancyImpulse_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_kinematicVel") ) { return hx::Val( get_kinematicVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_kinematicVel") ) { return hx::Val( set_kinematicVel_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_gravMassMode") ) { return hx::Val( get_gravMassMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_gravMassMode") ) { return hx::Val( set_gravMassMode_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_allowMovement") ) { return hx::Val( get_allowMovement_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_allowMovement") ) { return hx::Val( set_allowMovement_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_allowRotation") ) { return hx::Val( get_allowRotation_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_allowRotation") ) { return hx::Val( set_allowRotation_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_gravMassScale") ) { return hx::Val( get_gravMassScale_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_gravMassScale") ) { return hx::Val( set_gravMassScale_dyn() ); }
		if (HX_FIELD_EQ(inName,"constraintInertia") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_constraintInertia() ); }
		if (HX_FIELD_EQ(inName,"interactingBodies") ) { return hx::Val( interactingBodies_dyn() ); }
		if (HX_FIELD_EQ(inName,"localPointToWorld") ) { return hx::Val( localPointToWorld_dyn() ); }
		if (HX_FIELD_EQ(inName,"worldPointToLocal") ) { return hx::Val( worldPointToLocal_dyn() ); }
		if (HX_FIELD_EQ(inName,"setShapeMaterials") ) { return hx::Val( setShapeMaterials_dyn() ); }
		if (HX_FIELD_EQ(inName,"totalFluidImpulse") ) { return hx::Val( totalFluidImpulse_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"constraintVelocity") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_constraintVelocity() ); }
		if (HX_FIELD_EQ(inName,"get_constraintMass") ) { return hx::Val( get_constraintMass_dyn() ); }
		if (HX_FIELD_EQ(inName,"localVectorToWorld") ) { return hx::Val( localVectorToWorld_dyn() ); }
		if (HX_FIELD_EQ(inName,"worldVectorToLocal") ) { return hx::Val( worldVectorToLocal_dyn() ); }
		if (HX_FIELD_EQ(inName,"constraintsImpulse") ) { return hx::Val( constraintsImpulse_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"applyAngularImpulse") ) { return hx::Val( applyAngularImpulse_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"totalContactsImpulse") ) { return hx::Val( totalContactsImpulse_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"setVelocityFromTarget") ) { return hx::Val( setVelocityFromTarget_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_constraintInertia") ) { return hx::Val( get_constraintInertia_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"get_constraintVelocity") ) { return hx::Val( get_constraintVelocity_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"setShapeFluidProperties") ) { return hx::Val( setShapeFluidProperties_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Body_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_type(inValue.Cast<  ::nape::phys::BodyType >()) ); }
		if (HX_FIELD_EQ(inName,"mass") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_mass(inValue.Cast< Float >()) ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_space(inValue.Cast<  ::nape::space::Space >()) ); }
		if (HX_FIELD_EQ(inName,"force") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_force(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"torque") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_torque(inValue.Cast< Float >()) ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"inertia") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_inertia(inValue.Cast< Float >()) ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isBullet") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_isBullet(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"compound") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_compound(inValue.Cast<  ::nape::phys::Compound >()) ); }
		if (HX_FIELD_EQ(inName,"position") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_position(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		if (HX_FIELD_EQ(inName,"velocity") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_velocity(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		if (HX_FIELD_EQ(inName,"rotation") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_rotation(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"massMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_massMode(inValue.Cast<  ::nape::phys::MassMode >()) ); }
		if (HX_FIELD_EQ(inName,"gravMass") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_gravMass(inValue.Cast< Float >()) ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { zpp_inner=inValue.Cast<  ::zpp_nape::phys::ZPP_Body >(); return inValue; }
		if (HX_FIELD_EQ(inName,"debugDraw") ) { debugDraw=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"kinAngVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_kinAngVel(inValue.Cast< Float >()) ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"disableCCD") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_disableCCD(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"surfaceVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_surfaceVel(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		if (HX_FIELD_EQ(inName,"angularVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_angularVel(inValue.Cast< Float >()) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"inertiaMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_inertiaMode(inValue.Cast<  ::nape::phys::InertiaMode >()) ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"kinematicVel") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_kinematicVel(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		if (HX_FIELD_EQ(inName,"gravMassMode") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_gravMassMode(inValue.Cast<  ::nape::phys::GravMassMode >()) ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"allowMovement") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_allowMovement(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"allowRotation") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_allowRotation(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"gravMassScale") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_gravMassScale(inValue.Cast< Float >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Body_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("zpp_inner",51,65,85,78));
	outFields->push(HX_("debugDraw",f7,cf,bb,25));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("isBullet",cc,2d,fa,2c));
	outFields->push(HX_("disableCCD",bc,c8,9b,b6));
	outFields->push(HX_("shapes",32,da,29,1d));
	outFields->push(HX_("compound",6b,c3,cf,81));
	outFields->push(HX_("space",c6,8c,66,81));
	outFields->push(HX_("arbiters",6a,2c,b2,21));
	outFields->push(HX_("isSleeping",35,6a,42,8b));
	outFields->push(HX_("constraints",76,51,b4,17));
	outFields->push(HX_("position",a9,a0,fa,ca));
	outFields->push(HX_("velocity",1d,02,fe,1e));
	outFields->push(HX_("kinematicVel",58,d2,c1,63));
	outFields->push(HX_("surfaceVel",30,8e,1a,e0));
	outFields->push(HX_("force",eb,b1,94,04));
	outFields->push(HX_("constraintVelocity",9a,e3,2e,a1));
	outFields->push(HX_("rotation",3e,3d,86,08));
	outFields->push(HX_("angularVel",9b,e4,92,d8));
	outFields->push(HX_("kinAngVel",d3,90,6d,16));
	outFields->push(HX_("torque",ca,b6,90,96));
	outFields->push(HX_("bounds",75,86,1d,66));
	outFields->push(HX_("allowMovement",d8,16,f2,d0));
	outFields->push(HX_("allowRotation",e7,ce,40,d9));
	outFields->push(HX_("massMode",77,ca,75,81));
	outFields->push(HX_("constraintMass",f1,5f,3f,70));
	outFields->push(HX_("mass",f4,40,56,48));
	outFields->push(HX_("gravMassMode",77,36,b6,49));
	outFields->push(HX_("gravMass",f4,ac,f0,74));
	outFields->push(HX_("gravMassScale",f6,1c,30,a2));
	outFields->push(HX_("inertiaMode",7d,b5,39,0d));
	outFields->push(HX_("constraintInertia",1d,4e,13,e8));
	outFields->push(HX_("inertia",fa,b0,ba,7c));
	outFields->push(HX_("localCOM",96,c7,df,df));
	outFields->push(HX_("worldCOM",0f,c5,83,a4));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Body_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::zpp_nape::phys::ZPP_Body */ ,(int)offsetof(Body_obj,zpp_inner),HX_("zpp_inner",51,65,85,78)},
	{hx::fsBool,(int)offsetof(Body_obj,debugDraw),HX_("debugDraw",f7,cf,bb,25)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Body_obj_sStaticStorageInfo = 0;
#endif

static ::String Body_obj_sMemberFields[] = {
	HX_("zpp_inner",51,65,85,78),
	HX_("debugDraw",f7,cf,bb,25),
	HX_("get_type",43,ae,c3,cc),
	HX_("set_type",b7,07,21,7b),
	HX_("get_isBullet",d5,e1,13,e2),
	HX_("set_isBullet",49,05,0d,f7),
	HX_("get_disableCCD",05,51,91,2c),
	HX_("set_disableCCD",79,39,b1,4c),
	HX_("integrate",71,6e,60,ec),
	HX_("isStatic",38,78,65,5e),
	HX_("isDynamic",b5,1c,14,3a),
	HX_("isKinematic",bb,2f,80,c2),
	HX_("get_shapes",fb,49,b1,0d),
	HX_("get_compound",74,77,e9,36),
	HX_("set_compound",e8,9a,e2,4b),
	HX_("get_space",1d,e9,0f,c5),
	HX_("set_space",29,d5,60,a8),
	HX_("get_arbiters",73,e0,cb,d6),
	HX_("get_isSleeping",7e,f2,37,01),
	HX_("get_constraints",0d,09,96,d8),
	HX_("copy",b5,bb,c4,41),
	HX_("get_position",b2,54,14,80),
	HX_("set_position",26,78,0d,95),
	HX_("get_velocity",26,b6,17,d4),
	HX_("set_velocity",9a,d9,10,e9),
	HX_("setVelocityFromTarget",1a,f5,8b,d2),
	HX_("get_kinematicVel",e1,be,60,68),
	HX_("set_kinematicVel",55,ac,a2,be),
	HX_("get_surfaceVel",79,16,10,56),
	HX_("set_surfaceVel",ed,fe,2f,76),
	HX_("get_force",42,0e,3e,48),
	HX_("set_force",4e,fa,8e,2b),
	HX_("get_constraintVelocity",e3,5c,c3,fa),
	HX_("get_rotation",47,f1,9f,bd),
	HX_("set_rotation",bb,14,99,d2),
	HX_("get_angularVel",e4,6c,88,4e),
	HX_("set_angularVel",58,55,a8,6e),
	HX_("get_kinAngVel",aa,64,d1,d7),
	HX_("set_kinAngVel",b6,46,d7,1c),
	HX_("get_torque",93,26,18,87),
	HX_("set_torque",07,c5,95,8a),
	HX_("get_bounds",3e,f6,a4,56),
	HX_("get_allowMovement",2f,22,62,d7),
	HX_("set_allowMovement",3b,fa,cf,fa),
	HX_("get_allowRotation",3e,da,b0,df),
	HX_("set_allowRotation",4a,b2,1e,03),
	HX_("get_massMode",80,7e,8f,36),
	HX_("set_massMode",f4,a1,88,4b),
	HX_("get_constraintMass",ba,40,d9,0b),
	HX_("get_mass",7d,fc,10,c8),
	HX_("set_mass",f1,55,6e,76),
	HX_("get_gravMassMode",00,23,55,4e),
	HX_("set_gravMassMode",74,10,97,a4),
	HX_("get_gravMass",fd,60,0a,2a),
	HX_("set_gravMass",71,84,03,3f),
	HX_("get_gravMassScale",4d,28,a0,a8),
	HX_("set_gravMassScale",59,00,0e,cc),
	HX_("get_inertiaMode",14,6d,1b,ce),
	HX_("set_inertiaMode",20,ea,e6,c9),
	HX_("get_constraintInertia",f4,50,c1,66),
	HX_("get_inertia",11,11,b5,02),
	HX_("set_inertia",1d,18,22,0d),
	HX_("connectedBodies",29,2f,18,68),
	HX_("interactingBodies",8c,bf,60,f1),
	HX_("crushFactor",2a,68,85,8e),
	HX_("localPointToWorld",72,8a,8d,ac),
	HX_("worldPointToLocal",f2,c8,c0,e1),
	HX_("localVectorToWorld",e9,07,47,d4),
	HX_("worldVectorToLocal",bb,29,56,46),
	HX_("applyImpulse",e7,9c,2a,ad),
	HX_("applyAngularImpulse",01,c8,65,34),
	HX_("translateShapes",20,94,c3,76),
	HX_("rotateShapes",ed,4a,78,db),
	HX_("scaleShapes",5c,a0,2d,09),
	HX_("transformShapes",be,54,7f,58),
	HX_("align",c5,56,91,21),
	HX_("rotate",5b,46,20,cb),
	HX_("setShapeMaterials",cd,4d,08,ca),
	HX_("setShapeFilters",5c,cf,63,8f),
	HX_("setShapeFluidProperties",3e,41,e5,88),
	HX_("get_localCOM",9f,7b,f9,94),
	HX_("get_worldCOM",18,79,9d,59),
	HX_("normalImpulse",4e,a9,46,07),
	HX_("tangentImpulse",70,2e,3e,65),
	HX_("totalContactsImpulse",be,67,e6,6f),
	HX_("rollingImpulse",b0,b5,dd,ca),
	HX_("buoyancyImpulse",75,a7,03,9f),
	HX_("dragImpulse",21,73,de,23),
	HX_("totalFluidImpulse",af,09,40,b9),
	HX_("constraintsImpulse",df,e1,36,95),
	HX_("totalImpulse",51,e5,bb,16),
	HX_("contains",1f,5a,7b,2c),
	HX_("toString",ac,d0,6e,38),
	::String(null()) };

hx::Class Body_obj::__mClass;

void Body_obj::__register()
{
	Body_obj _hx_dummy;
	Body_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.phys.Body",d8,73,7a,0e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Body_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Body_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Body_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Body_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace phys
