// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_nape_callbacks_CbType
#include <hxinc/nape/callbacks/CbType.h>
#endif
#ifndef INCLUDED_nape_constraint_Constraint
#include <hxinc/nape/constraint/Constraint.h>
#endif
#ifndef INCLUDED_nape_constraint_ConstraintIterator
#include <hxinc/nape/constraint/ConstraintIterator.h>
#endif
#ifndef INCLUDED_nape_constraint_ConstraintList
#include <hxinc/nape/constraint/ConstraintList.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_BodyIterator
#include <hxinc/nape/phys/BodyIterator.h>
#endif
#ifndef INCLUDED_nape_phys_BodyList
#include <hxinc/nape/phys/BodyList.h>
#endif
#ifndef INCLUDED_nape_phys_Compound
#include <hxinc/nape/phys/Compound.h>
#endif
#ifndef INCLUDED_nape_phys_CompoundIterator
#include <hxinc/nape/phys/CompoundIterator.h>
#endif
#ifndef INCLUDED_nape_phys_CompoundList
#include <hxinc/nape/phys/CompoundList.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeList
#include <hxinc/nape/shape/ShapeList.h>
#endif
#ifndef INCLUDED_nape_space_Space
#include <hxinc/nape/space/Space.h>
#endif
#ifndef INCLUDED_zpp_nape_callbacks_ZPP_CbType
#include <hxinc/zpp_nape/callbacks/ZPP_CbType.h>
#endif
#ifndef INCLUDED_zpp_nape_constraint_ZPP_CopyHelper
#include <hxinc/zpp_nape/constraint/ZPP_CopyHelper.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Compound
#include <hxinc/zpp_nape/phys/ZPP_Compound.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Body
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Compound
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Compound.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Constraint
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Constraint.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Shape
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Shape
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_BodyList
#include <hxinc/zpp_nape/util/ZPP_BodyList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_CompoundList
#include <hxinc/zpp_nape/util/ZPP_CompoundList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ConstraintList
#include <hxinc/zpp_nape/util/ZPP_ConstraintList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_PubPool
#include <hxinc/zpp_nape/util/ZPP_PubPool.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ShapeList
#include <hxinc/zpp_nape/util/ZPP_ShapeList.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_196_new,"nape.phys.Compound","new",0x9c751513,"nape.phys.Compound.new","nape/phys/Compound.hx",196,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_211_get_bodies,"nape.phys.Compound","get_bodies",0x49f992f6,"nape.phys.Compound.get_bodies","nape/phys/Compound.hx",211,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_223_get_constraints,"nape.phys.Compound","get_constraints",0x89250e40,"nape.phys.Compound.get_constraints","nape/phys/Compound.hx",223,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_235_get_compounds,"nape.phys.Compound","get_compounds",0x74c250f2,"nape.phys.Compound.get_compounds","nape/phys/Compound.hx",235,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_245_get_compound,"nape.phys.Compound","get_compound",0xca918461,"nape.phys.Compound.get_compound","nape/phys/Compound.hx",245,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_247_set_compound,"nape.phys.Compound","set_compound",0xdf8aa7d5,"nape.phys.Compound.set_compound","nape/phys/Compound.hx",247,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_267_get_space,"nape.phys.Compound","get_space",0x76fe3610,"nape.phys.Compound.get_space","nape/phys/Compound.hx",267,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_269_set_space,"nape.phys.Compound","set_space",0x5a4f221c,"nape.phys.Compound.set_space","nape/phys/Compound.hx",269,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_306_toString,"nape.phys.Compound","toString",0xdb18a319,"nape.phys.Compound.toString","nape/phys/Compound.hx",306,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_330_copy,"nape.phys.Compound","copy",0x42bf93a2,"nape.phys.Compound.copy","nape/phys/Compound.hx",330,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_344_breakApart,"nape.phys.Compound","breakApart",0x5cade742,"nape.phys.Compound.breakApart","nape/phys/Compound.hx",344,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_353_visitBodies,"nape.phys.Compound","visitBodies",0xa830a35e,"nape.phys.Compound.visitBodies","nape/phys/Compound.hx",353,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_367_visitConstraints,"nape.phys.Compound","visitConstraints",0x8e7184d8,"nape.phys.Compound.visitConstraints","nape/phys/Compound.hx",367,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_381_visitCompounds,"nape.phys.Compound","visitCompounds",0x6b13718a,"nape.phys.Compound.visitCompounds","nape/phys/Compound.hx",381,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_404_COM,"nape.phys.Compound","COM",0x9c5460d4,"nape.phys.Compound.COM","nape/phys/Compound.hx",404,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_400_COM,"nape.phys.Compound","COM",0x9c5460d4,"nape.phys.Compound.COM","nape/phys/Compound.hx",400,0x15c2ad5d)
static const Float _hx_array_data_34428fa1_21[] = {
	0.0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_436_translate,"nape.phys.Compound","translate",0xfb6e2441,"nape.phys.Compound.translate","nape/phys/Compound.hx",436,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_425_translate,"nape.phys.Compound","translate",0xfb6e2441,"nape.phys.Compound.translate","nape/phys/Compound.hx",425,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_476_rotate,"nape.phys.Compound","rotate",0x2272b388,"nape.phys.Compound.rotate","nape/phys/Compound.hx",476,0x15c2ad5d)
HX_LOCAL_STACK_FRAME(_hx_pos_10b50cbfe0c4540d_462_rotate,"nape.phys.Compound","rotate",0x2272b388,"nape.phys.Compound.rotate","nape/phys/Compound.hx",462,0x15c2ad5d)
namespace nape{
namespace phys{

void Compound_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_196_new)
HXLINE( 200)		this->zpp_inner = null();
HXLINE( 289)		::nape::phys::Interactor_obj::zpp_internalAlloc = true;
HXLINE( 290)		super::__construct();
HXLINE( 291)		::nape::phys::Interactor_obj::zpp_internalAlloc = false;
HXLINE( 296)		this->zpp_inner =  ::zpp_nape::phys::ZPP_Compound_obj::__alloc( HX_CTX );
HXLINE( 297)		this->zpp_inner->outer = hx::ObjectPtr<OBJ_>(this);
HXLINE( 298)		this->zpp_inner->outer_i = hx::ObjectPtr<OBJ_>(this);
HXLINE( 299)		this->zpp_inner_i = this->zpp_inner;
HXLINE( 300)		this->zpp_inner->insert_cbtype(::zpp_nape::callbacks::ZPP_CbType_obj::ANY_COMPOUND->zpp_inner);
            	}

Dynamic Compound_obj::__CreateEmpty() { return new Compound_obj; }

void *Compound_obj::_hx_vtable = 0;

Dynamic Compound_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Compound_obj > _hx_result = new Compound_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Compound_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x187c38a9) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x187c38a9;
	} else {
		return inClassId==(int)0x643c1bb3;
	}
}

 ::nape::phys::BodyList Compound_obj::get_bodies(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_211_get_bodies)
HXDLIN( 211)		return this->zpp_inner->wrap_bodies;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,get_bodies,return )

 ::nape::constraint::ConstraintList Compound_obj::get_constraints(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_223_get_constraints)
HXDLIN( 223)		return this->zpp_inner->wrap_constraints;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,get_constraints,return )

 ::nape::phys::CompoundList Compound_obj::get_compounds(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_235_get_compounds)
HXDLIN( 235)		return this->zpp_inner->wrap_compounds;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,get_compounds,return )

 ::nape::phys::Compound Compound_obj::get_compound(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_245_get_compound)
HXDLIN( 245)		if (hx::IsNull( this->zpp_inner->compound )) {
HXDLIN( 245)			return null();
            		}
            		else {
HXDLIN( 245)			return this->zpp_inner->compound->outer;
            		}
HXDLIN( 245)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,get_compound,return )

 ::nape::phys::Compound Compound_obj::set_compound( ::nape::phys::Compound compound){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_247_set_compound)
HXLINE( 248)		{
HXLINE( 249)			this->zpp_inner->immutable_midstep(HX_("Compound::compound",76,31,1b,54));
HXLINE( 250)			 ::nape::phys::Compound _hx_tmp;
HXDLIN( 250)			if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 250)				_hx_tmp = null();
            			}
            			else {
HXLINE( 250)				_hx_tmp = this->zpp_inner->compound->outer;
            			}
HXDLIN( 250)			if (hx::IsNotEq( _hx_tmp,compound )) {
HXLINE( 251)				 ::nape::phys::Compound _hx_tmp1;
HXDLIN( 251)				if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 251)					_hx_tmp1 = null();
            				}
            				else {
HXLINE( 251)					_hx_tmp1 = this->zpp_inner->compound->outer;
            				}
HXDLIN( 251)				if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 251)					 ::nape::phys::Compound _hx_tmp2;
HXDLIN( 251)					if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 251)						_hx_tmp2 = null();
            					}
            					else {
HXLINE( 251)						_hx_tmp2 = this->zpp_inner->compound->outer;
            					}
HXDLIN( 251)					_hx_tmp2->zpp_inner->wrap_compounds->remove(hx::ObjectPtr<OBJ_>(this));
            				}
HXLINE( 252)				if (hx::IsNotNull( compound )) {
HXLINE( 252)					 ::nape::phys::CompoundList _this = compound->zpp_inner->wrap_compounds;
HXDLIN( 252)					if (_this->zpp_inner->reverse_flag) {
HXLINE( 252)						_this->push(hx::ObjectPtr<OBJ_>(this));
            					}
            					else {
HXLINE( 252)						_this->unshift(hx::ObjectPtr<OBJ_>(this));
            					}
            				}
            			}
            		}
HXLINE( 255)		if (hx::IsNull( this->zpp_inner->compound )) {
HXLINE( 255)			return null();
            		}
            		else {
HXLINE( 255)			return this->zpp_inner->compound->outer;
            		}
HXDLIN( 255)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,set_compound,return )

 ::nape::space::Space Compound_obj::get_space(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_267_get_space)
HXDLIN( 267)		if (hx::IsNull( this->zpp_inner->space )) {
HXDLIN( 267)			return null();
            		}
            		else {
HXDLIN( 267)			return this->zpp_inner->space->outer;
            		}
HXDLIN( 267)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,get_space,return )

 ::nape::space::Space Compound_obj::set_space( ::nape::space::Space space){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_269_set_space)
HXLINE( 270)		{
HXLINE( 272)			if (hx::IsNotNull( this->zpp_inner->compound )) {
HXLINE( 272)				HX_STACK_DO_THROW(HX_("Error: Cannot set the space of an inner Compound, only the root Compound space can be set",c0,8a,2d,1a));
            			}
HXLINE( 274)			this->zpp_inner->immutable_midstep(HX_("Compound::space",db,b9,96,b9));
HXLINE( 275)			 ::nape::space::Space _hx_tmp;
HXDLIN( 275)			if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 275)				_hx_tmp = null();
            			}
            			else {
HXLINE( 275)				_hx_tmp = this->zpp_inner->space->outer;
            			}
HXDLIN( 275)			if (hx::IsNotEq( _hx_tmp,space )) {
HXLINE( 276)				 ::nape::space::Space _hx_tmp1;
HXDLIN( 276)				if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 276)					_hx_tmp1 = null();
            				}
            				else {
HXLINE( 276)					_hx_tmp1 = this->zpp_inner->space->outer;
            				}
HXDLIN( 276)				if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 276)					 ::nape::space::Space _hx_tmp2;
HXDLIN( 276)					if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 276)						_hx_tmp2 = null();
            					}
            					else {
HXLINE( 276)						_hx_tmp2 = this->zpp_inner->space->outer;
            					}
HXDLIN( 276)					_hx_tmp2->zpp_inner->wrap_compounds->remove(hx::ObjectPtr<OBJ_>(this));
            				}
HXLINE( 277)				if (hx::IsNotNull( space )) {
HXLINE( 277)					 ::nape::phys::CompoundList _this = space->zpp_inner->wrap_compounds;
HXDLIN( 277)					if (_this->zpp_inner->reverse_flag) {
HXLINE( 277)						_this->push(hx::ObjectPtr<OBJ_>(this));
            					}
            					else {
HXLINE( 277)						_this->unshift(hx::ObjectPtr<OBJ_>(this));
            					}
            				}
            			}
            		}
HXLINE( 280)		if (hx::IsNull( this->zpp_inner->space )) {
HXLINE( 280)			return null();
            		}
            		else {
HXLINE( 280)			return this->zpp_inner->space->outer;
            		}
HXDLIN( 280)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,set_space,return )

::String Compound_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_306_toString)
HXDLIN( 306)		return (HX_("Compound",8b,7f,81,5b) + this->zpp_inner_i->id);
            	}


 ::nape::phys::Compound Compound_obj::copy(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_330_copy)
HXDLIN( 330)		return this->zpp_inner->copy(null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,copy,return )

void Compound_obj::breakApart(){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_344_breakApart)
HXDLIN( 344)		this->zpp_inner->breakApart();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Compound_obj,breakApart,(void))

void Compound_obj::visitBodies( ::Dynamic lambda){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_353_visitBodies)
HXLINE( 355)		if (hx::IsNull( lambda )) {
HXLINE( 355)			HX_STACK_DO_THROW(HX_("Error: lambda cannot be null for Compound::visitBodies",5b,64,bc,62));
            		}
HXLINE( 357)		{
HXLINE( 357)			 ::nape::phys::BodyList _this = this->zpp_inner->wrap_bodies;
HXDLIN( 357)			_this->zpp_inner->valmod();
HXDLIN( 357)			 ::nape::phys::BodyIterator _g = ::nape::phys::BodyIterator_obj::get(_this);
HXDLIN( 357)			while(true){
HXLINE( 357)				_g->zpp_inner->zpp_inner->valmod();
HXDLIN( 357)				 ::nape::phys::BodyList _this1 = _g->zpp_inner;
HXDLIN( 357)				_this1->zpp_inner->valmod();
HXDLIN( 357)				if (_this1->zpp_inner->zip_length) {
HXLINE( 357)					_this1->zpp_inner->zip_length = false;
HXDLIN( 357)					_this1->zpp_inner->user_length = _this1->zpp_inner->inner->length;
            				}
HXDLIN( 357)				int length = _this1->zpp_inner->user_length;
HXDLIN( 357)				_g->zpp_critical = true;
HXDLIN( 357)				bool _hx_tmp;
HXDLIN( 357)				if ((_g->zpp_i < length)) {
HXLINE( 357)					_hx_tmp = true;
            				}
            				else {
HXLINE( 357)					{
HXLINE( 357)						_g->zpp_next = ::nape::phys::BodyIterator_obj::zpp_pool;
HXDLIN( 357)						::nape::phys::BodyIterator_obj::zpp_pool = _g;
HXDLIN( 357)						_g->zpp_inner = null();
            					}
HXDLIN( 357)					_hx_tmp = false;
            				}
HXDLIN( 357)				if (!(_hx_tmp)) {
HXLINE( 357)					goto _hx_goto_11;
            				}
HXDLIN( 357)				_g->zpp_critical = false;
HXDLIN( 357)				 ::nape::phys::Body b = _g->zpp_inner->at(_g->zpp_i++);
HXDLIN( 357)				lambda(b);
            			}
            			_hx_goto_11:;
            		}
HXLINE( 358)		{
HXLINE( 358)			 ::nape::phys::CompoundList _this2 = this->zpp_inner->wrap_compounds;
HXDLIN( 358)			_this2->zpp_inner->valmod();
HXDLIN( 358)			 ::nape::phys::CompoundIterator _g1 = ::nape::phys::CompoundIterator_obj::get(_this2);
HXDLIN( 358)			while(true){
HXLINE( 358)				_g1->zpp_inner->zpp_inner->valmod();
HXDLIN( 358)				 ::nape::phys::CompoundList _this3 = _g1->zpp_inner;
HXDLIN( 358)				_this3->zpp_inner->valmod();
HXDLIN( 358)				if (_this3->zpp_inner->zip_length) {
HXLINE( 358)					_this3->zpp_inner->zip_length = false;
HXDLIN( 358)					_this3->zpp_inner->user_length = _this3->zpp_inner->inner->length;
            				}
HXDLIN( 358)				int length1 = _this3->zpp_inner->user_length;
HXDLIN( 358)				_g1->zpp_critical = true;
HXDLIN( 358)				bool _hx_tmp1;
HXDLIN( 358)				if ((_g1->zpp_i < length1)) {
HXLINE( 358)					_hx_tmp1 = true;
            				}
            				else {
HXLINE( 358)					{
HXLINE( 358)						_g1->zpp_next = ::nape::phys::CompoundIterator_obj::zpp_pool;
HXDLIN( 358)						::nape::phys::CompoundIterator_obj::zpp_pool = _g1;
HXDLIN( 358)						_g1->zpp_inner = null();
            					}
HXDLIN( 358)					_hx_tmp1 = false;
            				}
HXDLIN( 358)				if (!(_hx_tmp1)) {
HXLINE( 358)					goto _hx_goto_12;
            				}
HXDLIN( 358)				_g1->zpp_critical = false;
HXDLIN( 358)				 ::nape::phys::Compound c = _g1->zpp_inner->at(_g1->zpp_i++);
HXDLIN( 358)				c->visitBodies(lambda);
            			}
            			_hx_goto_12:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,visitBodies,(void))

void Compound_obj::visitConstraints( ::Dynamic lambda){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_367_visitConstraints)
HXLINE( 369)		if (hx::IsNull( lambda )) {
HXLINE( 369)			HX_STACK_DO_THROW(HX_("Error: lambda cannot be null for Compound::visitConstraints",bb,0e,98,69));
            		}
HXLINE( 371)		{
HXLINE( 371)			 ::nape::constraint::ConstraintList _this = this->zpp_inner->wrap_constraints;
HXDLIN( 371)			_this->zpp_inner->valmod();
HXDLIN( 371)			 ::nape::constraint::ConstraintIterator _g = ::nape::constraint::ConstraintIterator_obj::get(_this);
HXDLIN( 371)			while(true){
HXLINE( 371)				_g->zpp_inner->zpp_inner->valmod();
HXDLIN( 371)				 ::nape::constraint::ConstraintList _this1 = _g->zpp_inner;
HXDLIN( 371)				_this1->zpp_inner->valmod();
HXDLIN( 371)				if (_this1->zpp_inner->zip_length) {
HXLINE( 371)					_this1->zpp_inner->zip_length = false;
HXDLIN( 371)					_this1->zpp_inner->user_length = _this1->zpp_inner->inner->length;
            				}
HXDLIN( 371)				int length = _this1->zpp_inner->user_length;
HXDLIN( 371)				_g->zpp_critical = true;
HXDLIN( 371)				bool _hx_tmp;
HXDLIN( 371)				if ((_g->zpp_i < length)) {
HXLINE( 371)					_hx_tmp = true;
            				}
            				else {
HXLINE( 371)					{
HXLINE( 371)						_g->zpp_next = ::nape::constraint::ConstraintIterator_obj::zpp_pool;
HXDLIN( 371)						::nape::constraint::ConstraintIterator_obj::zpp_pool = _g;
HXDLIN( 371)						_g->zpp_inner = null();
            					}
HXDLIN( 371)					_hx_tmp = false;
            				}
HXDLIN( 371)				if (!(_hx_tmp)) {
HXLINE( 371)					goto _hx_goto_14;
            				}
HXDLIN( 371)				_g->zpp_critical = false;
HXDLIN( 371)				 ::nape::constraint::Constraint c = _g->zpp_inner->at(_g->zpp_i++);
HXDLIN( 371)				lambda(c);
            			}
            			_hx_goto_14:;
            		}
HXLINE( 372)		{
HXLINE( 372)			 ::nape::phys::CompoundList _this2 = this->zpp_inner->wrap_compounds;
HXDLIN( 372)			_this2->zpp_inner->valmod();
HXDLIN( 372)			 ::nape::phys::CompoundIterator _g1 = ::nape::phys::CompoundIterator_obj::get(_this2);
HXDLIN( 372)			while(true){
HXLINE( 372)				_g1->zpp_inner->zpp_inner->valmod();
HXDLIN( 372)				 ::nape::phys::CompoundList _this3 = _g1->zpp_inner;
HXDLIN( 372)				_this3->zpp_inner->valmod();
HXDLIN( 372)				if (_this3->zpp_inner->zip_length) {
HXLINE( 372)					_this3->zpp_inner->zip_length = false;
HXDLIN( 372)					_this3->zpp_inner->user_length = _this3->zpp_inner->inner->length;
            				}
HXDLIN( 372)				int length1 = _this3->zpp_inner->user_length;
HXDLIN( 372)				_g1->zpp_critical = true;
HXDLIN( 372)				bool _hx_tmp1;
HXDLIN( 372)				if ((_g1->zpp_i < length1)) {
HXLINE( 372)					_hx_tmp1 = true;
            				}
            				else {
HXLINE( 372)					{
HXLINE( 372)						_g1->zpp_next = ::nape::phys::CompoundIterator_obj::zpp_pool;
HXDLIN( 372)						::nape::phys::CompoundIterator_obj::zpp_pool = _g1;
HXDLIN( 372)						_g1->zpp_inner = null();
            					}
HXDLIN( 372)					_hx_tmp1 = false;
            				}
HXDLIN( 372)				if (!(_hx_tmp1)) {
HXLINE( 372)					goto _hx_goto_15;
            				}
HXDLIN( 372)				_g1->zpp_critical = false;
HXDLIN( 372)				 ::nape::phys::Compound c1 = _g1->zpp_inner->at(_g1->zpp_i++);
HXDLIN( 372)				c1->visitConstraints(lambda);
            			}
            			_hx_goto_15:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,visitConstraints,(void))

void Compound_obj::visitCompounds( ::Dynamic lambda){
            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_381_visitCompounds)
HXLINE( 383)		if (hx::IsNull( lambda )) {
HXLINE( 383)			HX_STACK_DO_THROW(HX_("Error: lambda cannot be null for Compound::visitConstraints",bb,0e,98,69));
            		}
HXLINE( 385)		{
HXLINE( 385)			 ::nape::phys::CompoundList _this = this->zpp_inner->wrap_compounds;
HXDLIN( 385)			_this->zpp_inner->valmod();
HXDLIN( 385)			 ::nape::phys::CompoundIterator _g = ::nape::phys::CompoundIterator_obj::get(_this);
HXDLIN( 385)			while(true){
HXLINE( 385)				_g->zpp_inner->zpp_inner->valmod();
HXDLIN( 385)				 ::nape::phys::CompoundList _this1 = _g->zpp_inner;
HXDLIN( 385)				_this1->zpp_inner->valmod();
HXDLIN( 385)				if (_this1->zpp_inner->zip_length) {
HXLINE( 385)					_this1->zpp_inner->zip_length = false;
HXDLIN( 385)					_this1->zpp_inner->user_length = _this1->zpp_inner->inner->length;
            				}
HXDLIN( 385)				int length = _this1->zpp_inner->user_length;
HXDLIN( 385)				_g->zpp_critical = true;
HXDLIN( 385)				bool _hx_tmp;
HXDLIN( 385)				if ((_g->zpp_i < length)) {
HXLINE( 385)					_hx_tmp = true;
            				}
            				else {
HXLINE( 385)					{
HXLINE( 385)						_g->zpp_next = ::nape::phys::CompoundIterator_obj::zpp_pool;
HXDLIN( 385)						::nape::phys::CompoundIterator_obj::zpp_pool = _g;
HXDLIN( 385)						_g->zpp_inner = null();
            					}
HXDLIN( 385)					_hx_tmp = false;
            				}
HXDLIN( 385)				if (!(_hx_tmp)) {
HXLINE( 385)					goto _hx_goto_17;
            				}
HXDLIN( 385)				_g->zpp_critical = false;
HXDLIN( 385)				 ::nape::phys::Compound c = _g->zpp_inner->at(_g->zpp_i++);
HXLINE( 386)				lambda(c);
HXLINE( 387)				c->visitCompounds(lambda);
            			}
            			_hx_goto_17:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,visitCompounds,(void))

 ::nape::geom::Vec2 Compound_obj::COM(hx::Null< bool >  __o_weak){
            		HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_0,::Array< Float >,total, ::nape::geom::Vec2,ret2) HXARGC(1)
            		void _hx_run( ::nape::phys::Body b){
            			HX_GC_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_404_COM)
HXLINE( 404)			 ::nape::shape::ShapeList _this4 = b->zpp_inner->wrap_shapes;
HXDLIN( 404)			if (hx::IsNotNull( _this4->zpp_inner->inner->head )) {
HXLINE( 405)				if (b->zpp_inner->world) {
HXLINE( 405)					HX_STACK_DO_THROW((HX_("Error: Space::world has no ",d3,43,94,b2) + HX_("worldCOM",0f,c5,83,a4)));
            				}
HXDLIN( 405)				if (hx::IsNull( b->zpp_inner->wrap_worldCOM )) {
HXLINE( 405)					Float x = b->zpp_inner->worldCOMx;
HXDLIN( 405)					Float y = b->zpp_inner->worldCOMy;
HXDLIN( 405)					bool _hx_tmp4;
HXDLIN( 405)					if ((x == x)) {
HXLINE( 405)						_hx_tmp4 = (y != y);
            					}
            					else {
HXLINE( 405)						_hx_tmp4 = true;
            					}
HXDLIN( 405)					if (_hx_tmp4) {
HXLINE( 405)						HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            					}
HXDLIN( 405)					 ::nape::geom::Vec2 ret3;
HXDLIN( 405)					if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE( 405)						ret3 =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            					}
            					else {
HXLINE( 405)						ret3 = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN( 405)						::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret3->zpp_pool;
HXDLIN( 405)						ret3->zpp_pool = null();
HXDLIN( 405)						ret3->zpp_disp = false;
HXDLIN( 405)						if (hx::IsEq( ret3,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 405)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            						}
            					}
HXDLIN( 405)					if (hx::IsNull( ret3->zpp_inner )) {
HXLINE( 405)						 ::zpp_nape::geom::ZPP_Vec2 ret4;
HXDLIN( 405)						{
HXLINE( 405)							if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE( 405)								ret4 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            							}
            							else {
HXLINE( 405)								ret4 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 405)								::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret4->next;
HXDLIN( 405)								ret4->next = null();
            							}
HXDLIN( 405)							ret4->weak = false;
            						}
HXDLIN( 405)						ret4->_immutable = false;
HXDLIN( 405)						{
HXLINE( 405)							ret4->x = x;
HXDLIN( 405)							ret4->y = y;
            						}
HXDLIN( 405)						ret3->zpp_inner = ret4;
HXDLIN( 405)						ret3->zpp_inner->outer = ret3;
            					}
            					else {
HXLINE( 405)						bool _hx_tmp5;
HXDLIN( 405)						if (hx::IsNotNull( ret3 )) {
HXLINE( 405)							_hx_tmp5 = ret3->zpp_disp;
            						}
            						else {
HXLINE( 405)							_hx_tmp5 = false;
            						}
HXDLIN( 405)						if (_hx_tmp5) {
HXLINE( 405)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 405)						{
HXLINE( 405)							 ::zpp_nape::geom::ZPP_Vec2 _this5 = ret3->zpp_inner;
HXDLIN( 405)							if (_this5->_immutable) {
HXLINE( 405)								HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            							}
HXDLIN( 405)							if (hx::IsNotNull( _this5->_isimmutable )) {
HXLINE( 405)								_this5->_isimmutable();
            							}
            						}
HXDLIN( 405)						bool _hx_tmp6;
HXDLIN( 405)						if ((x == x)) {
HXLINE( 405)							_hx_tmp6 = (y != y);
            						}
            						else {
HXLINE( 405)							_hx_tmp6 = true;
            						}
HXDLIN( 405)						if (_hx_tmp6) {
HXLINE( 405)							HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            						}
HXDLIN( 405)						bool _hx_tmp7;
HXDLIN( 405)						bool _hx_tmp8;
HXDLIN( 405)						if (hx::IsNotNull( ret3 )) {
HXLINE( 405)							_hx_tmp8 = ret3->zpp_disp;
            						}
            						else {
HXLINE( 405)							_hx_tmp8 = false;
            						}
HXDLIN( 405)						if (_hx_tmp8) {
HXLINE( 405)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 405)						{
HXLINE( 405)							 ::zpp_nape::geom::ZPP_Vec2 _this6 = ret3->zpp_inner;
HXDLIN( 405)							if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 405)								_this6->_validate();
            							}
            						}
HXDLIN( 405)						if ((ret3->zpp_inner->x == x)) {
HXLINE( 405)							bool _hx_tmp9;
HXDLIN( 405)							if (hx::IsNotNull( ret3 )) {
HXLINE( 405)								_hx_tmp9 = ret3->zpp_disp;
            							}
            							else {
HXLINE( 405)								_hx_tmp9 = false;
            							}
HXDLIN( 405)							if (_hx_tmp9) {
HXLINE( 405)								HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            							}
HXDLIN( 405)							{
HXLINE( 405)								 ::zpp_nape::geom::ZPP_Vec2 _this7 = ret3->zpp_inner;
HXDLIN( 405)								if (hx::IsNotNull( _this7->_validate )) {
HXLINE( 405)									_this7->_validate();
            								}
            							}
HXDLIN( 405)							_hx_tmp7 = (ret3->zpp_inner->y == y);
            						}
            						else {
HXLINE( 405)							_hx_tmp7 = false;
            						}
HXDLIN( 405)						if (!(_hx_tmp7)) {
HXLINE( 405)							{
HXLINE( 405)								ret3->zpp_inner->x = x;
HXDLIN( 405)								ret3->zpp_inner->y = y;
            							}
HXDLIN( 405)							{
HXLINE( 405)								 ::zpp_nape::geom::ZPP_Vec2 _this8 = ret3->zpp_inner;
HXDLIN( 405)								if (hx::IsNotNull( _this8->_invalidate )) {
HXLINE( 405)									_this8->_invalidate(_this8);
            								}
            							}
            						}
            					}
HXDLIN( 405)					ret3->zpp_inner->weak = false;
HXDLIN( 405)					b->zpp_inner->wrap_worldCOM = ret3;
HXDLIN( 405)					b->zpp_inner->wrap_worldCOM->zpp_inner->_inuse = true;
HXDLIN( 405)					b->zpp_inner->wrap_worldCOM->zpp_inner->_immutable = true;
HXDLIN( 405)					b->zpp_inner->wrap_worldCOM->zpp_inner->_validate = b->zpp_inner->getworldCOM_dyn();
            				}
HXDLIN( 405)				 ::nape::geom::Vec2 _hx_tmp10 = b->zpp_inner->wrap_worldCOM;
HXDLIN( 405)				if (b->zpp_inner->world) {
HXLINE( 405)					HX_STACK_DO_THROW(HX_("Error: Space::world has no mass",47,6a,54,2b));
            				}
HXDLIN( 405)				b->zpp_inner->validate_mass();
HXDLIN( 405)				bool _hx_tmp11;
HXDLIN( 405)				if ((b->zpp_inner->massMode == 0)) {
HXLINE( 405)					_hx_tmp11 = hx::IsNull( b->zpp_inner->shapes->head );
            				}
            				else {
HXLINE( 405)					_hx_tmp11 = false;
            				}
HXDLIN( 405)				if (_hx_tmp11) {
HXLINE( 405)					HX_STACK_DO_THROW(HX_("Error: Given current mass mode, Body::mass only makes sense if it contains shapes",3f,ab,6b,cb));
            				}
HXDLIN( 405)				 ::nape::geom::Vec2 _hx_tmp12 = _hx_tmp10->mul(b->zpp_inner->cmass,true);
HXDLIN( 405)				ret2->addeq(_hx_tmp12);
HXLINE( 406)				::Array< Float > total1 = total;
HXDLIN( 406)				int _hx_tmp13 = 0;
HXDLIN( 406)				Float total2 = total1->__get(_hx_tmp13);
HXDLIN( 406)				if (b->zpp_inner->world) {
HXLINE( 406)					HX_STACK_DO_THROW(HX_("Error: Space::world has no mass",47,6a,54,2b));
            				}
HXDLIN( 406)				b->zpp_inner->validate_mass();
HXDLIN( 406)				bool _hx_tmp14;
HXDLIN( 406)				if ((b->zpp_inner->massMode == 0)) {
HXLINE( 406)					_hx_tmp14 = hx::IsNull( b->zpp_inner->shapes->head );
            				}
            				else {
HXLINE( 406)					_hx_tmp14 = false;
            				}
HXDLIN( 406)				if (_hx_tmp14) {
HXLINE( 406)					HX_STACK_DO_THROW(HX_("Error: Given current mass mode, Body::mass only makes sense if it contains shapes",3f,ab,6b,cb));
            				}
HXDLIN( 406)				total1[_hx_tmp13] = (total2 + b->zpp_inner->cmass);
            			}
            		}
            		HX_END_LOCAL_FUNC1((void))

            		bool weak = __o_weak.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_400_COM)
HXLINE( 401)		 ::nape::geom::Vec2 ret;
HXDLIN( 401)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE( 401)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE( 401)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN( 401)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN( 401)			ret->zpp_pool = null();
HXDLIN( 401)			ret->zpp_disp = false;
HXDLIN( 401)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 401)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN( 401)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE( 401)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN( 401)			{
HXLINE( 401)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE( 401)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 401)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 401)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN( 401)					ret1->next = null();
            				}
HXDLIN( 401)				ret1->weak = false;
            			}
HXDLIN( 401)			ret1->_immutable = false;
HXDLIN( 401)			{
HXLINE( 401)				ret1->x = ( (Float)(0) );
HXDLIN( 401)				ret1->y = ( (Float)(0) );
            			}
HXDLIN( 401)			ret->zpp_inner = ret1;
HXDLIN( 401)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE( 401)			bool _hx_tmp;
HXDLIN( 401)			if (hx::IsNotNull( ret )) {
HXLINE( 401)				_hx_tmp = ret->zpp_disp;
            			}
            			else {
HXLINE( 401)				_hx_tmp = false;
            			}
HXDLIN( 401)			if (_hx_tmp) {
HXLINE( 401)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 401)			{
HXLINE( 401)				 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN( 401)				if (_this->_immutable) {
HXLINE( 401)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 401)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 401)					_this->_isimmutable();
            				}
            			}
HXDLIN( 401)			bool _hx_tmp1;
HXDLIN( 401)			bool _hx_tmp2;
HXDLIN( 401)			if (hx::IsNotNull( ret )) {
HXLINE( 401)				_hx_tmp2 = ret->zpp_disp;
            			}
            			else {
HXLINE( 401)				_hx_tmp2 = false;
            			}
HXDLIN( 401)			if (_hx_tmp2) {
HXLINE( 401)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 401)			{
HXLINE( 401)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN( 401)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 401)					_this1->_validate();
            				}
            			}
HXDLIN( 401)			if ((ret->zpp_inner->x == 0)) {
HXLINE( 401)				bool _hx_tmp3;
HXDLIN( 401)				if (hx::IsNotNull( ret )) {
HXLINE( 401)					_hx_tmp3 = ret->zpp_disp;
            				}
            				else {
HXLINE( 401)					_hx_tmp3 = false;
            				}
HXDLIN( 401)				if (_hx_tmp3) {
HXLINE( 401)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 401)				{
HXLINE( 401)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN( 401)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 401)						_this2->_validate();
            					}
            				}
HXDLIN( 401)				_hx_tmp1 = (ret->zpp_inner->y == 0);
            			}
            			else {
HXLINE( 401)				_hx_tmp1 = false;
            			}
HXDLIN( 401)			if (!(_hx_tmp1)) {
HXLINE( 401)				{
HXLINE( 401)					ret->zpp_inner->x = ( (Float)(0) );
HXDLIN( 401)					ret->zpp_inner->y = ( (Float)(0) );
            				}
HXDLIN( 401)				{
HXLINE( 401)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN( 401)					if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE( 401)						_this3->_invalidate(_this3);
            					}
            				}
            			}
            		}
HXDLIN( 401)		ret->zpp_inner->weak = weak;
HXDLIN( 401)		 ::nape::geom::Vec2 ret2 = ret;
HXLINE( 402)		::Array< Float > total = ::Array_obj< Float >::fromData( _hx_array_data_34428fa1_21,1);
HXLINE( 403)		this->visitBodies( ::Dynamic(new _hx_Closure_0(total,ret2)));
HXLINE( 410)		if ((total->__get(0) == ((Float)0.0))) {
HXLINE( 410)			HX_STACK_DO_THROW(HX_("Error: COM of an empty Compound is undefined silly",e8,49,f3,05));
            		}
HXLINE( 412)		ret2->muleq((( (Float)(1) ) / total->__get(0)));
HXLINE( 413)		return ret2;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,COM,return )

 ::nape::phys::Compound Compound_obj::translate( ::nape::geom::Vec2 translation){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0, ::nape::geom::Vec2,translation) HXARGC(1)
            		void _hx_run( ::nape::phys::Body b){
            			HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_436_translate)
HXLINE( 436)			if (hx::IsNull( b->zpp_inner->wrap_pos )) {
HXLINE( 436)				b->zpp_inner->setupPosition();
            			}
HXDLIN( 436)			b->zpp_inner->wrap_pos->addeq(translation);
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_425_translate)
HXLINE( 428)		bool _hx_tmp;
HXDLIN( 428)		if (hx::IsNotNull( translation )) {
HXLINE( 428)			_hx_tmp = translation->zpp_disp;
            		}
            		else {
HXLINE( 428)			_hx_tmp = false;
            		}
HXDLIN( 428)		if (_hx_tmp) {
HXLINE( 428)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 432)		if (hx::IsNull( translation )) {
HXLINE( 432)			HX_STACK_DO_THROW(HX_("Error: Cannot translate by null Vec2",8f,5c,4d,00));
            		}
HXLINE( 434)		bool weak = translation->zpp_inner->weak;
HXLINE( 435)		translation->zpp_inner->weak = false;
HXLINE( 436)		this->visitBodies( ::Dynamic(new _hx_Closure_0(translation)));
HXLINE( 437)		translation->zpp_inner->weak = weak;
HXLINE( 438)		if (translation->zpp_inner->weak) {
HXLINE( 442)			bool _hx_tmp1;
HXDLIN( 442)			if (hx::IsNotNull( translation )) {
HXLINE( 442)				_hx_tmp1 = translation->zpp_disp;
            			}
            			else {
HXLINE( 442)				_hx_tmp1 = false;
            			}
HXDLIN( 442)			if (_hx_tmp1) {
HXLINE( 442)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 442)			{
HXLINE( 442)				 ::zpp_nape::geom::ZPP_Vec2 _this = translation->zpp_inner;
HXDLIN( 442)				if (_this->_immutable) {
HXLINE( 442)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 442)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 442)					_this->_isimmutable();
            				}
            			}
HXDLIN( 442)			if (translation->zpp_inner->_inuse) {
HXLINE( 442)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 442)			 ::zpp_nape::geom::ZPP_Vec2 inner = translation->zpp_inner;
HXDLIN( 442)			translation->zpp_inner->outer = null();
HXDLIN( 442)			translation->zpp_inner = null();
HXDLIN( 442)			{
HXLINE( 442)				 ::nape::geom::Vec2 o = translation;
HXDLIN( 442)				o->zpp_pool = null();
HXDLIN( 442)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 442)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE( 442)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN( 442)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 442)				o->zpp_disp = true;
            			}
HXDLIN( 442)			{
HXLINE( 442)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 442)				{
HXLINE( 442)					if (hx::IsNotNull( o1->outer )) {
HXLINE( 442)						o1->outer->zpp_inner = null();
HXDLIN( 442)						o1->outer = null();
            					}
HXDLIN( 442)					o1->_isimmutable = null();
HXDLIN( 442)					o1->_validate = null();
HXDLIN( 442)					o1->_invalidate = null();
            				}
HXDLIN( 442)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 442)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE( 449)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Compound_obj,translate,return )

 ::nape::phys::Compound Compound_obj::rotate( ::nape::geom::Vec2 centre,Float angle){
            		HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_0,Float,angle, ::nape::geom::Vec2,centre) HXARGC(1)
            		void _hx_run( ::nape::phys::Body b){
            			HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_476_rotate)
HXLINE( 476)			b->rotate(centre,angle);
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_STACKFRAME(&_hx_pos_10b50cbfe0c4540d_462_rotate)
HXLINE( 465)		bool _hx_tmp;
HXDLIN( 465)		if (hx::IsNotNull( centre )) {
HXLINE( 465)			_hx_tmp = centre->zpp_disp;
            		}
            		else {
HXLINE( 465)			_hx_tmp = false;
            		}
HXDLIN( 465)		if (_hx_tmp) {
HXLINE( 465)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 469)		if (hx::IsNull( centre )) {
HXLINE( 469)			HX_STACK_DO_THROW(HX_("Error: Cannot rotate about a null Vec2",ef,7f,59,a6));
            		}
HXLINE( 472)		if ((angle != angle)) {
HXLINE( 472)			HX_STACK_DO_THROW(HX_("Error: Cannot rotate by NaN radians",da,44,34,35));
            		}
HXLINE( 474)		bool weak = centre->zpp_inner->weak;
HXLINE( 475)		centre->zpp_inner->weak = false;
HXLINE( 476)		this->visitBodies( ::Dynamic(new _hx_Closure_0(angle,centre)));
HXLINE( 477)		centre->zpp_inner->weak = weak;
HXLINE( 478)		if (centre->zpp_inner->weak) {
HXLINE( 482)			bool _hx_tmp1;
HXDLIN( 482)			if (hx::IsNotNull( centre )) {
HXLINE( 482)				_hx_tmp1 = centre->zpp_disp;
            			}
            			else {
HXLINE( 482)				_hx_tmp1 = false;
            			}
HXDLIN( 482)			if (_hx_tmp1) {
HXLINE( 482)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 482)			{
HXLINE( 482)				 ::zpp_nape::geom::ZPP_Vec2 _this = centre->zpp_inner;
HXDLIN( 482)				if (_this->_immutable) {
HXLINE( 482)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 482)				if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 482)					_this->_isimmutable();
            				}
            			}
HXDLIN( 482)			if (centre->zpp_inner->_inuse) {
HXLINE( 482)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 482)			 ::zpp_nape::geom::ZPP_Vec2 inner = centre->zpp_inner;
HXDLIN( 482)			centre->zpp_inner->outer = null();
HXDLIN( 482)			centre->zpp_inner = null();
HXDLIN( 482)			{
HXLINE( 482)				 ::nape::geom::Vec2 o = centre;
HXDLIN( 482)				o->zpp_pool = null();
HXDLIN( 482)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 482)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE( 482)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN( 482)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 482)				o->zpp_disp = true;
            			}
HXDLIN( 482)			{
HXLINE( 482)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 482)				{
HXLINE( 482)					if (hx::IsNotNull( o1->outer )) {
HXLINE( 482)						o1->outer->zpp_inner = null();
HXDLIN( 482)						o1->outer = null();
            					}
HXDLIN( 482)					o1->_isimmutable = null();
HXDLIN( 482)					o1->_validate = null();
HXDLIN( 482)					o1->_invalidate = null();
            				}
HXDLIN( 482)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 482)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE( 489)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Compound_obj,rotate,return )


hx::ObjectPtr< Compound_obj > Compound_obj::__new() {
	hx::ObjectPtr< Compound_obj > __this = new Compound_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Compound_obj > Compound_obj::__alloc(hx::Ctx *_hx_ctx) {
	Compound_obj *__this = (Compound_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Compound_obj), true, "nape.phys.Compound"));
	*(void **)__this = Compound_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Compound_obj::Compound_obj()
{
}

void Compound_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Compound);
	HX_MARK_MEMBER_NAME(zpp_inner,"zpp_inner");
	 ::nape::phys::Interactor_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Compound_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(zpp_inner,"zpp_inner");
	 ::nape::phys::Interactor_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Compound_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"COM") ) { return hx::Val( COM_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_space() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bodies") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_bodies() ); }
		if (HX_FIELD_EQ(inName,"rotate") ) { return hx::Val( rotate_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"compound") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_compound() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { return hx::Val( zpp_inner ); }
		if (HX_FIELD_EQ(inName,"compounds") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_compounds() ); }
		if (HX_FIELD_EQ(inName,"get_space") ) { return hx::Val( get_space_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_space") ) { return hx::Val( set_space_dyn() ); }
		if (HX_FIELD_EQ(inName,"translate") ) { return hx::Val( translate_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_bodies") ) { return hx::Val( get_bodies_dyn() ); }
		if (HX_FIELD_EQ(inName,"breakApart") ) { return hx::Val( breakApart_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"constraints") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_constraints() ); }
		if (HX_FIELD_EQ(inName,"visitBodies") ) { return hx::Val( visitBodies_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_compound") ) { return hx::Val( get_compound_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_compound") ) { return hx::Val( set_compound_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"get_compounds") ) { return hx::Val( get_compounds_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"visitCompounds") ) { return hx::Val( visitCompounds_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_constraints") ) { return hx::Val( get_constraints_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"visitConstraints") ) { return hx::Val( visitConstraints_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Compound_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_space(inValue.Cast<  ::nape::space::Space >()) ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"compound") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_compound(inValue.Cast<  ::nape::phys::Compound >()) ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { zpp_inner=inValue.Cast<  ::zpp_nape::phys::ZPP_Compound >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Compound_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("zpp_inner",51,65,85,78));
	outFields->push(HX_("bodies",80,1b,dd,5a));
	outFields->push(HX_("constraints",76,51,b4,17));
	outFields->push(HX_("compounds",a8,3a,fb,13));
	outFields->push(HX_("compound",6b,c3,cf,81));
	outFields->push(HX_("space",c6,8c,66,81));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Compound_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::zpp_nape::phys::ZPP_Compound */ ,(int)offsetof(Compound_obj,zpp_inner),HX_("zpp_inner",51,65,85,78)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Compound_obj_sStaticStorageInfo = 0;
#endif

static ::String Compound_obj_sMemberFields[] = {
	HX_("zpp_inner",51,65,85,78),
	HX_("get_bodies",49,8b,64,4b),
	HX_("get_constraints",0d,09,96,d8),
	HX_("get_compounds",7f,0e,5f,d5),
	HX_("get_compound",74,77,e9,36),
	HX_("set_compound",e8,9a,e2,4b),
	HX_("get_space",1d,e9,0f,c5),
	HX_("set_space",29,d5,60,a8),
	HX_("toString",ac,d0,6e,38),
	HX_("copy",b5,bb,c4,41),
	HX_("breakApart",95,df,18,5e),
	HX_("visitBodies",ab,f3,5e,e4),
	HX_("visitConstraints",6b,fd,db,c1),
	HX_("visitCompounds",5d,8f,9c,93),
	HX_("COM",21,1c,33,00),
	HX_("translate",4e,d7,7f,49),
	HX_("rotate",5b,46,20,cb),
	::String(null()) };

hx::Class Compound_obj::__mClass;

void Compound_obj::__register()
{
	Compound_obj _hx_dummy;
	Compound_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.phys.Compound",a1,8f,42,34);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Compound_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Compound_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Compound_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Compound_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace phys
