// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_Config
#include <hxinc/nape/Config.h>
#endif
#ifndef INCLUDED_nape_dynamics_InteractionFilter
#include <hxinc/nape/dynamics/InteractionFilter.h>
#endif
#ifndef INCLUDED_nape_geom_AABB
#include <hxinc/nape/geom/AABB.h>
#endif
#ifndef INCLUDED_nape_geom_Mat23
#include <hxinc/nape/geom/Mat23.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_FluidProperties
#include <hxinc/nape/phys/FluidProperties.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_phys_Material
#include <hxinc/nape/phys/Material.h>
#endif
#ifndef INCLUDED_nape_shape_Circle
#include <hxinc/nape/shape/Circle.h>
#endif
#ifndef INCLUDED_nape_shape_Polygon
#include <hxinc/nape/shape/Polygon.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <hxinc/nape/shape/Shape.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeList
#include <hxinc/nape/shape/ShapeList.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeType
#include <hxinc/nape/shape/ShapeType.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_InteractionFilter
#include <hxinc/zpp_nape/dynamics/ZPP_InteractionFilter.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_AABB
#include <hxinc/zpp_nape/geom/ZPP_AABB.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Collide
#include <hxinc/zpp_nape/geom/ZPP_Collide.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Geom
#include <hxinc/zpp_nape/geom/ZPP_Geom.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_FluidProperties
#include <hxinc/zpp_nape/phys/ZPP_FluidProperties.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Material
#include <hxinc/zpp_nape/phys/ZPP_Material.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Circle
#include <hxinc/zpp_nape/shape/ZPP_Circle.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Polygon
#include <hxinc/zpp_nape/shape/ZPP_Polygon.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <hxinc/zpp_nape/shape/ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_PubPool
#include <hxinc/zpp_nape/util/ZPP_PubPool.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ShapeList
#include <hxinc/zpp_nape/util/ZPP_ShapeList.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_89f9be17cd3263cd_177_new,"nape.shape.Shape","new",0x749b3160,"nape.shape.Shape.new","nape/shape/Shape.hx",177,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_188_get_type,"nape.shape.Shape","get_type",0x151cad43,"nape.shape.Shape.get_type","nape/shape/Shape.hx",188,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_198_isCircle,"nape.shape.Shape","isCircle",0xf6d00c9a,"nape.shape.Shape.isCircle","nape/shape/Shape.hx",198,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_208_isPolygon,"nape.shape.Shape","isPolygon",0x1c15a0b0,"nape.shape.Shape.isPolygon","nape/shape/Shape.hx",208,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_240_get_body,"nape.shape.Shape","get_body",0x092f352b,"nape.shape.Shape.get_body","nape/shape/Shape.hx",240,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_242_set_body,"nape.shape.Shape","set_body",0xb78c8e9f,"nape.shape.Shape.set_body","nape/shape/Shape.hx",242,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_258_get_castCircle,"nape.shape.Shape","get_castCircle",0xcfe1e578,"nape.shape.Shape.get_castCircle","nape/shape/Shape.hx",258,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_266_get_castPolygon,"nape.shape.Shape","get_castPolygon",0x32a18a12,"nape.shape.Shape.get_castPolygon","nape/shape/Shape.hx",266,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_279_get_worldCOM,"nape.shape.Shape","get_worldCOM",0xdbe1f818,"nape.shape.Shape.get_worldCOM","nape/shape/Shape.hx",279,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_300_get_localCOM,"nape.shape.Shape","get_localCOM",0x173dfa9f,"nape.shape.Shape.get_localCOM","nape/shape/Shape.hx",300,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_307_set_localCOM,"nape.shape.Shape","set_localCOM",0x2c371e13,"nape.shape.Shape.set_localCOM","nape/shape/Shape.hx",307,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_328_get_area,"nape.shape.Shape","get_area",0x08884616,"nape.shape.Shape.get_area","nape/shape/Shape.hx",328,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_337_get_inertia,"nape.shape.Shape","get_inertia",0x0ec57211,"nape.shape.Shape.get_inertia","nape/shape/Shape.hx",337,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_346_get_angDrag,"nape.shape.Shape","get_angDrag",0xca7d8905,"nape.shape.Shape.get_angDrag","nape/shape/Shape.hx",346,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_358_get_material,"nape.shape.Shape","get_material",0x28038fb0,"nape.shape.Shape.get_material","nape/shape/Shape.hx",358,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_360_set_material,"nape.shape.Shape","set_material",0x3cfcb324,"nape.shape.Shape.set_material","nape/shape/Shape.hx",360,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_378_get_filter,"nape.shape.Shape","get_filter",0x45934e81,"nape.shape.Shape.get_filter","nape/shape/Shape.hx",378,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_380_set_filter,"nape.shape.Shape","set_filter",0x4910ecf5,"nape.shape.Shape.set_filter","nape/shape/Shape.hx",380,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_400_get_fluidProperties,"nape.shape.Shape","get_fluidProperties",0xa4643ab4,"nape.shape.Shape.get_fluidProperties","nape/shape/Shape.hx",400,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_405_set_fluidProperties,"nape.shape.Shape","set_fluidProperties",0xe1012dc0,"nape.shape.Shape.set_fluidProperties","nape/shape/Shape.hx",405,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_429_get_fluidEnabled,"nape.shape.Shape","get_fluidEnabled",0x76ed7320,"nape.shape.Shape.get_fluidEnabled","nape/shape/Shape.hx",429,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_431_set_fluidEnabled,"nape.shape.Shape","set_fluidEnabled",0xcd2f6094,"nape.shape.Shape.set_fluidEnabled","nape/shape/Shape.hx",431,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_454_get_sensorEnabled,"nape.shape.Shape","get_sensorEnabled",0x622941be,"nape.shape.Shape.get_sensorEnabled","nape/shape/Shape.hx",454,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_456_set_sensorEnabled,"nape.shape.Shape","set_sensorEnabled",0x859719ca,"nape.shape.Shape.set_sensorEnabled","nape/shape/Shape.hx",456,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_476_get_bounds,"nape.shape.Shape","get_bounds",0x267bb53e,"nape.shape.Shape.get_bounds","nape/shape/Shape.hx",476,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_489_translate,"nape.shape.Shape","translate",0x4f05f84e,"nape.shape.Shape.translate","nape/shape/Shape.hx",489,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_529_scale,"nape.shape.Shape","scale",0x16706f8a,"nape.shape.Shape.scale","nape/shape/Shape.hx",529,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_559_rotate,"nape.shape.Shape","rotate",0x1aeb855b,"nape.shape.Shape.rotate","nape/shape/Shape.hx",559,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_586_transform,"nape.shape.Shape","transform",0x4b194e6c,"nape.shape.Shape.transform","nape/shape/Shape.hx",586,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_618_contains,"nape.shape.Shape","contains",0x74d4591f,"nape.shape.Shape.contains","nape/shape/Shape.hx",618,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_657_copy,"nape.shape.Shape","copy",0x8bf23ab5,"nape.shape.Shape.copy","nape/shape/Shape.hx",657,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_662_toString,"nape.shape.Shape","toString",0x80c7cfac,"nape.shape.Shape.toString","nape/shape/Shape.hx",662,0x036d22d2)
HX_LOCAL_STACK_FRAME(_hx_pos_89f9be17cd3263cd_214_boot,"nape.shape.Shape","boot",0x8b490332,"nape.shape.Shape.boot","nape/shape/Shape.hx",214,0x036d22d2)
namespace nape{
namespace shape{

void Shape_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_177_new)
HXLINE( 181)		this->zpp_inner = null();
HXLINE( 218)		::nape::phys::Interactor_obj::zpp_internalAlloc = true;
HXLINE( 219)		super::__construct();
HXLINE( 220)		::nape::phys::Interactor_obj::zpp_internalAlloc = false;
HXLINE( 226)		if (!(::nape::shape::Shape_obj::zpp_internalAlloc)) {
HXLINE( 226)			HX_STACK_DO_THROW(HX_("Error: Shape cannot be instantiated derp!",49,63,3e,47));
            		}
            	}

Dynamic Shape_obj::__CreateEmpty() { return new Shape_obj; }

void *Shape_obj::_hx_vtable = 0;

Dynamic Shape_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Shape_obj > _hx_result = new Shape_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Shape_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x643c1bb3) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x643c1bb3;
	} else {
		return inClassId==(int)0x7e0877dc;
	}
}

 ::nape::shape::ShapeType Shape_obj::get_type(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_188_get_type)
HXDLIN( 188)		return ::zpp_nape::shape::ZPP_Shape_obj::types->__get(this->zpp_inner->type).StaticCast<  ::nape::shape::ShapeType >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_type,return )

bool Shape_obj::isCircle(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_198_isCircle)
HXDLIN( 198)		return (this->zpp_inner->type == 0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,isCircle,return )

bool Shape_obj::isPolygon(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_208_isPolygon)
HXDLIN( 208)		return (this->zpp_inner->type == 1);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,isPolygon,return )

 ::nape::phys::Body Shape_obj::get_body(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_240_get_body)
HXDLIN( 240)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXDLIN( 240)			return this->zpp_inner->body->outer;
            		}
            		else {
HXDLIN( 240)			return null();
            		}
HXDLIN( 240)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_body,return )

 ::nape::phys::Body Shape_obj::set_body( ::nape::phys::Body body){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_242_set_body)
HXLINE( 243)		{
HXLINE( 244)			this->zpp_inner->immutable_midstep(HX_("Shape::body",23,17,ec,18));
HXLINE( 245)			 ::nape::phys::Body _hx_tmp;
HXDLIN( 245)			if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 245)				_hx_tmp = this->zpp_inner->body->outer;
            			}
            			else {
HXLINE( 245)				_hx_tmp = null();
            			}
HXDLIN( 245)			if (hx::IsNotEq( _hx_tmp,body )) {
HXLINE( 246)				if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 246)					 ::nape::phys::Body _hx_tmp1;
HXDLIN( 246)					if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 246)						_hx_tmp1 = this->zpp_inner->body->outer;
            					}
            					else {
HXLINE( 246)						_hx_tmp1 = null();
            					}
HXDLIN( 246)					_hx_tmp1->zpp_inner->wrap_shapes->remove(hx::ObjectPtr<OBJ_>(this));
            				}
HXLINE( 247)				if (hx::IsNotNull( body )) {
HXLINE( 247)					 ::nape::shape::ShapeList _this = body->zpp_inner->wrap_shapes;
HXDLIN( 247)					if (_this->zpp_inner->reverse_flag) {
HXLINE( 247)						_this->push(hx::ObjectPtr<OBJ_>(this));
            					}
            					else {
HXLINE( 247)						_this->unshift(hx::ObjectPtr<OBJ_>(this));
            					}
            				}
            			}
            		}
HXLINE( 250)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 250)			return this->zpp_inner->body->outer;
            		}
            		else {
HXLINE( 250)			return null();
            		}
HXDLIN( 250)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_body,return )

 ::nape::shape::Circle Shape_obj::get_castCircle(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_258_get_castCircle)
HXDLIN( 258)		if ((this->zpp_inner->type == 0)) {
HXDLIN( 258)			return this->zpp_inner->circle->outer_zn;
            		}
            		else {
HXDLIN( 258)			return null();
            		}
HXDLIN( 258)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_castCircle,return )

 ::nape::shape::Polygon Shape_obj::get_castPolygon(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_266_get_castPolygon)
HXDLIN( 266)		if ((this->zpp_inner->type == 1)) {
HXDLIN( 266)			return this->zpp_inner->polygon->outer_zn;
            		}
            		else {
HXDLIN( 266)			return null();
            		}
HXDLIN( 266)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_castPolygon,return )

 ::nape::geom::Vec2 Shape_obj::get_worldCOM(){
            	HX_GC_STACKFRAME(&_hx_pos_89f9be17cd3263cd_279_get_worldCOM)
HXLINE( 280)		if (hx::IsNull( this->zpp_inner->wrap_worldCOM )) {
HXLINE( 281)			Float x = this->zpp_inner->worldCOMx;
HXDLIN( 281)			Float y = this->zpp_inner->worldCOMy;
HXDLIN( 281)			bool _hx_tmp;
HXDLIN( 281)			if ((x == x)) {
HXLINE( 281)				_hx_tmp = (y != y);
            			}
            			else {
HXLINE( 281)				_hx_tmp = true;
            			}
HXDLIN( 281)			if (_hx_tmp) {
HXLINE( 281)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN( 281)			 ::nape::geom::Vec2 ret;
HXDLIN( 281)			if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE( 281)				ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            			}
            			else {
HXLINE( 281)				ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN( 281)				::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN( 281)				ret->zpp_pool = null();
HXDLIN( 281)				ret->zpp_disp = false;
HXDLIN( 281)				if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 281)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            				}
            			}
HXDLIN( 281)			if (hx::IsNull( ret->zpp_inner )) {
HXLINE( 281)				 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN( 281)				{
HXLINE( 281)					if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE( 281)						ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            					}
            					else {
HXLINE( 281)						ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 281)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN( 281)						ret1->next = null();
            					}
HXDLIN( 281)					ret1->weak = false;
            				}
HXDLIN( 281)				ret1->_immutable = false;
HXDLIN( 281)				{
HXLINE( 281)					ret1->x = x;
HXDLIN( 281)					ret1->y = y;
            				}
HXDLIN( 281)				ret->zpp_inner = ret1;
HXDLIN( 281)				ret->zpp_inner->outer = ret;
            			}
            			else {
HXLINE( 281)				bool _hx_tmp1;
HXDLIN( 281)				if (hx::IsNotNull( ret )) {
HXLINE( 281)					_hx_tmp1 = ret->zpp_disp;
            				}
            				else {
HXLINE( 281)					_hx_tmp1 = false;
            				}
HXDLIN( 281)				if (_hx_tmp1) {
HXLINE( 281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 281)				{
HXLINE( 281)					 ::zpp_nape::geom::ZPP_Vec2 _this = ret->zpp_inner;
HXDLIN( 281)					if (_this->_immutable) {
HXLINE( 281)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 281)					if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 281)						_this->_isimmutable();
            					}
            				}
HXDLIN( 281)				bool _hx_tmp2;
HXDLIN( 281)				if ((x == x)) {
HXLINE( 281)					_hx_tmp2 = (y != y);
            				}
            				else {
HXLINE( 281)					_hx_tmp2 = true;
            				}
HXDLIN( 281)				if (_hx_tmp2) {
HXLINE( 281)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 281)				bool _hx_tmp3;
HXDLIN( 281)				bool _hx_tmp4;
HXDLIN( 281)				if (hx::IsNotNull( ret )) {
HXLINE( 281)					_hx_tmp4 = ret->zpp_disp;
            				}
            				else {
HXLINE( 281)					_hx_tmp4 = false;
            				}
HXDLIN( 281)				if (_hx_tmp4) {
HXLINE( 281)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 281)				{
HXLINE( 281)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = ret->zpp_inner;
HXDLIN( 281)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 281)						_this1->_validate();
            					}
            				}
HXDLIN( 281)				if ((ret->zpp_inner->x == x)) {
HXLINE( 281)					bool _hx_tmp5;
HXDLIN( 281)					if (hx::IsNotNull( ret )) {
HXLINE( 281)						_hx_tmp5 = ret->zpp_disp;
            					}
            					else {
HXLINE( 281)						_hx_tmp5 = false;
            					}
HXDLIN( 281)					if (_hx_tmp5) {
HXLINE( 281)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 281)					{
HXLINE( 281)						 ::zpp_nape::geom::ZPP_Vec2 _this2 = ret->zpp_inner;
HXDLIN( 281)						if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 281)							_this2->_validate();
            						}
            					}
HXDLIN( 281)					_hx_tmp3 = (ret->zpp_inner->y == y);
            				}
            				else {
HXLINE( 281)					_hx_tmp3 = false;
            				}
HXDLIN( 281)				if (!(_hx_tmp3)) {
HXLINE( 281)					{
HXLINE( 281)						ret->zpp_inner->x = x;
HXDLIN( 281)						ret->zpp_inner->y = y;
            					}
HXDLIN( 281)					{
HXLINE( 281)						 ::zpp_nape::geom::ZPP_Vec2 _this3 = ret->zpp_inner;
HXDLIN( 281)						if (hx::IsNotNull( _this3->_invalidate )) {
HXLINE( 281)							_this3->_invalidate(_this3);
            						}
            					}
            				}
            			}
HXDLIN( 281)			ret->zpp_inner->weak = false;
HXDLIN( 281)			this->zpp_inner->wrap_worldCOM = ret;
HXLINE( 282)			this->zpp_inner->wrap_worldCOM->zpp_inner->_inuse = true;
HXLINE( 283)			this->zpp_inner->wrap_worldCOM->zpp_inner->_immutable = true;
HXLINE( 284)			this->zpp_inner->wrap_worldCOM->zpp_inner->_validate = this->zpp_inner->getworldCOM_dyn();
            		}
HXLINE( 286)		return this->zpp_inner->wrap_worldCOM;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_worldCOM,return )

 ::nape::geom::Vec2 Shape_obj::get_localCOM(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_300_get_localCOM)
HXLINE( 301)		if (hx::IsNull( this->zpp_inner->wrap_localCOM )) {
HXLINE( 302)			if ((this->zpp_inner->type == 0)) {
HXLINE( 302)				this->zpp_inner->circle->setupLocalCOM();
            			}
            			else {
HXLINE( 303)				this->zpp_inner->polygon->setupLocalCOM();
            			}
            		}
HXLINE( 305)		return this->zpp_inner->wrap_localCOM;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_localCOM,return )

 ::nape::geom::Vec2 Shape_obj::set_localCOM( ::nape::geom::Vec2 localCOM){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_307_set_localCOM)
HXLINE( 308)		{
HXLINE( 309)			this->zpp_inner->immutable_midstep(HX_("Body::localCOM",98,27,7e,42));
HXLINE( 312)			bool _hx_tmp;
HXDLIN( 312)			if (hx::IsNotNull( localCOM )) {
HXLINE( 312)				_hx_tmp = localCOM->zpp_disp;
            			}
            			else {
HXLINE( 312)				_hx_tmp = false;
            			}
HXDLIN( 312)			if (_hx_tmp) {
HXLINE( 312)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 316)			bool _hx_tmp1;
HXDLIN( 316)			bool _hx_tmp2;
HXDLIN( 316)			if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 316)				_hx_tmp2 = hx::IsNotNull( this->zpp_inner->body->space );
            			}
            			else {
HXLINE( 316)				_hx_tmp2 = false;
            			}
HXDLIN( 316)			if (_hx_tmp2) {
HXLINE( 316)				_hx_tmp1 = (this->zpp_inner->body->type == 1);
            			}
            			else {
HXLINE( 316)				_hx_tmp1 = false;
            			}
HXDLIN( 316)			if (_hx_tmp1) {
HXLINE( 316)				HX_STACK_DO_THROW(HX_("Error: Cannot modify Shape belonging to a static Object once inside a Space",82,96,75,9f));
            			}
HXLINE( 317)			if (hx::IsNull( localCOM )) {
HXLINE( 317)				HX_STACK_DO_THROW(HX_("Error: Shape::localCOM cannot be null",1e,36,fd,e4));
            			}
HXLINE( 319)			{
HXLINE( 319)				if (hx::IsNull( this->zpp_inner->wrap_localCOM )) {
HXLINE( 319)					if ((this->zpp_inner->type == 0)) {
HXLINE( 319)						this->zpp_inner->circle->setupLocalCOM();
            					}
            					else {
HXLINE( 319)						this->zpp_inner->polygon->setupLocalCOM();
            					}
            				}
HXDLIN( 319)				 ::nape::geom::Vec2 _this = this->zpp_inner->wrap_localCOM;
HXDLIN( 319)				bool _hx_tmp3;
HXDLIN( 319)				if (hx::IsNotNull( _this )) {
HXLINE( 319)					_hx_tmp3 = _this->zpp_disp;
            				}
            				else {
HXLINE( 319)					_hx_tmp3 = false;
            				}
HXDLIN( 319)				if (_hx_tmp3) {
HXLINE( 319)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 319)				bool _hx_tmp4;
HXDLIN( 319)				if (hx::IsNotNull( localCOM )) {
HXLINE( 319)					_hx_tmp4 = localCOM->zpp_disp;
            				}
            				else {
HXLINE( 319)					_hx_tmp4 = false;
            				}
HXDLIN( 319)				if (_hx_tmp4) {
HXLINE( 319)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 319)				{
HXLINE( 319)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 319)					if (_this1->_immutable) {
HXLINE( 319)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 319)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 319)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 319)				if (hx::IsNull( localCOM )) {
HXLINE( 319)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 319)				bool _hx_tmp5;
HXDLIN( 319)				if (hx::IsNotNull( localCOM )) {
HXLINE( 319)					_hx_tmp5 = localCOM->zpp_disp;
            				}
            				else {
HXLINE( 319)					_hx_tmp5 = false;
            				}
HXDLIN( 319)				if (_hx_tmp5) {
HXLINE( 319)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 319)				{
HXLINE( 319)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = localCOM->zpp_inner;
HXDLIN( 319)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 319)						_this2->_validate();
            					}
            				}
HXDLIN( 319)				Float x = localCOM->zpp_inner->x;
HXDLIN( 319)				bool _hx_tmp6;
HXDLIN( 319)				if (hx::IsNotNull( localCOM )) {
HXLINE( 319)					_hx_tmp6 = localCOM->zpp_disp;
            				}
            				else {
HXLINE( 319)					_hx_tmp6 = false;
            				}
HXDLIN( 319)				if (_hx_tmp6) {
HXLINE( 319)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 319)				{
HXLINE( 319)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = localCOM->zpp_inner;
HXDLIN( 319)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 319)						_this3->_validate();
            					}
            				}
HXDLIN( 319)				Float y = localCOM->zpp_inner->y;
HXDLIN( 319)				bool _hx_tmp7;
HXDLIN( 319)				if (hx::IsNotNull( _this )) {
HXLINE( 319)					_hx_tmp7 = _this->zpp_disp;
            				}
            				else {
HXLINE( 319)					_hx_tmp7 = false;
            				}
HXDLIN( 319)				if (_hx_tmp7) {
HXLINE( 319)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 319)				{
HXLINE( 319)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 319)					if (_this4->_immutable) {
HXLINE( 319)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 319)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 319)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 319)				bool _hx_tmp8;
HXDLIN( 319)				if ((x == x)) {
HXLINE( 319)					_hx_tmp8 = (y != y);
            				}
            				else {
HXLINE( 319)					_hx_tmp8 = true;
            				}
HXDLIN( 319)				if (_hx_tmp8) {
HXLINE( 319)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 319)				bool _hx_tmp9;
HXDLIN( 319)				bool _hx_tmp10;
HXDLIN( 319)				if (hx::IsNotNull( _this )) {
HXLINE( 319)					_hx_tmp10 = _this->zpp_disp;
            				}
            				else {
HXLINE( 319)					_hx_tmp10 = false;
            				}
HXDLIN( 319)				if (_hx_tmp10) {
HXLINE( 319)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 319)				{
HXLINE( 319)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 319)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 319)						_this5->_validate();
            					}
            				}
HXDLIN( 319)				if ((_this->zpp_inner->x == x)) {
HXLINE( 319)					bool _hx_tmp11;
HXDLIN( 319)					if (hx::IsNotNull( _this )) {
HXLINE( 319)						_hx_tmp11 = _this->zpp_disp;
            					}
            					else {
HXLINE( 319)						_hx_tmp11 = false;
            					}
HXDLIN( 319)					if (_hx_tmp11) {
HXLINE( 319)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 319)					{
HXLINE( 319)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 319)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 319)							_this6->_validate();
            						}
            					}
HXDLIN( 319)					_hx_tmp9 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 319)					_hx_tmp9 = false;
            				}
HXDLIN( 319)				if (!(_hx_tmp9)) {
HXLINE( 319)					{
HXLINE( 319)						_this->zpp_inner->x = x;
HXDLIN( 319)						_this->zpp_inner->y = y;
            					}
HXDLIN( 319)					{
HXLINE( 319)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 319)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 319)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 319)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 319)				if (localCOM->zpp_inner->weak) {
HXLINE( 319)					bool _hx_tmp12;
HXDLIN( 319)					if (hx::IsNotNull( localCOM )) {
HXLINE( 319)						_hx_tmp12 = localCOM->zpp_disp;
            					}
            					else {
HXLINE( 319)						_hx_tmp12 = false;
            					}
HXDLIN( 319)					if (_hx_tmp12) {
HXLINE( 319)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 319)					{
HXLINE( 319)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = localCOM->zpp_inner;
HXDLIN( 319)						if (_this8->_immutable) {
HXLINE( 319)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 319)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 319)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 319)					if (localCOM->zpp_inner->_inuse) {
HXLINE( 319)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 319)					 ::zpp_nape::geom::ZPP_Vec2 inner = localCOM->zpp_inner;
HXDLIN( 319)					localCOM->zpp_inner->outer = null();
HXDLIN( 319)					localCOM->zpp_inner = null();
HXDLIN( 319)					{
HXLINE( 319)						 ::nape::geom::Vec2 o = localCOM;
HXDLIN( 319)						o->zpp_pool = null();
HXDLIN( 319)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 319)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 319)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 319)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 319)						o->zpp_disp = true;
            					}
HXDLIN( 319)					{
HXLINE( 319)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 319)						{
HXLINE( 319)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 319)								o1->outer->zpp_inner = null();
HXDLIN( 319)								o1->outer = null();
            							}
HXDLIN( 319)							o1->_isimmutable = null();
HXDLIN( 319)							o1->_validate = null();
HXDLIN( 319)							o1->_invalidate = null();
            						}
HXDLIN( 319)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 319)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 321)		if (hx::IsNull( this->zpp_inner->wrap_localCOM )) {
HXLINE( 321)			if ((this->zpp_inner->type == 0)) {
HXLINE( 321)				this->zpp_inner->circle->setupLocalCOM();
            			}
            			else {
HXLINE( 321)				this->zpp_inner->polygon->setupLocalCOM();
            			}
            		}
HXDLIN( 321)		return this->zpp_inner->wrap_localCOM;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_localCOM,return )

Float Shape_obj::get_area(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_328_get_area)
HXLINE( 329)		this->zpp_inner->validate_area_inertia();
HXLINE( 330)		return this->zpp_inner->area;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_area,return )

Float Shape_obj::get_inertia(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_337_get_inertia)
HXLINE( 338)		this->zpp_inner->validate_area_inertia();
HXLINE( 339)		return this->zpp_inner->inertia;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_inertia,return )

Float Shape_obj::get_angDrag(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_346_get_angDrag)
HXLINE( 347)		this->zpp_inner->validate_angDrag();
HXLINE( 348)		return this->zpp_inner->angDrag;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_angDrag,return )

 ::nape::phys::Material Shape_obj::get_material(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_358_get_material)
HXDLIN( 358)		return this->zpp_inner->material->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_material,return )

 ::nape::phys::Material Shape_obj::set_material( ::nape::phys::Material material){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_360_set_material)
HXLINE( 361)		{
HXLINE( 362)			this->zpp_inner->immutable_midstep(HX_("Shape::material",a8,cd,a4,b9));
HXLINE( 364)			if (hx::IsNull( material )) {
HXLINE( 364)				HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape material",9d,c0,89,99));
            			}
HXLINE( 366)			this->zpp_inner->setMaterial(material->zpp_inner);
            		}
HXLINE( 368)		return this->zpp_inner->material->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_material,return )

 ::nape::dynamics::InteractionFilter Shape_obj::get_filter(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_378_get_filter)
HXDLIN( 378)		return this->zpp_inner->filter->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_filter,return )

 ::nape::dynamics::InteractionFilter Shape_obj::set_filter( ::nape::dynamics::InteractionFilter filter){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_380_set_filter)
HXLINE( 381)		{
HXLINE( 382)			this->zpp_inner->immutable_midstep(HX_("Shape::filter",79,9e,c6,67));
HXLINE( 384)			if (hx::IsNull( filter )) {
HXLINE( 384)				HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape filter",2e,7a,75,59));
            			}
HXLINE( 386)			this->zpp_inner->setFilter(filter->zpp_inner);
            		}
HXLINE( 388)		return this->zpp_inner->filter->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_filter,return )

 ::nape::phys::FluidProperties Shape_obj::get_fluidProperties(){
            	HX_GC_STACKFRAME(&_hx_pos_89f9be17cd3263cd_400_get_fluidProperties)
HXLINE( 401)		this->zpp_inner->immutable_midstep(HX_("Shape::fluidProperties",bc,2b,f3,66));
HXLINE( 402)		if (hx::IsNull( this->zpp_inner->fluidProperties )) {
HXLINE( 402)			 ::zpp_nape::shape::ZPP_Shape _hx_tmp = this->zpp_inner;
HXDLIN( 402)			_hx_tmp->setFluid( ::nape::phys::FluidProperties_obj::__alloc( HX_CTX ,null(),null())->zpp_inner);
            		}
HXLINE( 403)		return this->zpp_inner->fluidProperties->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_fluidProperties,return )

 ::nape::phys::FluidProperties Shape_obj::set_fluidProperties( ::nape::phys::FluidProperties fluidProperties){
            	HX_GC_STACKFRAME(&_hx_pos_89f9be17cd3263cd_405_set_fluidProperties)
HXLINE( 406)		{
HXLINE( 408)			if (hx::IsNull( fluidProperties )) {
HXLINE( 408)				HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape fluidProperties, disable fluids by setting fluidEnabled to false",b2,c7,28,b5));
            			}
HXLINE( 410)			this->zpp_inner->setFluid(fluidProperties->zpp_inner);
            		}
HXLINE( 412)		this->zpp_inner->immutable_midstep(HX_("Shape::fluidProperties",bc,2b,f3,66));
HXDLIN( 412)		if (hx::IsNull( this->zpp_inner->fluidProperties )) {
HXLINE( 412)			 ::zpp_nape::shape::ZPP_Shape _hx_tmp = this->zpp_inner;
HXDLIN( 412)			_hx_tmp->setFluid( ::nape::phys::FluidProperties_obj::__alloc( HX_CTX ,null(),null())->zpp_inner);
            		}
HXDLIN( 412)		return this->zpp_inner->fluidProperties->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_fluidProperties,return )

bool Shape_obj::get_fluidEnabled(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_429_get_fluidEnabled)
HXDLIN( 429)		return this->zpp_inner->fluidEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_fluidEnabled,return )

bool Shape_obj::set_fluidEnabled(bool fluidEnabled){
            	HX_GC_STACKFRAME(&_hx_pos_89f9be17cd3263cd_431_set_fluidEnabled)
HXLINE( 432)		{
HXLINE( 433)			this->zpp_inner->immutable_midstep(HX_("Shape::fluidEnabled",18,0d,d1,29));
HXLINE( 434)			this->zpp_inner->fluidEnabled = fluidEnabled;
HXLINE( 435)			bool _hx_tmp;
HXDLIN( 435)			if (fluidEnabled) {
HXLINE( 435)				_hx_tmp = hx::IsNull( this->zpp_inner->fluidProperties );
            			}
            			else {
HXLINE( 435)				_hx_tmp = false;
            			}
HXDLIN( 435)			if (_hx_tmp) {
HXLINE( 435)				 ::nape::phys::FluidProperties fluidProperties =  ::nape::phys::FluidProperties_obj::__alloc( HX_CTX ,null(),null());
HXDLIN( 435)				{
HXLINE( 435)					if (hx::IsNull( fluidProperties )) {
HXLINE( 435)						HX_STACK_DO_THROW(HX_("Error: Cannot assign null as Shape fluidProperties, disable fluids by setting fluidEnabled to false",b2,c7,28,b5));
            					}
HXDLIN( 435)					this->zpp_inner->setFluid(fluidProperties->zpp_inner);
            				}
HXDLIN( 435)				{
HXLINE( 435)					this->zpp_inner->immutable_midstep(HX_("Shape::fluidProperties",bc,2b,f3,66));
HXDLIN( 435)					if (hx::IsNull( this->zpp_inner->fluidProperties )) {
HXLINE( 435)						 ::zpp_nape::shape::ZPP_Shape _hx_tmp1 = this->zpp_inner;
HXDLIN( 435)						_hx_tmp1->setFluid( ::nape::phys::FluidProperties_obj::__alloc( HX_CTX ,null(),null())->zpp_inner);
            					}
HXDLIN( 435)					this->zpp_inner->fluidProperties->wrapper();
            				}
            			}
HXLINE( 436)			this->zpp_inner->wake();
            		}
HXLINE( 438)		return this->zpp_inner->fluidEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_fluidEnabled,return )

bool Shape_obj::get_sensorEnabled(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_454_get_sensorEnabled)
HXDLIN( 454)		return this->zpp_inner->sensorEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_sensorEnabled,return )

bool Shape_obj::set_sensorEnabled(bool sensorEnabled){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_456_set_sensorEnabled)
HXLINE( 457)		{
HXLINE( 458)			this->zpp_inner->immutable_midstep(HX_("Shape::sensorEnabled",c6,60,6c,36));
HXLINE( 459)			this->zpp_inner->sensorEnabled = sensorEnabled;
HXLINE( 460)			this->zpp_inner->wake();
            		}
HXLINE( 462)		return this->zpp_inner->sensorEnabled;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,set_sensorEnabled,return )

 ::nape::geom::AABB Shape_obj::get_bounds(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_476_get_bounds)
HXDLIN( 476)		return this->zpp_inner->aabb->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,get_bounds,return )

 ::nape::shape::Shape Shape_obj::translate( ::nape::geom::Vec2 translation){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_489_translate)
HXLINE( 490)		this->zpp_inner->immutable_midstep(HX_("Shape::translate()",6e,4f,c5,dc));
HXLINE( 493)		bool _hx_tmp;
HXDLIN( 493)		if (hx::IsNotNull( translation )) {
HXLINE( 493)			_hx_tmp = translation->zpp_disp;
            		}
            		else {
HXLINE( 493)			_hx_tmp = false;
            		}
HXDLIN( 493)		if (_hx_tmp) {
HXLINE( 493)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 497)		bool _hx_tmp1;
HXDLIN( 497)		bool _hx_tmp2;
HXDLIN( 497)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 497)			_hx_tmp2 = hx::IsNotNull( this->zpp_inner->body->space );
            		}
            		else {
HXLINE( 497)			_hx_tmp2 = false;
            		}
HXDLIN( 497)		if (_hx_tmp2) {
HXLINE( 497)			_hx_tmp1 = (this->zpp_inner->body->type == 1);
            		}
            		else {
HXLINE( 497)			_hx_tmp1 = false;
            		}
HXDLIN( 497)		if (_hx_tmp1) {
HXLINE( 497)			HX_STACK_DO_THROW(HX_("Error: Cannot modify Shape belonging to a static Object once inside a Space",82,96,75,9f));
            		}
HXLINE( 498)		if (hx::IsNull( translation )) {
HXLINE( 498)			HX_STACK_DO_THROW(HX_("Error: Cannot displace Shape by null Vec2",05,59,ba,78));
            		}
HXLINE( 500)		if ((translation->lsq() > 0)) {
HXLINE( 501)			if ((this->zpp_inner->type == 0)) {
HXLINE( 501)				 ::zpp_nape::shape::ZPP_Circle _hx_tmp3 = this->zpp_inner->circle;
HXDLIN( 501)				bool _hx_tmp4;
HXDLIN( 501)				if (hx::IsNotNull( translation )) {
HXLINE( 501)					_hx_tmp4 = translation->zpp_disp;
            				}
            				else {
HXLINE( 501)					_hx_tmp4 = false;
            				}
HXDLIN( 501)				if (_hx_tmp4) {
HXLINE( 501)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 501)				{
HXLINE( 501)					 ::zpp_nape::geom::ZPP_Vec2 _this = translation->zpp_inner;
HXDLIN( 501)					if (hx::IsNotNull( _this->_validate )) {
HXLINE( 501)						_this->_validate();
            					}
            				}
HXDLIN( 501)				Float _hx_tmp5 = translation->zpp_inner->x;
HXDLIN( 501)				bool _hx_tmp6;
HXDLIN( 501)				if (hx::IsNotNull( translation )) {
HXLINE( 501)					_hx_tmp6 = translation->zpp_disp;
            				}
            				else {
HXLINE( 501)					_hx_tmp6 = false;
            				}
HXDLIN( 501)				if (_hx_tmp6) {
HXLINE( 501)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 501)				{
HXLINE( 501)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = translation->zpp_inner;
HXDLIN( 501)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 501)						_this1->_validate();
            					}
            				}
HXDLIN( 501)				_hx_tmp3->_hx___translate(_hx_tmp5,translation->zpp_inner->y);
            			}
            			else {
HXLINE( 502)				 ::zpp_nape::shape::ZPP_Polygon _hx_tmp7 = this->zpp_inner->polygon;
HXDLIN( 502)				bool _hx_tmp8;
HXDLIN( 502)				if (hx::IsNotNull( translation )) {
HXLINE( 502)					_hx_tmp8 = translation->zpp_disp;
            				}
            				else {
HXLINE( 502)					_hx_tmp8 = false;
            				}
HXDLIN( 502)				if (_hx_tmp8) {
HXLINE( 502)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 502)				{
HXLINE( 502)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = translation->zpp_inner;
HXDLIN( 502)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 502)						_this2->_validate();
            					}
            				}
HXDLIN( 502)				Float _hx_tmp9 = translation->zpp_inner->x;
HXDLIN( 502)				bool _hx_tmp10;
HXDLIN( 502)				if (hx::IsNotNull( translation )) {
HXLINE( 502)					_hx_tmp10 = translation->zpp_disp;
            				}
            				else {
HXLINE( 502)					_hx_tmp10 = false;
            				}
HXDLIN( 502)				if (_hx_tmp10) {
HXLINE( 502)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 502)				{
HXLINE( 502)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = translation->zpp_inner;
HXDLIN( 502)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 502)						_this3->_validate();
            					}
            				}
HXDLIN( 502)				_hx_tmp7->_hx___translate(_hx_tmp9,translation->zpp_inner->y);
            			}
            		}
HXLINE( 504)		if (translation->zpp_inner->weak) {
HXLINE( 508)			bool _hx_tmp11;
HXDLIN( 508)			if (hx::IsNotNull( translation )) {
HXLINE( 508)				_hx_tmp11 = translation->zpp_disp;
            			}
            			else {
HXLINE( 508)				_hx_tmp11 = false;
            			}
HXDLIN( 508)			if (_hx_tmp11) {
HXLINE( 508)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 508)			{
HXLINE( 508)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = translation->zpp_inner;
HXDLIN( 508)				if (_this4->_immutable) {
HXLINE( 508)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 508)				if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 508)					_this4->_isimmutable();
            				}
            			}
HXDLIN( 508)			if (translation->zpp_inner->_inuse) {
HXLINE( 508)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 508)			 ::zpp_nape::geom::ZPP_Vec2 inner = translation->zpp_inner;
HXDLIN( 508)			translation->zpp_inner->outer = null();
HXDLIN( 508)			translation->zpp_inner = null();
HXDLIN( 508)			{
HXLINE( 508)				 ::nape::geom::Vec2 o = translation;
HXDLIN( 508)				o->zpp_pool = null();
HXDLIN( 508)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 508)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE( 508)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN( 508)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 508)				o->zpp_disp = true;
            			}
HXDLIN( 508)			{
HXLINE( 508)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 508)				{
HXLINE( 508)					if (hx::IsNotNull( o1->outer )) {
HXLINE( 508)						o1->outer->zpp_inner = null();
HXDLIN( 508)						o1->outer = null();
            					}
HXDLIN( 508)					o1->_isimmutable = null();
HXDLIN( 508)					o1->_validate = null();
HXDLIN( 508)					o1->_invalidate = null();
            				}
HXDLIN( 508)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 508)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE( 515)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,translate,return )

 ::nape::shape::Shape Shape_obj::scale(Float scalex,Float scaley){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_529_scale)
HXLINE( 530)		this->zpp_inner->immutable_midstep(HX_("Shape::scale()",2a,92,c4,c1));
HXLINE( 532)		bool _hx_tmp;
HXDLIN( 532)		bool _hx_tmp1;
HXDLIN( 532)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 532)			_hx_tmp1 = hx::IsNotNull( this->zpp_inner->body->space );
            		}
            		else {
HXLINE( 532)			_hx_tmp1 = false;
            		}
HXDLIN( 532)		if (_hx_tmp1) {
HXLINE( 532)			_hx_tmp = (this->zpp_inner->body->type == 1);
            		}
            		else {
HXLINE( 532)			_hx_tmp = false;
            		}
HXDLIN( 532)		if (_hx_tmp) {
HXLINE( 532)			HX_STACK_DO_THROW(HX_("Error: Cannot modify Shape belonging to a static Object once inside a Space",82,96,75,9f));
            		}
HXLINE( 533)		bool _hx_tmp2;
HXDLIN( 533)		if ((scalex == scalex)) {
HXLINE( 533)			_hx_tmp2 = (scaley != scaley);
            		}
            		else {
HXLINE( 533)			_hx_tmp2 = true;
            		}
HXDLIN( 533)		if (_hx_tmp2) {
HXLINE( 533)			HX_STACK_DO_THROW(HX_("Error: Cannot scale Shape by NaN",36,d9,16,15));
            		}
HXLINE( 534)		bool _hx_tmp3;
HXDLIN( 534)		if ((scalex != 0)) {
HXLINE( 534)			_hx_tmp3 = (scaley == 0);
            		}
            		else {
HXLINE( 534)			_hx_tmp3 = true;
            		}
HXDLIN( 534)		if (_hx_tmp3) {
HXLINE( 534)			HX_STACK_DO_THROW(HX_("Error: Cannot Scale shape by a factor of 0",f4,37,0c,59));
            		}
HXLINE( 536)		if ((this->zpp_inner->type == 0)) {
HXLINE( 537)			Float d = ((scalex * scalex) - (scaley * scaley));
HXLINE( 538)			if (((d * d) < (::nape::Config_obj::epsilon * ::nape::Config_obj::epsilon))) {
HXLINE( 539)				this->zpp_inner->circle->_hx___scale(scalex,scaley);
            			}
            			else {
HXLINE( 543)				HX_STACK_DO_THROW(HX_("Error: Cannot perform a non equal scaling on a Circle",eb,c7,92,4e));
            			}
            		}
            		else {
HXLINE( 547)			this->zpp_inner->polygon->_hx___scale(scalex,scaley);
            		}
HXLINE( 548)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Shape_obj,scale,return )

 ::nape::shape::Shape Shape_obj::rotate(Float angle){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_559_rotate)
HXLINE( 560)		this->zpp_inner->immutable_midstep(HX_("Shape::rotate()",1d,67,82,d1));
HXLINE( 562)		bool _hx_tmp;
HXDLIN( 562)		bool _hx_tmp1;
HXDLIN( 562)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 562)			_hx_tmp1 = hx::IsNotNull( this->zpp_inner->body->space );
            		}
            		else {
HXLINE( 562)			_hx_tmp1 = false;
            		}
HXDLIN( 562)		if (_hx_tmp1) {
HXLINE( 562)			_hx_tmp = (this->zpp_inner->body->type == 1);
            		}
            		else {
HXLINE( 562)			_hx_tmp = false;
            		}
HXDLIN( 562)		if (_hx_tmp) {
HXLINE( 562)			HX_STACK_DO_THROW(HX_("Error: Cannot modify Shape belonging to a static Object once inside a Space",82,96,75,9f));
            		}
HXLINE( 563)		if ((angle != angle)) {
HXLINE( 563)			HX_STACK_DO_THROW(HX_("Error: Cannot rotate Shape by NaN",47,b6,1e,3b));
            		}
HXLINE( 565)		Float dr = hx::Mod(angle,(( (Float)(2) ) * ::Math_obj::PI));
HXLINE( 566)		if ((dr != ((Float)0.0))) {
HXLINE( 567)			Float cos = ::Math_obj::cos(angle);
HXLINE( 568)			Float sin = ::Math_obj::sin(angle);
HXLINE( 569)			if ((this->zpp_inner->type == 0)) {
HXLINE( 569)				this->zpp_inner->circle->_hx___rotate(sin,cos);
            			}
            			else {
HXLINE( 570)				this->zpp_inner->polygon->_hx___rotate(sin,cos);
            			}
            		}
HXLINE( 572)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,rotate,return )

 ::nape::shape::Shape Shape_obj::transform( ::nape::geom::Mat23 matrix){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_586_transform)
HXLINE( 587)		this->zpp_inner->immutable_midstep(HX_("Shape::transform()",0c,e9,f0,84));
HXLINE( 589)		bool _hx_tmp;
HXDLIN( 589)		bool _hx_tmp1;
HXDLIN( 589)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 589)			_hx_tmp1 = hx::IsNotNull( this->zpp_inner->body->space );
            		}
            		else {
HXLINE( 589)			_hx_tmp1 = false;
            		}
HXDLIN( 589)		if (_hx_tmp1) {
HXLINE( 589)			_hx_tmp = (this->zpp_inner->body->type == 1);
            		}
            		else {
HXLINE( 589)			_hx_tmp = false;
            		}
HXDLIN( 589)		if (_hx_tmp) {
HXLINE( 589)			HX_STACK_DO_THROW(HX_("Error: Cannot modify Shape belonging to a static Object once inside a Space",82,96,75,9f));
            		}
HXLINE( 590)		if (hx::IsNull( matrix )) {
HXLINE( 590)			HX_STACK_DO_THROW(HX_("Error: Cannot transform Shape by null matrix",b3,63,2a,df));
            		}
HXLINE( 591)		if (matrix->singular()) {
HXLINE( 591)			HX_STACK_DO_THROW(HX_("Error: Cannot transform Shape by a singular matrix",64,7a,ee,b2));
            		}
HXLINE( 593)		if ((this->zpp_inner->type == 0)) {
HXLINE( 594)			if (matrix->equiorthogonal()) {
HXLINE( 595)				this->zpp_inner->circle->_hx___transform(matrix);
            			}
            			else {
HXLINE( 599)				HX_STACK_DO_THROW(HX_("Error: Cannot transform Circle by a non equiorthogonal matrix",ba,10,db,af));
            			}
            		}
            		else {
HXLINE( 603)			this->zpp_inner->polygon->_hx___transform(matrix);
            		}
HXLINE( 604)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,transform,return )

bool Shape_obj::contains( ::nape::geom::Vec2 point){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_618_contains)
HXLINE( 621)		bool _hx_tmp;
HXDLIN( 621)		if (hx::IsNotNull( point )) {
HXLINE( 621)			_hx_tmp = point->zpp_disp;
            		}
            		else {
HXLINE( 621)			_hx_tmp = false;
            		}
HXDLIN( 621)		if (_hx_tmp) {
HXLINE( 621)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 625)		if (hx::IsNull( point )) {
HXLINE( 625)			HX_STACK_DO_THROW(HX_("Cannot check null point for containment",a7,97,cc,2d));
            		}
HXLINE( 628)		 ::nape::phys::Body _hx_tmp1;
HXDLIN( 628)		if (hx::IsNotNull( this->zpp_inner->body )) {
HXLINE( 628)			_hx_tmp1 = this->zpp_inner->body->outer;
            		}
            		else {
HXLINE( 628)			_hx_tmp1 = null();
            		}
HXDLIN( 628)		if (hx::IsNull( _hx_tmp1 )) {
HXLINE( 628)			HX_STACK_DO_THROW(HX_("Error: Shape is not well defined without a Body",4c,b5,e2,9d));
            		}
HXLINE( 630)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(this->zpp_inner);
HXLINE( 631)		{
HXLINE( 631)			 ::zpp_nape::geom::ZPP_Vec2 _this = point->zpp_inner;
HXDLIN( 631)			if (hx::IsNotNull( _this->_validate )) {
HXLINE( 631)				_this->_validate();
            			}
            		}
HXLINE( 632)		bool ret = ::zpp_nape::geom::ZPP_Collide_obj::shapeContains(this->zpp_inner,point->zpp_inner);
HXLINE( 633)		if (point->zpp_inner->weak) {
HXLINE( 637)			bool _hx_tmp2;
HXDLIN( 637)			if (hx::IsNotNull( point )) {
HXLINE( 637)				_hx_tmp2 = point->zpp_disp;
            			}
            			else {
HXLINE( 637)				_hx_tmp2 = false;
            			}
HXDLIN( 637)			if (_hx_tmp2) {
HXLINE( 637)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 637)			{
HXLINE( 637)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = point->zpp_inner;
HXDLIN( 637)				if (_this1->_immutable) {
HXLINE( 637)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 637)				if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 637)					_this1->_isimmutable();
            				}
            			}
HXDLIN( 637)			if (point->zpp_inner->_inuse) {
HXLINE( 637)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 637)			 ::zpp_nape::geom::ZPP_Vec2 inner = point->zpp_inner;
HXDLIN( 637)			point->zpp_inner->outer = null();
HXDLIN( 637)			point->zpp_inner = null();
HXDLIN( 637)			{
HXLINE( 637)				 ::nape::geom::Vec2 o = point;
HXDLIN( 637)				o->zpp_pool = null();
HXDLIN( 637)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 637)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE( 637)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN( 637)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 637)				o->zpp_disp = true;
            			}
HXDLIN( 637)			{
HXLINE( 637)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 637)				{
HXLINE( 637)					if (hx::IsNotNull( o1->outer )) {
HXLINE( 637)						o1->outer->zpp_inner = null();
HXDLIN( 637)						o1->outer = null();
            					}
HXDLIN( 637)					o1->_isimmutable = null();
HXDLIN( 637)					o1->_validate = null();
HXDLIN( 637)					o1->_invalidate = null();
            				}
HXDLIN( 637)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 637)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE( 644)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Shape_obj,contains,return )

 ::nape::shape::Shape Shape_obj::copy(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_657_copy)
HXDLIN( 657)		return this->zpp_inner->copy();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Shape_obj,copy,return )

::String Shape_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_662_toString)
HXLINE( 663)		::String ret;
HXDLIN( 663)		if ((this->zpp_inner->type == 0)) {
HXLINE( 663)			ret = HX_("Circle",30,e6,a1,8a);
            		}
            		else {
HXLINE( 663)			ret = HX_("Polygon",5a,2a,e2,df);
            		}
HXLINE( 664)		return ((ret + HX_("#",23,00,00,00)) + this->zpp_inner_i->id);
            	}


bool Shape_obj::zpp_internalAlloc;


hx::ObjectPtr< Shape_obj > Shape_obj::__new() {
	hx::ObjectPtr< Shape_obj > __this = new Shape_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Shape_obj > Shape_obj::__alloc(hx::Ctx *_hx_ctx) {
	Shape_obj *__this = (Shape_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Shape_obj), true, "nape.shape.Shape"));
	*(void **)__this = Shape_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Shape_obj::Shape_obj()
{
}

void Shape_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Shape);
	HX_MARK_MEMBER_NAME(zpp_inner,"zpp_inner");
	 ::nape::phys::Interactor_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Shape_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(zpp_inner,"zpp_inner");
	 ::nape::phys::Interactor_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Shape_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_type() ); }
		if (HX_FIELD_EQ(inName,"body") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_body() ); }
		if (HX_FIELD_EQ(inName,"area") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_area() ); }
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { return hx::Val( scale_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"filter") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_filter() ); }
		if (HX_FIELD_EQ(inName,"bounds") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_bounds() ); }
		if (HX_FIELD_EQ(inName,"rotate") ) { return hx::Val( rotate_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"inertia") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_inertia() ); }
		if (HX_FIELD_EQ(inName,"angDrag") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_angDrag() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"get_type") ) { return hx::Val( get_type_dyn() ); }
		if (HX_FIELD_EQ(inName,"isCircle") ) { return hx::Val( isCircle_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_body") ) { return hx::Val( get_body_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_body") ) { return hx::Val( set_body_dyn() ); }
		if (HX_FIELD_EQ(inName,"worldCOM") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_worldCOM() ); }
		if (HX_FIELD_EQ(inName,"localCOM") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_localCOM() ); }
		if (HX_FIELD_EQ(inName,"get_area") ) { return hx::Val( get_area_dyn() ); }
		if (HX_FIELD_EQ(inName,"material") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_material() ); }
		if (HX_FIELD_EQ(inName,"contains") ) { return hx::Val( contains_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { return hx::Val( zpp_inner ); }
		if (HX_FIELD_EQ(inName,"isPolygon") ) { return hx::Val( isPolygon_dyn() ); }
		if (HX_FIELD_EQ(inName,"translate") ) { return hx::Val( translate_dyn() ); }
		if (HX_FIELD_EQ(inName,"transform") ) { return hx::Val( transform_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"castCircle") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_castCircle() ); }
		if (HX_FIELD_EQ(inName,"get_filter") ) { return hx::Val( get_filter_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_filter") ) { return hx::Val( set_filter_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_bounds") ) { return hx::Val( get_bounds_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"castPolygon") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_castPolygon() ); }
		if (HX_FIELD_EQ(inName,"get_inertia") ) { return hx::Val( get_inertia_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_angDrag") ) { return hx::Val( get_angDrag_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_worldCOM") ) { return hx::Val( get_worldCOM_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_localCOM") ) { return hx::Val( get_localCOM_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_localCOM") ) { return hx::Val( set_localCOM_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_material") ) { return hx::Val( get_material_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_material") ) { return hx::Val( set_material_dyn() ); }
		if (HX_FIELD_EQ(inName,"fluidEnabled") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_fluidEnabled() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"sensorEnabled") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_sensorEnabled() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"get_castCircle") ) { return hx::Val( get_castCircle_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_castPolygon") ) { return hx::Val( get_castPolygon_dyn() ); }
		if (HX_FIELD_EQ(inName,"fluidProperties") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_fluidProperties() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"get_fluidEnabled") ) { return hx::Val( get_fluidEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_fluidEnabled") ) { return hx::Val( set_fluidEnabled_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_sensorEnabled") ) { return hx::Val( get_sensorEnabled_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_sensorEnabled") ) { return hx::Val( set_sensorEnabled_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"get_fluidProperties") ) { return hx::Val( get_fluidProperties_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_fluidProperties") ) { return hx::Val( set_fluidProperties_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Shape_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"zpp_internalAlloc") ) { outValue = ( zpp_internalAlloc ); return true; }
	}
	return false;
}

hx::Val Shape_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"body") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_body(inValue.Cast<  ::nape::phys::Body >()) ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"filter") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_filter(inValue.Cast<  ::nape::dynamics::InteractionFilter >()) ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"localCOM") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_localCOM(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		if (HX_FIELD_EQ(inName,"material") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_material(inValue.Cast<  ::nape::phys::Material >()) ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { zpp_inner=inValue.Cast<  ::zpp_nape::shape::ZPP_Shape >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"fluidEnabled") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_fluidEnabled(inValue.Cast< bool >()) ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"sensorEnabled") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_sensorEnabled(inValue.Cast< bool >()) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fluidProperties") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_fluidProperties(inValue.Cast<  ::nape::phys::FluidProperties >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Shape_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 17:
		if (HX_FIELD_EQ(inName,"zpp_internalAlloc") ) { zpp_internalAlloc=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

void Shape_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("zpp_inner",51,65,85,78));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("body",a2,7a,1b,41));
	outFields->push(HX_("castCircle",2f,1e,4a,5e));
	outFields->push(HX_("castPolygon",7b,f1,6a,3f));
	outFields->push(HX_("worldCOM",0f,c5,83,a4));
	outFields->push(HX_("localCOM",96,c7,df,df));
	outFields->push(HX_("area",8d,8b,74,40));
	outFields->push(HX_("inertia",fa,b0,ba,7c));
	outFields->push(HX_("angDrag",ee,c7,72,38));
	outFields->push(HX_("material",a7,5c,a5,f0));
	outFields->push(HX_("filter",b8,1f,35,85));
	outFields->push(HX_("fluidProperties",9d,0a,80,04));
	outFields->push(HX_("fluidEnabled",97,87,5e,9a));
	outFields->push(HX_("sensorEnabled",67,15,aa,41));
	outFields->push(HX_("bounds",75,86,1d,66));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Shape_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::zpp_nape::shape::ZPP_Shape */ ,(int)offsetof(Shape_obj,zpp_inner),HX_("zpp_inner",51,65,85,78)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Shape_obj_sStaticStorageInfo[] = {
	{hx::fsBool,(void *) &Shape_obj::zpp_internalAlloc,HX_("zpp_internalAlloc",b3,36,26,40)},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Shape_obj_sMemberFields[] = {
	HX_("zpp_inner",51,65,85,78),
	HX_("get_type",43,ae,c3,cc),
	HX_("isCircle",9a,0d,77,ae),
	HX_("isPolygon",b0,7f,8f,16),
	HX_("get_body",2b,36,d6,c0),
	HX_("set_body",9f,8f,33,6f),
	HX_("get_castCircle",78,a6,3f,d4),
	HX_("get_castPolygon",12,a9,4c,00),
	HX_("get_worldCOM",18,79,9d,59),
	HX_("get_localCOM",9f,7b,f9,94),
	HX_("set_localCOM",13,9f,f2,a9),
	HX_("get_area",16,47,2f,c0),
	HX_("get_inertia",11,11,b5,02),
	HX_("get_angDrag",05,28,6d,be),
	HX_("get_material",b0,10,bf,a5),
	HX_("set_material",24,34,b8,ba),
	HX_("get_filter",81,8f,bc,75),
	HX_("set_filter",f5,2d,3a,79),
	HX_("get_fluidProperties",b4,d9,8a,8f),
	HX_("set_fluidProperties",c0,cc,27,cc),
	HX_("get_fluidEnabled",20,74,fd,9e),
	HX_("set_fluidEnabled",94,61,3f,f5),
	HX_("get_sensorEnabled",be,20,1a,48),
	HX_("set_sensorEnabled",ca,f8,87,6b),
	HX_("get_bounds",3e,f6,a4,56),
	HX_("translate",4e,d7,7f,49),
	HX_("scale",8a,ce,ce,78),
	HX_("rotate",5b,46,20,cb),
	HX_("transform",6c,2d,93,45),
	HX_("contains",1f,5a,7b,2c),
	HX_("copy",b5,bb,c4,41),
	HX_("toString",ac,d0,6e,38),
	::String(null()) };

static void Shape_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Shape_obj::zpp_internalAlloc,"zpp_internalAlloc");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Shape_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Shape_obj::zpp_internalAlloc,"zpp_internalAlloc");
};

#endif

hx::Class Shape_obj::__mClass;

static ::String Shape_obj_sStaticFields[] = {
	HX_("zpp_internalAlloc",b3,36,26,40),
	::String(null())
};

void Shape_obj::__register()
{
	Shape_obj _hx_dummy;
	Shape_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.shape.Shape",6e,41,97,5c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Shape_obj::__GetStatic;
	__mClass->mSetStaticField = &Shape_obj::__SetStatic;
	__mClass->mMarkFunc = Shape_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Shape_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Shape_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Shape_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Shape_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Shape_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Shape_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Shape_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_89f9be17cd3263cd_214_boot)
HXDLIN( 214)		zpp_internalAlloc = false;
            	}
}

} // end namespace nape
} // end namespace shape
