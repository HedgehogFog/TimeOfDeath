// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_nape_Config
#include <hxinc/nape/Config.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1cc65b763db1b828_9_new,"nape.Config","new",0xbc5e2e9a,"nape.Config.new","nape/Config.hx",9,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_15_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",15,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_27_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",27,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_40_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",40,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_53_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",53,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_62_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",62,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_69_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",69,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_77_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",77,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_88_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",88,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_104_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",104,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_121_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",121,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_136_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",136,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_145_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",145,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_157_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",157,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_174_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",174,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_188_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",188,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_200_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",200,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_210_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",210,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_222_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",222,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_234_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",234,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_244_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",244,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_258_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",258,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_269_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",269,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_279_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",279,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_289_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",289,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_299_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",299,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_309_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",309,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_319_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",319,0x5f8e99f5)
HX_LOCAL_STACK_FRAME(_hx_pos_1cc65b763db1b828_332_boot,"nape.Config","boot",0x0e2398b8,"nape.Config.boot","nape/Config.hx",332,0x5f8e99f5)
namespace nape{

void Config_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_9_new)
            	}

Dynamic Config_obj::__CreateEmpty() { return new Config_obj; }

void *Config_obj::_hx_vtable = 0;

Dynamic Config_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Config_obj > _hx_result = new Config_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Config_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x0b3d30ee;
}

Float Config_obj::epsilon;

Float Config_obj::fluidAngularDragFriction;

Float Config_obj::fluidAngularDrag;

Float Config_obj::fluidVacuumDrag;

Float Config_obj::fluidLinearDrag;

Float Config_obj::collisionSlop;

Float Config_obj::collisionSlopCCD;

Float Config_obj::distanceThresholdCCD;

Float Config_obj::staticCCDLinearThreshold;

Float Config_obj::staticCCDAngularThreshold;

Float Config_obj::bulletCCDLinearThreshold;

Float Config_obj::bulletCCDAngularThreshold;

Float Config_obj::dynamicSweepLinearThreshold;

Float Config_obj::dynamicSweepAngularThreshold;

Float Config_obj::angularCCDSlipScale;

int Config_obj::arbiterExpirationDelay;

Float Config_obj::staticFrictionThreshold;

Float Config_obj::elasticThreshold;

int Config_obj::sleepDelay;

Float Config_obj::linearSleepThreshold;

Float Config_obj::angularSleepThreshold;

Float Config_obj::contactBiasCoef;

Float Config_obj::contactStaticBiasCoef;

Float Config_obj::contactContinuousBiasCoef;

Float Config_obj::contactContinuousStaticBiasCoef;

Float Config_obj::constraintLinearSlop;

Float Config_obj::constraintAngularSlop;

Float Config_obj::illConditionedThreshold;


Config_obj::Config_obj()
{
}

bool Config_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"epsilon") ) { outValue = ( epsilon ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sleepDelay") ) { outValue = ( sleepDelay ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"collisionSlop") ) { outValue = ( collisionSlop ); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fluidVacuumDrag") ) { outValue = ( fluidVacuumDrag ); return true; }
		if (HX_FIELD_EQ(inName,"fluidLinearDrag") ) { outValue = ( fluidLinearDrag ); return true; }
		if (HX_FIELD_EQ(inName,"contactBiasCoef") ) { outValue = ( contactBiasCoef ); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fluidAngularDrag") ) { outValue = ( fluidAngularDrag ); return true; }
		if (HX_FIELD_EQ(inName,"collisionSlopCCD") ) { outValue = ( collisionSlopCCD ); return true; }
		if (HX_FIELD_EQ(inName,"elasticThreshold") ) { outValue = ( elasticThreshold ); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"angularCCDSlipScale") ) { outValue = ( angularCCDSlipScale ); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"distanceThresholdCCD") ) { outValue = ( distanceThresholdCCD ); return true; }
		if (HX_FIELD_EQ(inName,"linearSleepThreshold") ) { outValue = ( linearSleepThreshold ); return true; }
		if (HX_FIELD_EQ(inName,"constraintLinearSlop") ) { outValue = ( constraintLinearSlop ); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"angularSleepThreshold") ) { outValue = ( angularSleepThreshold ); return true; }
		if (HX_FIELD_EQ(inName,"contactStaticBiasCoef") ) { outValue = ( contactStaticBiasCoef ); return true; }
		if (HX_FIELD_EQ(inName,"constraintAngularSlop") ) { outValue = ( constraintAngularSlop ); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"arbiterExpirationDelay") ) { outValue = ( arbiterExpirationDelay ); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"staticFrictionThreshold") ) { outValue = ( staticFrictionThreshold ); return true; }
		if (HX_FIELD_EQ(inName,"illConditionedThreshold") ) { outValue = ( illConditionedThreshold ); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"fluidAngularDragFriction") ) { outValue = ( fluidAngularDragFriction ); return true; }
		if (HX_FIELD_EQ(inName,"staticCCDLinearThreshold") ) { outValue = ( staticCCDLinearThreshold ); return true; }
		if (HX_FIELD_EQ(inName,"bulletCCDLinearThreshold") ) { outValue = ( bulletCCDLinearThreshold ); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"staticCCDAngularThreshold") ) { outValue = ( staticCCDAngularThreshold ); return true; }
		if (HX_FIELD_EQ(inName,"bulletCCDAngularThreshold") ) { outValue = ( bulletCCDAngularThreshold ); return true; }
		if (HX_FIELD_EQ(inName,"contactContinuousBiasCoef") ) { outValue = ( contactContinuousBiasCoef ); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"dynamicSweepLinearThreshold") ) { outValue = ( dynamicSweepLinearThreshold ); return true; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"dynamicSweepAngularThreshold") ) { outValue = ( dynamicSweepAngularThreshold ); return true; }
		break;
	case 31:
		if (HX_FIELD_EQ(inName,"contactContinuousStaticBiasCoef") ) { outValue = ( contactContinuousStaticBiasCoef ); return true; }
	}
	return false;
}

bool Config_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"epsilon") ) { epsilon=ioValue.Cast< Float >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"sleepDelay") ) { sleepDelay=ioValue.Cast< int >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"collisionSlop") ) { collisionSlop=ioValue.Cast< Float >(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fluidVacuumDrag") ) { fluidVacuumDrag=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"fluidLinearDrag") ) { fluidLinearDrag=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"contactBiasCoef") ) { contactBiasCoef=ioValue.Cast< Float >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"fluidAngularDrag") ) { fluidAngularDrag=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"collisionSlopCCD") ) { collisionSlopCCD=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"elasticThreshold") ) { elasticThreshold=ioValue.Cast< Float >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"angularCCDSlipScale") ) { angularCCDSlipScale=ioValue.Cast< Float >(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"distanceThresholdCCD") ) { distanceThresholdCCD=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"linearSleepThreshold") ) { linearSleepThreshold=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"constraintLinearSlop") ) { constraintLinearSlop=ioValue.Cast< Float >(); return true; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"angularSleepThreshold") ) { angularSleepThreshold=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"contactStaticBiasCoef") ) { contactStaticBiasCoef=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"constraintAngularSlop") ) { constraintAngularSlop=ioValue.Cast< Float >(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"arbiterExpirationDelay") ) { arbiterExpirationDelay=ioValue.Cast< int >(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"staticFrictionThreshold") ) { staticFrictionThreshold=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"illConditionedThreshold") ) { illConditionedThreshold=ioValue.Cast< Float >(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"fluidAngularDragFriction") ) { fluidAngularDragFriction=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"staticCCDLinearThreshold") ) { staticCCDLinearThreshold=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"bulletCCDLinearThreshold") ) { bulletCCDLinearThreshold=ioValue.Cast< Float >(); return true; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"staticCCDAngularThreshold") ) { staticCCDAngularThreshold=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"bulletCCDAngularThreshold") ) { bulletCCDAngularThreshold=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"contactContinuousBiasCoef") ) { contactContinuousBiasCoef=ioValue.Cast< Float >(); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"dynamicSweepLinearThreshold") ) { dynamicSweepLinearThreshold=ioValue.Cast< Float >(); return true; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"dynamicSweepAngularThreshold") ) { dynamicSweepAngularThreshold=ioValue.Cast< Float >(); return true; }
		break;
	case 31:
		if (HX_FIELD_EQ(inName,"contactContinuousStaticBiasCoef") ) { contactContinuousStaticBiasCoef=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *Config_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Config_obj_sStaticStorageInfo[] = {
	{hx::fsFloat,(void *) &Config_obj::epsilon,HX_("epsilon",6a,b5,be,ac)},
	{hx::fsFloat,(void *) &Config_obj::fluidAngularDragFriction,HX_("fluidAngularDragFriction",26,07,b7,e8)},
	{hx::fsFloat,(void *) &Config_obj::fluidAngularDrag,HX_("fluidAngularDrag",0c,e6,94,fb)},
	{hx::fsFloat,(void *) &Config_obj::fluidVacuumDrag,HX_("fluidVacuumDrag",73,4b,c6,0a)},
	{hx::fsFloat,(void *) &Config_obj::fluidLinearDrag,HX_("fluidLinearDrag",23,0f,1a,dd)},
	{hx::fsFloat,(void *) &Config_obj::collisionSlop,HX_("collisionSlop",8c,d3,8b,2c)},
	{hx::fsFloat,(void *) &Config_obj::collisionSlopCCD,HX_("collisionSlopCCD",98,fd,16,d1)},
	{hx::fsFloat,(void *) &Config_obj::distanceThresholdCCD,HX_("distanceThresholdCCD",ae,05,89,27)},
	{hx::fsFloat,(void *) &Config_obj::staticCCDLinearThreshold,HX_("staticCCDLinearThreshold",f0,7b,b6,14)},
	{hx::fsFloat,(void *) &Config_obj::staticCCDAngularThreshold,HX_("staticCCDAngularThreshold",3f,06,d5,58)},
	{hx::fsFloat,(void *) &Config_obj::bulletCCDLinearThreshold,HX_("bulletCCDLinearThreshold",84,26,2c,43)},
	{hx::fsFloat,(void *) &Config_obj::bulletCCDAngularThreshold,HX_("bulletCCDAngularThreshold",2b,9d,54,d1)},
	{hx::fsFloat,(void *) &Config_obj::dynamicSweepLinearThreshold,HX_("dynamicSweepLinearThreshold",99,4d,9b,9c)},
	{hx::fsFloat,(void *) &Config_obj::dynamicSweepAngularThreshold,HX_("dynamicSweepAngularThreshold",76,a8,27,b9)},
	{hx::fsFloat,(void *) &Config_obj::angularCCDSlipScale,HX_("angularCCDSlipScale",48,a1,74,a2)},
	{hx::fsInt,(void *) &Config_obj::arbiterExpirationDelay,HX_("arbiterExpirationDelay",eb,97,56,94)},
	{hx::fsFloat,(void *) &Config_obj::staticFrictionThreshold,HX_("staticFrictionThreshold",c3,fa,d5,c0)},
	{hx::fsFloat,(void *) &Config_obj::elasticThreshold,HX_("elasticThreshold",16,3f,87,62)},
	{hx::fsInt,(void *) &Config_obj::sleepDelay,HX_("sleepDelay",ec,b6,77,8a)},
	{hx::fsFloat,(void *) &Config_obj::linearSleepThreshold,HX_("linearSleepThreshold",59,98,fa,f1)},
	{hx::fsFloat,(void *) &Config_obj::angularSleepThreshold,HX_("angularSleepThreshold",16,d6,01,9c)},
	{hx::fsFloat,(void *) &Config_obj::contactBiasCoef,HX_("contactBiasCoef",e6,cf,ff,89)},
	{hx::fsFloat,(void *) &Config_obj::contactStaticBiasCoef,HX_("contactStaticBiasCoef",b4,56,1c,b7)},
	{hx::fsFloat,(void *) &Config_obj::contactContinuousBiasCoef,HX_("contactContinuousBiasCoef",15,a8,b2,f7)},
	{hx::fsFloat,(void *) &Config_obj::contactContinuousStaticBiasCoef,HX_("contactContinuousStaticBiasCoef",23,fc,f1,34)},
	{hx::fsFloat,(void *) &Config_obj::constraintLinearSlop,HX_("constraintLinearSlop",3c,ad,d8,5c)},
	{hx::fsFloat,(void *) &Config_obj::constraintAngularSlop,HX_("constraintAngularSlop",9f,3c,70,ad)},
	{hx::fsFloat,(void *) &Config_obj::illConditionedThreshold,HX_("illConditionedThreshold",5a,3f,3e,bd)},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Config_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Config_obj::epsilon,"epsilon");
	HX_MARK_MEMBER_NAME(Config_obj::fluidAngularDragFriction,"fluidAngularDragFriction");
	HX_MARK_MEMBER_NAME(Config_obj::fluidAngularDrag,"fluidAngularDrag");
	HX_MARK_MEMBER_NAME(Config_obj::fluidVacuumDrag,"fluidVacuumDrag");
	HX_MARK_MEMBER_NAME(Config_obj::fluidLinearDrag,"fluidLinearDrag");
	HX_MARK_MEMBER_NAME(Config_obj::collisionSlop,"collisionSlop");
	HX_MARK_MEMBER_NAME(Config_obj::collisionSlopCCD,"collisionSlopCCD");
	HX_MARK_MEMBER_NAME(Config_obj::distanceThresholdCCD,"distanceThresholdCCD");
	HX_MARK_MEMBER_NAME(Config_obj::staticCCDLinearThreshold,"staticCCDLinearThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::staticCCDAngularThreshold,"staticCCDAngularThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::bulletCCDLinearThreshold,"bulletCCDLinearThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::bulletCCDAngularThreshold,"bulletCCDAngularThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::dynamicSweepLinearThreshold,"dynamicSweepLinearThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::dynamicSweepAngularThreshold,"dynamicSweepAngularThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::angularCCDSlipScale,"angularCCDSlipScale");
	HX_MARK_MEMBER_NAME(Config_obj::arbiterExpirationDelay,"arbiterExpirationDelay");
	HX_MARK_MEMBER_NAME(Config_obj::staticFrictionThreshold,"staticFrictionThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::elasticThreshold,"elasticThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::sleepDelay,"sleepDelay");
	HX_MARK_MEMBER_NAME(Config_obj::linearSleepThreshold,"linearSleepThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::angularSleepThreshold,"angularSleepThreshold");
	HX_MARK_MEMBER_NAME(Config_obj::contactBiasCoef,"contactBiasCoef");
	HX_MARK_MEMBER_NAME(Config_obj::contactStaticBiasCoef,"contactStaticBiasCoef");
	HX_MARK_MEMBER_NAME(Config_obj::contactContinuousBiasCoef,"contactContinuousBiasCoef");
	HX_MARK_MEMBER_NAME(Config_obj::contactContinuousStaticBiasCoef,"contactContinuousStaticBiasCoef");
	HX_MARK_MEMBER_NAME(Config_obj::constraintLinearSlop,"constraintLinearSlop");
	HX_MARK_MEMBER_NAME(Config_obj::constraintAngularSlop,"constraintAngularSlop");
	HX_MARK_MEMBER_NAME(Config_obj::illConditionedThreshold,"illConditionedThreshold");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Config_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Config_obj::epsilon,"epsilon");
	HX_VISIT_MEMBER_NAME(Config_obj::fluidAngularDragFriction,"fluidAngularDragFriction");
	HX_VISIT_MEMBER_NAME(Config_obj::fluidAngularDrag,"fluidAngularDrag");
	HX_VISIT_MEMBER_NAME(Config_obj::fluidVacuumDrag,"fluidVacuumDrag");
	HX_VISIT_MEMBER_NAME(Config_obj::fluidLinearDrag,"fluidLinearDrag");
	HX_VISIT_MEMBER_NAME(Config_obj::collisionSlop,"collisionSlop");
	HX_VISIT_MEMBER_NAME(Config_obj::collisionSlopCCD,"collisionSlopCCD");
	HX_VISIT_MEMBER_NAME(Config_obj::distanceThresholdCCD,"distanceThresholdCCD");
	HX_VISIT_MEMBER_NAME(Config_obj::staticCCDLinearThreshold,"staticCCDLinearThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::staticCCDAngularThreshold,"staticCCDAngularThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::bulletCCDLinearThreshold,"bulletCCDLinearThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::bulletCCDAngularThreshold,"bulletCCDAngularThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::dynamicSweepLinearThreshold,"dynamicSweepLinearThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::dynamicSweepAngularThreshold,"dynamicSweepAngularThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::angularCCDSlipScale,"angularCCDSlipScale");
	HX_VISIT_MEMBER_NAME(Config_obj::arbiterExpirationDelay,"arbiterExpirationDelay");
	HX_VISIT_MEMBER_NAME(Config_obj::staticFrictionThreshold,"staticFrictionThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::elasticThreshold,"elasticThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::sleepDelay,"sleepDelay");
	HX_VISIT_MEMBER_NAME(Config_obj::linearSleepThreshold,"linearSleepThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::angularSleepThreshold,"angularSleepThreshold");
	HX_VISIT_MEMBER_NAME(Config_obj::contactBiasCoef,"contactBiasCoef");
	HX_VISIT_MEMBER_NAME(Config_obj::contactStaticBiasCoef,"contactStaticBiasCoef");
	HX_VISIT_MEMBER_NAME(Config_obj::contactContinuousBiasCoef,"contactContinuousBiasCoef");
	HX_VISIT_MEMBER_NAME(Config_obj::contactContinuousStaticBiasCoef,"contactContinuousStaticBiasCoef");
	HX_VISIT_MEMBER_NAME(Config_obj::constraintLinearSlop,"constraintLinearSlop");
	HX_VISIT_MEMBER_NAME(Config_obj::constraintAngularSlop,"constraintAngularSlop");
	HX_VISIT_MEMBER_NAME(Config_obj::illConditionedThreshold,"illConditionedThreshold");
};

#endif

hx::Class Config_obj::__mClass;

static ::String Config_obj_sStaticFields[] = {
	HX_("epsilon",6a,b5,be,ac),
	HX_("fluidAngularDragFriction",26,07,b7,e8),
	HX_("fluidAngularDrag",0c,e6,94,fb),
	HX_("fluidVacuumDrag",73,4b,c6,0a),
	HX_("fluidLinearDrag",23,0f,1a,dd),
	HX_("collisionSlop",8c,d3,8b,2c),
	HX_("collisionSlopCCD",98,fd,16,d1),
	HX_("distanceThresholdCCD",ae,05,89,27),
	HX_("staticCCDLinearThreshold",f0,7b,b6,14),
	HX_("staticCCDAngularThreshold",3f,06,d5,58),
	HX_("bulletCCDLinearThreshold",84,26,2c,43),
	HX_("bulletCCDAngularThreshold",2b,9d,54,d1),
	HX_("dynamicSweepLinearThreshold",99,4d,9b,9c),
	HX_("dynamicSweepAngularThreshold",76,a8,27,b9),
	HX_("angularCCDSlipScale",48,a1,74,a2),
	HX_("arbiterExpirationDelay",eb,97,56,94),
	HX_("staticFrictionThreshold",c3,fa,d5,c0),
	HX_("elasticThreshold",16,3f,87,62),
	HX_("sleepDelay",ec,b6,77,8a),
	HX_("linearSleepThreshold",59,98,fa,f1),
	HX_("angularSleepThreshold",16,d6,01,9c),
	HX_("contactBiasCoef",e6,cf,ff,89),
	HX_("contactStaticBiasCoef",b4,56,1c,b7),
	HX_("contactContinuousBiasCoef",15,a8,b2,f7),
	HX_("contactContinuousStaticBiasCoef",23,fc,f1,34),
	HX_("constraintLinearSlop",3c,ad,d8,5c),
	HX_("constraintAngularSlop",9f,3c,70,ad),
	HX_("illConditionedThreshold",5a,3f,3e,bd),
	::String(null())
};

void Config_obj::__register()
{
	Config_obj _hx_dummy;
	Config_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.Config",a8,99,90,8b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Config_obj::__GetStatic;
	__mClass->mSetStaticField = &Config_obj::__SetStatic;
	__mClass->mMarkFunc = Config_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Config_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Config_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Config_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Config_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Config_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Config_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_15_boot)
HXDLIN(  15)		epsilon = ((Float)1e-8);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_27_boot)
HXDLIN(  27)		fluidAngularDragFriction = ((Float)2.5);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_40_boot)
HXDLIN(  40)		fluidAngularDrag = ((Float)100);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_53_boot)
HXDLIN(  53)		fluidVacuumDrag = ((Float)0.5);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_62_boot)
HXDLIN(  62)		fluidLinearDrag = ((Float)0.5);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_69_boot)
HXDLIN(  69)		collisionSlop = ((Float)0.2);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_77_boot)
HXDLIN(  77)		collisionSlopCCD = ((Float)0.5);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_88_boot)
HXDLIN(  88)		distanceThresholdCCD = ((Float)0.05);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_104_boot)
HXDLIN( 104)		staticCCDLinearThreshold = ((Float)0.05);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_121_boot)
HXDLIN( 121)		staticCCDAngularThreshold = ((Float)0.005);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_136_boot)
HXDLIN( 136)		bulletCCDLinearThreshold = ((Float)0.125);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_145_boot)
HXDLIN( 145)		bulletCCDAngularThreshold = ((Float)0.0125);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_157_boot)
HXDLIN( 157)		dynamicSweepLinearThreshold = ((Float)17);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_174_boot)
HXDLIN( 174)		dynamicSweepAngularThreshold = ((Float)0.6);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_188_boot)
HXDLIN( 188)		angularCCDSlipScale = ((Float)0.75);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_200_boot)
HXDLIN( 200)		arbiterExpirationDelay = 6;
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_210_boot)
HXDLIN( 210)		staticFrictionThreshold = ((Float)2);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_222_boot)
HXDLIN( 222)		elasticThreshold = ((Float)20);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_234_boot)
HXDLIN( 234)		sleepDelay = 60;
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_244_boot)
HXDLIN( 244)		linearSleepThreshold = ((Float)0.2);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_258_boot)
HXDLIN( 258)		angularSleepThreshold = ((Float)0.4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_269_boot)
HXDLIN( 269)		contactBiasCoef = ((Float)0.3);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_279_boot)
HXDLIN( 279)		contactStaticBiasCoef = ((Float)0.6);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_289_boot)
HXDLIN( 289)		contactContinuousBiasCoef = ((Float)0.4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_299_boot)
HXDLIN( 299)		contactContinuousStaticBiasCoef = ((Float)0.5);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_309_boot)
HXDLIN( 309)		constraintLinearSlop = ((Float)0.1);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_319_boot)
HXDLIN( 319)		constraintAngularSlop = ((Float)1e-3);
            	}
{
            	HX_STACKFRAME(&_hx_pos_1cc65b763db1b828_332_boot)
HXDLIN( 332)		illConditionedThreshold = ((Float)2e+8);
            	}
}

} // end namespace nape
