// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_dynamics_Arbiter
#include <hxinc/nape/dynamics/Arbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_CollisionArbiter
#include <hxinc/nape/dynamics/CollisionArbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_Contact
#include <hxinc/nape/dynamics/Contact.h>
#endif
#ifndef INCLUDED_nape_dynamics_ContactList
#include <hxinc/nape/dynamics/ContactList.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_geom_Vec3
#include <hxinc/nape/geom/Vec3.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_shape_Edge
#include <hxinc/nape/shape/Edge.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <hxinc/nape/shape/Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Arbiter
#include <hxinc/zpp_nape/dynamics/ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_ColArbiter
#include <hxinc/zpp_nape/dynamics/ZPP_ColArbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Contact
#include <hxinc/zpp_nape/dynamics/ZPP_Contact.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec3
#include <hxinc/zpp_nape/geom/ZPP_Vec3.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Material
#include <hxinc/zpp_nape/phys/ZPP_Material.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Edge
#include <hxinc/zpp_nape/shape/ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Polygon
#include <hxinc/zpp_nape/shape/ZPP_Polygon.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <hxinc/zpp_nape/shape/ZPP_Shape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_841e18e210cad5d1_728_new,"nape.dynamics.CollisionArbiter","new",0xd8a0cabd,"nape.dynamics.CollisionArbiter.new","nape/dynamics/CollisionArbiter.hx",728,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_183_get_contacts,"nape.dynamics.CollisionArbiter","get_contacts",0x33e1d7df,"nape.dynamics.CollisionArbiter.get_contacts","nape/dynamics/CollisionArbiter.hx",183,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_199_get_normal,"nape.dynamics.CollisionArbiter","get_normal",0x34ea9d33,"nape.dynamics.CollisionArbiter.get_normal","nape/dynamics/CollisionArbiter.hx",199,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_213_get_radius,"nape.dynamics.CollisionArbiter","get_radius",0xb577fb5e,"nape.dynamics.CollisionArbiter.get_radius","nape/dynamics/CollisionArbiter.hx",213,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_225_get_referenceEdge1,"nape.dynamics.CollisionArbiter","get_referenceEdge1",0x7f96cc95,"nape.dynamics.CollisionArbiter.get_referenceEdge1","nape/dynamics/CollisionArbiter.hx",225,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_239_get_referenceEdge2,"nape.dynamics.CollisionArbiter","get_referenceEdge2",0x7f96cc96,"nape.dynamics.CollisionArbiter.get_referenceEdge2","nape/dynamics/CollisionArbiter.hx",239,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_257_firstVertex,"nape.dynamics.CollisionArbiter","firstVertex",0xec742b11,"nape.dynamics.CollisionArbiter.firstVertex","nape/dynamics/CollisionArbiter.hx",257,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_276_secondVertex,"nape.dynamics.CollisionArbiter","secondVertex",0x2e747ffb,"nape.dynamics.CollisionArbiter.secondVertex","nape/dynamics/CollisionArbiter.hx",276,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_300_normalImpulse,"nape.dynamics.CollisionArbiter","normalImpulse",0xbc1d19eb,"nape.dynamics.CollisionArbiter.normalImpulse","nape/dynamics/CollisionArbiter.hx",300,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_394_tangentImpulse,"nape.dynamics.CollisionArbiter","tangentImpulse",0xec0a4733,"nape.dynamics.CollisionArbiter.tangentImpulse","nape/dynamics/CollisionArbiter.hx",394,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_485_totalImpulse,"nape.dynamics.CollisionArbiter","totalImpulse",0x690d3754,"nape.dynamics.CollisionArbiter.totalImpulse","nape/dynamics/CollisionArbiter.hx",485,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_573_rollingImpulse,"nape.dynamics.CollisionArbiter","rollingImpulse",0x51a9ce73,"nape.dynamics.CollisionArbiter.rollingImpulse","nape/dynamics/CollisionArbiter.hx",573,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_596_get_elasticity,"nape.dynamics.CollisionArbiter","get_elasticity",0x4a75c485,"nape.dynamics.CollisionArbiter.get_elasticity","nape/dynamics/CollisionArbiter.hx",596,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_604_set_elasticity,"nape.dynamics.CollisionArbiter","set_elasticity",0x6a95acf9,"nape.dynamics.CollisionArbiter.set_elasticity","nape/dynamics/CollisionArbiter.hx",604,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_631_get_dynamicFriction,"nape.dynamics.CollisionArbiter","get_dynamicFriction",0x4389ff0d,"nape.dynamics.CollisionArbiter.get_dynamicFriction","nape/dynamics/CollisionArbiter.hx",631,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_639_set_dynamicFriction,"nape.dynamics.CollisionArbiter","set_dynamicFriction",0x8026f219,"nape.dynamics.CollisionArbiter.set_dynamicFriction","nape/dynamics/CollisionArbiter.hx",639,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_666_get_staticFriction,"nape.dynamics.CollisionArbiter","get_staticFriction",0x9e3d86d4,"nape.dynamics.CollisionArbiter.get_staticFriction","nape/dynamics/CollisionArbiter.hx",666,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_674_set_staticFriction,"nape.dynamics.CollisionArbiter","set_staticFriction",0x7aecb948,"nape.dynamics.CollisionArbiter.set_staticFriction","nape/dynamics/CollisionArbiter.hx",674,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_701_get_rollingFriction,"nape.dynamics.CollisionArbiter","get_rollingFriction",0x20008313,"nape.dynamics.CollisionArbiter.get_rollingFriction","nape/dynamics/CollisionArbiter.hx",701,0xb8178f73)
HX_LOCAL_STACK_FRAME(_hx_pos_841e18e210cad5d1_709_set_rollingFriction,"nape.dynamics.CollisionArbiter","set_rollingFriction",0x5c9d761f,"nape.dynamics.CollisionArbiter.set_rollingFriction","nape/dynamics/CollisionArbiter.hx",709,0xb8178f73)
namespace nape{
namespace dynamics{

void CollisionArbiter_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_728_new)
HXLINE( 730)		if (!(::zpp_nape::dynamics::ZPP_Arbiter_obj::internal)) {
HXLINE( 730)			HX_STACK_DO_THROW(HX_("Error: Cannot instantiate CollisionArbiter derp!",1e,50,df,ec));
            		}
HXLINE( 732)		super::__construct();
            	}

Dynamic CollisionArbiter_obj::__CreateEmpty() { return new CollisionArbiter_obj; }

void *CollisionArbiter_obj::_hx_vtable = 0;

Dynamic CollisionArbiter_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< CollisionArbiter_obj > _hx_result = new CollisionArbiter_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool CollisionArbiter_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3d1477e9) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x3d1477e9;
	} else {
		return inClassId==(int)0x7dbe69fb;
	}
}

 ::nape::dynamics::ContactList CollisionArbiter_obj::get_contacts(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_183_get_contacts)
HXLINE( 185)		if (!(this->zpp_inner->active)) {
HXLINE( 185)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 187)		if (hx::IsNull( this->zpp_inner->colarb->wrap_contacts )) {
HXLINE( 187)			this->zpp_inner->colarb->setupcontacts();
            		}
HXLINE( 188)		return this->zpp_inner->colarb->wrap_contacts;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_contacts,return )

 ::nape::geom::Vec2 CollisionArbiter_obj::get_normal(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_199_get_normal)
HXLINE( 201)		if (!(this->zpp_inner->active)) {
HXLINE( 201)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 203)		if (hx::IsNull( this->zpp_inner->colarb->wrap_normal )) {
HXLINE( 203)			this->zpp_inner->colarb->getnormal();
            		}
HXLINE( 204)		return this->zpp_inner->colarb->wrap_normal;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_normal,return )

Float CollisionArbiter_obj::get_radius(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_213_get_radius)
HXLINE( 215)		if (!(this->zpp_inner->active)) {
HXLINE( 215)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 217)		return this->zpp_inner->colarb->radius;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_radius,return )

 ::nape::shape::Edge CollisionArbiter_obj::get_referenceEdge1(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_225_get_referenceEdge1)
HXLINE( 227)		if (!(this->zpp_inner->active)) {
HXLINE( 227)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 229)		 ::zpp_nape::shape::ZPP_Edge edge = this->zpp_inner->colarb->_hx___ref_edge1;
HXLINE( 230)		bool _hx_tmp;
HXDLIN( 230)		if (hx::IsNotNull( edge )) {
HXLINE( 230)			if (!(this->zpp_inner->active)) {
HXLINE( 230)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 230)			 ::nape::shape::Shape _this;
HXDLIN( 230)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 230)				_this = this->zpp_inner->ws2->outer;
            			}
            			else {
HXLINE( 230)				_this = this->zpp_inner->ws1->outer;
            			}
HXDLIN( 230)			if ((_this->zpp_inner->type == 1)) {
HXLINE( 230)				if (!(this->zpp_inner->active)) {
HXLINE( 230)					HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            				}
HXDLIN( 230)				 ::nape::shape::Shape _hx_tmp1;
HXDLIN( 230)				if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 230)					_hx_tmp1 = this->zpp_inner->ws2->outer;
            				}
            				else {
HXLINE( 230)					_hx_tmp1 = this->zpp_inner->ws1->outer;
            				}
HXDLIN( 230)				_hx_tmp = hx::IsNotEq( _hx_tmp1->zpp_inner,edge->polygon );
            			}
            			else {
HXLINE( 230)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 230)			_hx_tmp = false;
            		}
HXDLIN( 230)		if (_hx_tmp) {
HXLINE( 230)			edge = this->zpp_inner->colarb->_hx___ref_edge2;
            		}
HXLINE( 231)		if (hx::IsNull( edge )) {
HXLINE( 231)			return null();
            		}
            		else {
HXLINE( 231)			return edge->wrapper();
            		}
HXDLIN( 231)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_referenceEdge1,return )

 ::nape::shape::Edge CollisionArbiter_obj::get_referenceEdge2(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_239_get_referenceEdge2)
HXLINE( 241)		if (!(this->zpp_inner->active)) {
HXLINE( 241)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 243)		 ::zpp_nape::shape::ZPP_Edge edge = this->zpp_inner->colarb->_hx___ref_edge1;
HXLINE( 244)		bool _hx_tmp;
HXDLIN( 244)		if (hx::IsNotNull( edge )) {
HXLINE( 244)			if (!(this->zpp_inner->active)) {
HXLINE( 244)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 244)			 ::nape::shape::Shape _this;
HXDLIN( 244)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 244)				_this = this->zpp_inner->ws1->outer;
            			}
            			else {
HXLINE( 244)				_this = this->zpp_inner->ws2->outer;
            			}
HXDLIN( 244)			if ((_this->zpp_inner->type == 1)) {
HXLINE( 244)				if (!(this->zpp_inner->active)) {
HXLINE( 244)					HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            				}
HXDLIN( 244)				 ::nape::shape::Shape _hx_tmp1;
HXDLIN( 244)				if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 244)					_hx_tmp1 = this->zpp_inner->ws1->outer;
            				}
            				else {
HXLINE( 244)					_hx_tmp1 = this->zpp_inner->ws2->outer;
            				}
HXDLIN( 244)				_hx_tmp = hx::IsNotEq( _hx_tmp1->zpp_inner,edge->polygon );
            			}
            			else {
HXLINE( 244)				_hx_tmp = true;
            			}
            		}
            		else {
HXLINE( 244)			_hx_tmp = false;
            		}
HXDLIN( 244)		if (_hx_tmp) {
HXLINE( 244)			edge = this->zpp_inner->colarb->_hx___ref_edge2;
            		}
HXLINE( 245)		if (hx::IsNull( edge )) {
HXLINE( 245)			return null();
            		}
            		else {
HXLINE( 245)			return edge->wrapper();
            		}
HXDLIN( 245)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_referenceEdge2,return )

bool CollisionArbiter_obj::firstVertex(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_257_firstVertex)
HXLINE( 259)		if (!(this->zpp_inner->active)) {
HXLINE( 259)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 261)		bool poly2circle = (hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge1 ) != hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge2 ));
HXLINE( 262)		if (poly2circle) {
HXLINE( 262)			return (this->zpp_inner->colarb->_hx___ref_vertex == -1);
            		}
            		else {
HXLINE( 262)			return false;
            		}
HXDLIN( 262)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,firstVertex,return )

bool CollisionArbiter_obj::secondVertex(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_276_secondVertex)
HXLINE( 278)		if (!(this->zpp_inner->active)) {
HXLINE( 278)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 280)		bool poly2circle = (hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge1 ) != hx::IsNotNull( this->zpp_inner->colarb->_hx___ref_edge2 ));
HXLINE( 281)		if (poly2circle) {
HXLINE( 281)			return (this->zpp_inner->colarb->_hx___ref_vertex == 1);
            		}
            		else {
HXLINE( 281)			return false;
            		}
HXDLIN( 281)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,secondVertex,return )

 ::nape::geom::Vec3 CollisionArbiter_obj::normalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_300_normalImpulse)
HXLINE( 302)		if (!(this->zpp_inner->active)) {
HXLINE( 302)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 305)		bool _hx_tmp;
HXDLIN( 305)		bool _hx_tmp1;
HXDLIN( 305)		if (hx::IsNotNull( body )) {
HXLINE( 305)			if (!(this->zpp_inner->active)) {
HXLINE( 305)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 305)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 305)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 305)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 305)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 305)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 305)			_hx_tmp1 = false;
            		}
HXDLIN( 305)		if (_hx_tmp1) {
HXLINE( 305)			if (!(this->zpp_inner->active)) {
HXLINE( 305)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 305)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 305)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 305)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 305)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 305)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 305)			_hx_tmp = false;
            		}
HXDLIN( 305)		if (_hx_tmp) {
HXLINE( 305)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 307)		Float retx = ( (Float)(0) );
HXLINE( 308)		Float rety = ( (Float)(0) );
HXLINE( 325)		Float retz = ( (Float)(0) );
HXLINE( 326)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 328)		bool _hx_tmp4;
HXDLIN( 328)		if (!(!(freshOnly))) {
HXLINE( 328)			_hx_tmp4 = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 328)			_hx_tmp4 = true;
            		}
HXDLIN( 328)		if (_hx_tmp4) {
HXLINE( 329)			 ::nape::geom::Vec3 imp = colarb->oc1->wrapper()->normalImpulse(body);
HXLINE( 330)			{
HXLINE( 331)				int t = 1;
HXLINE( 332)				{
HXLINE( 333)					int t1 = t;
HXLINE( 342)					bool retx1;
HXDLIN( 342)					if (hx::IsNotNull( imp )) {
HXLINE( 342)						retx1 = imp->zpp_disp;
            					}
            					else {
HXLINE( 342)						retx1 = false;
            					}
HXDLIN( 342)					if (retx1) {
HXLINE( 342)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 342)					{
HXLINE( 342)						 ::zpp_nape::geom::ZPP_Vec3 _this = imp->zpp_inner;
HXDLIN( 342)						if (hx::IsNotNull( _this->_validate )) {
HXLINE( 342)							_this->_validate();
            						}
            					}
HXDLIN( 342)					retx = (retx + (imp->zpp_inner->x * ( (Float)(t1) )));
HXLINE( 343)					bool rety1;
HXDLIN( 343)					if (hx::IsNotNull( imp )) {
HXLINE( 343)						rety1 = imp->zpp_disp;
            					}
            					else {
HXLINE( 343)						rety1 = false;
            					}
HXDLIN( 343)					if (rety1) {
HXLINE( 343)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 343)					{
HXLINE( 343)						 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp->zpp_inner;
HXDLIN( 343)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 343)							_this1->_validate();
            						}
            					}
HXDLIN( 343)					rety = (rety + (imp->zpp_inner->y * ( (Float)(t1) )));
            				}
HXLINE( 345)				bool retz1;
HXDLIN( 345)				if (hx::IsNotNull( imp )) {
HXLINE( 345)					retz1 = imp->zpp_disp;
            				}
            				else {
HXLINE( 345)					retz1 = false;
            				}
HXDLIN( 345)				if (retz1) {
HXLINE( 345)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 345)				{
HXLINE( 345)					 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp->zpp_inner;
HXDLIN( 345)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 345)						_this2->_validate();
            					}
            				}
HXDLIN( 345)				retz = (retz + (imp->zpp_inner->z * ( (Float)(t) )));
            			}
HXLINE( 347)			imp->dispose();
            		}
HXLINE( 350)		if (colarb->hc2) {
HXLINE( 351)			bool _hx_tmp5;
HXDLIN( 351)			if (!(!(freshOnly))) {
HXLINE( 351)				_hx_tmp5 = colarb->oc2->fresh;
            			}
            			else {
HXLINE( 351)				_hx_tmp5 = true;
            			}
HXDLIN( 351)			if (_hx_tmp5) {
HXLINE( 352)				 ::nape::geom::Vec3 imp1 = colarb->oc2->wrapper()->normalImpulse(body);
HXLINE( 353)				{
HXLINE( 354)					int t2 = 1;
HXLINE( 355)					{
HXLINE( 356)						int t3 = t2;
HXLINE( 365)						bool retx2;
HXDLIN( 365)						if (hx::IsNotNull( imp1 )) {
HXLINE( 365)							retx2 = imp1->zpp_disp;
            						}
            						else {
HXLINE( 365)							retx2 = false;
            						}
HXDLIN( 365)						if (retx2) {
HXLINE( 365)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 365)						{
HXLINE( 365)							 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN( 365)							if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 365)								_this3->_validate();
            							}
            						}
HXDLIN( 365)						retx = (retx + (imp1->zpp_inner->x * ( (Float)(t3) )));
HXLINE( 366)						bool rety2;
HXDLIN( 366)						if (hx::IsNotNull( imp1 )) {
HXLINE( 366)							rety2 = imp1->zpp_disp;
            						}
            						else {
HXLINE( 366)							rety2 = false;
            						}
HXDLIN( 366)						if (rety2) {
HXLINE( 366)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 366)						{
HXLINE( 366)							 ::zpp_nape::geom::ZPP_Vec3 _this4 = imp1->zpp_inner;
HXDLIN( 366)							if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 366)								_this4->_validate();
            							}
            						}
HXDLIN( 366)						rety = (rety + (imp1->zpp_inner->y * ( (Float)(t3) )));
            					}
HXLINE( 368)					bool retz2;
HXDLIN( 368)					if (hx::IsNotNull( imp1 )) {
HXLINE( 368)						retz2 = imp1->zpp_disp;
            					}
            					else {
HXLINE( 368)						retz2 = false;
            					}
HXDLIN( 368)					if (retz2) {
HXLINE( 368)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 368)					{
HXLINE( 368)						 ::zpp_nape::geom::ZPP_Vec3 _this5 = imp1->zpp_inner;
HXDLIN( 368)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 368)							_this5->_validate();
            						}
            					}
HXDLIN( 368)					retz = (retz + (imp1->zpp_inner->z * ( (Float)(t2) )));
            				}
HXLINE( 370)				imp1->dispose();
            			}
            		}
HXLINE( 373)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CollisionArbiter_obj,normalImpulse,return )

 ::nape::geom::Vec3 CollisionArbiter_obj::tangentImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_394_tangentImpulse)
HXLINE( 396)		if (!(this->zpp_inner->active)) {
HXLINE( 396)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 399)		bool _hx_tmp;
HXDLIN( 399)		bool _hx_tmp1;
HXDLIN( 399)		if (hx::IsNotNull( body )) {
HXLINE( 399)			if (!(this->zpp_inner->active)) {
HXLINE( 399)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 399)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 399)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 399)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 399)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 399)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 399)			_hx_tmp1 = false;
            		}
HXDLIN( 399)		if (_hx_tmp1) {
HXLINE( 399)			if (!(this->zpp_inner->active)) {
HXLINE( 399)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 399)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 399)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 399)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 399)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 399)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 399)			_hx_tmp = false;
            		}
HXDLIN( 399)		if (_hx_tmp) {
HXLINE( 399)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 401)		Float retx = ( (Float)(0) );
HXLINE( 402)		Float rety = ( (Float)(0) );
HXLINE( 419)		Float retz = ( (Float)(0) );
HXLINE( 420)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 422)		bool _hx_tmp4;
HXDLIN( 422)		if (!(!(freshOnly))) {
HXLINE( 422)			_hx_tmp4 = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 422)			_hx_tmp4 = true;
            		}
HXDLIN( 422)		if (_hx_tmp4) {
HXLINE( 423)			 ::nape::geom::Vec3 imp = colarb->oc1->wrapper()->tangentImpulse(body);
HXLINE( 424)			{
HXLINE( 425)				int t = 1;
HXLINE( 426)				{
HXLINE( 427)					int t1 = t;
HXLINE( 436)					bool retx1;
HXDLIN( 436)					if (hx::IsNotNull( imp )) {
HXLINE( 436)						retx1 = imp->zpp_disp;
            					}
            					else {
HXLINE( 436)						retx1 = false;
            					}
HXDLIN( 436)					if (retx1) {
HXLINE( 436)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 436)					{
HXLINE( 436)						 ::zpp_nape::geom::ZPP_Vec3 _this = imp->zpp_inner;
HXDLIN( 436)						if (hx::IsNotNull( _this->_validate )) {
HXLINE( 436)							_this->_validate();
            						}
            					}
HXDLIN( 436)					retx = (retx + (imp->zpp_inner->x * ( (Float)(t1) )));
HXLINE( 437)					bool rety1;
HXDLIN( 437)					if (hx::IsNotNull( imp )) {
HXLINE( 437)						rety1 = imp->zpp_disp;
            					}
            					else {
HXLINE( 437)						rety1 = false;
            					}
HXDLIN( 437)					if (rety1) {
HXLINE( 437)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 437)					{
HXLINE( 437)						 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp->zpp_inner;
HXDLIN( 437)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 437)							_this1->_validate();
            						}
            					}
HXDLIN( 437)					rety = (rety + (imp->zpp_inner->y * ( (Float)(t1) )));
            				}
HXLINE( 439)				bool retz1;
HXDLIN( 439)				if (hx::IsNotNull( imp )) {
HXLINE( 439)					retz1 = imp->zpp_disp;
            				}
            				else {
HXLINE( 439)					retz1 = false;
            				}
HXDLIN( 439)				if (retz1) {
HXLINE( 439)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 439)				{
HXLINE( 439)					 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp->zpp_inner;
HXDLIN( 439)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 439)						_this2->_validate();
            					}
            				}
HXDLIN( 439)				retz = (retz + (imp->zpp_inner->z * ( (Float)(t) )));
            			}
HXLINE( 441)			imp->dispose();
            		}
HXLINE( 444)		if (colarb->hc2) {
HXLINE( 445)			bool _hx_tmp5;
HXDLIN( 445)			if (!(!(freshOnly))) {
HXLINE( 445)				_hx_tmp5 = colarb->oc2->fresh;
            			}
            			else {
HXLINE( 445)				_hx_tmp5 = true;
            			}
HXDLIN( 445)			if (_hx_tmp5) {
HXLINE( 446)				 ::nape::geom::Vec3 imp1 = colarb->oc2->wrapper()->tangentImpulse(body);
HXLINE( 447)				{
HXLINE( 448)					int t2 = 1;
HXLINE( 449)					{
HXLINE( 450)						int t3 = t2;
HXLINE( 459)						bool retx2;
HXDLIN( 459)						if (hx::IsNotNull( imp1 )) {
HXLINE( 459)							retx2 = imp1->zpp_disp;
            						}
            						else {
HXLINE( 459)							retx2 = false;
            						}
HXDLIN( 459)						if (retx2) {
HXLINE( 459)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 459)						{
HXLINE( 459)							 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN( 459)							if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 459)								_this3->_validate();
            							}
            						}
HXDLIN( 459)						retx = (retx + (imp1->zpp_inner->x * ( (Float)(t3) )));
HXLINE( 460)						bool rety2;
HXDLIN( 460)						if (hx::IsNotNull( imp1 )) {
HXLINE( 460)							rety2 = imp1->zpp_disp;
            						}
            						else {
HXLINE( 460)							rety2 = false;
            						}
HXDLIN( 460)						if (rety2) {
HXLINE( 460)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 460)						{
HXLINE( 460)							 ::zpp_nape::geom::ZPP_Vec3 _this4 = imp1->zpp_inner;
HXDLIN( 460)							if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 460)								_this4->_validate();
            							}
            						}
HXDLIN( 460)						rety = (rety + (imp1->zpp_inner->y * ( (Float)(t3) )));
            					}
HXLINE( 462)					bool retz2;
HXDLIN( 462)					if (hx::IsNotNull( imp1 )) {
HXLINE( 462)						retz2 = imp1->zpp_disp;
            					}
            					else {
HXLINE( 462)						retz2 = false;
            					}
HXDLIN( 462)					if (retz2) {
HXLINE( 462)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 462)					{
HXLINE( 462)						 ::zpp_nape::geom::ZPP_Vec3 _this5 = imp1->zpp_inner;
HXDLIN( 462)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 462)							_this5->_validate();
            						}
            					}
HXDLIN( 462)					retz = (retz + (imp1->zpp_inner->z * ( (Float)(t2) )));
            				}
HXLINE( 464)				imp1->dispose();
            			}
            		}
HXLINE( 467)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CollisionArbiter_obj,tangentImpulse,return )

 ::nape::geom::Vec3 CollisionArbiter_obj::totalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_485_totalImpulse)
HXLINE( 487)		if (!(this->zpp_inner->active)) {
HXLINE( 487)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 490)		bool _hx_tmp;
HXDLIN( 490)		bool _hx_tmp1;
HXDLIN( 490)		if (hx::IsNotNull( body )) {
HXLINE( 490)			if (!(this->zpp_inner->active)) {
HXLINE( 490)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 490)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 490)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 490)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 490)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 490)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 490)			_hx_tmp1 = false;
            		}
HXDLIN( 490)		if (_hx_tmp1) {
HXLINE( 490)			if (!(this->zpp_inner->active)) {
HXLINE( 490)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 490)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 490)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 490)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 490)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 490)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 490)			_hx_tmp = false;
            		}
HXDLIN( 490)		if (_hx_tmp) {
HXLINE( 490)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 492)		Float retx = ( (Float)(0) );
HXLINE( 493)		Float rety = ( (Float)(0) );
HXLINE( 510)		Float retz = ( (Float)(0) );
HXLINE( 511)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 513)		bool _hx_tmp4;
HXDLIN( 513)		if (!(!(freshOnly))) {
HXLINE( 513)			_hx_tmp4 = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 513)			_hx_tmp4 = true;
            		}
HXDLIN( 513)		if (_hx_tmp4) {
HXLINE( 514)			 ::nape::geom::Vec3 imp = colarb->oc1->wrapper()->totalImpulse(body);
HXLINE( 515)			{
HXLINE( 516)				int t = 1;
HXLINE( 517)				{
HXLINE( 518)					int t1 = t;
HXLINE( 527)					bool retx1;
HXDLIN( 527)					if (hx::IsNotNull( imp )) {
HXLINE( 527)						retx1 = imp->zpp_disp;
            					}
            					else {
HXLINE( 527)						retx1 = false;
            					}
HXDLIN( 527)					if (retx1) {
HXLINE( 527)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 527)					{
HXLINE( 527)						 ::zpp_nape::geom::ZPP_Vec3 _this = imp->zpp_inner;
HXDLIN( 527)						if (hx::IsNotNull( _this->_validate )) {
HXLINE( 527)							_this->_validate();
            						}
            					}
HXDLIN( 527)					retx = (retx + (imp->zpp_inner->x * ( (Float)(t1) )));
HXLINE( 528)					bool rety1;
HXDLIN( 528)					if (hx::IsNotNull( imp )) {
HXLINE( 528)						rety1 = imp->zpp_disp;
            					}
            					else {
HXLINE( 528)						rety1 = false;
            					}
HXDLIN( 528)					if (rety1) {
HXLINE( 528)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 528)					{
HXLINE( 528)						 ::zpp_nape::geom::ZPP_Vec3 _this1 = imp->zpp_inner;
HXDLIN( 528)						if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 528)							_this1->_validate();
            						}
            					}
HXDLIN( 528)					rety = (rety + (imp->zpp_inner->y * ( (Float)(t1) )));
            				}
HXLINE( 530)				bool retz1;
HXDLIN( 530)				if (hx::IsNotNull( imp )) {
HXLINE( 530)					retz1 = imp->zpp_disp;
            				}
            				else {
HXLINE( 530)					retz1 = false;
            				}
HXDLIN( 530)				if (retz1) {
HXLINE( 530)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 530)				{
HXLINE( 530)					 ::zpp_nape::geom::ZPP_Vec3 _this2 = imp->zpp_inner;
HXDLIN( 530)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 530)						_this2->_validate();
            					}
            				}
HXDLIN( 530)				retz = (retz + (imp->zpp_inner->z * ( (Float)(t) )));
            			}
HXLINE( 532)			imp->dispose();
            		}
HXLINE( 535)		if (colarb->hc2) {
HXLINE( 536)			bool _hx_tmp5;
HXDLIN( 536)			if (!(!(freshOnly))) {
HXLINE( 536)				_hx_tmp5 = colarb->oc2->fresh;
            			}
            			else {
HXLINE( 536)				_hx_tmp5 = true;
            			}
HXDLIN( 536)			if (_hx_tmp5) {
HXLINE( 537)				 ::nape::geom::Vec3 imp1 = colarb->oc2->wrapper()->totalImpulse(body);
HXLINE( 538)				{
HXLINE( 539)					int t2 = 1;
HXLINE( 540)					{
HXLINE( 541)						int t3 = t2;
HXLINE( 550)						bool retx2;
HXDLIN( 550)						if (hx::IsNotNull( imp1 )) {
HXLINE( 550)							retx2 = imp1->zpp_disp;
            						}
            						else {
HXLINE( 550)							retx2 = false;
            						}
HXDLIN( 550)						if (retx2) {
HXLINE( 550)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 550)						{
HXLINE( 550)							 ::zpp_nape::geom::ZPP_Vec3 _this3 = imp1->zpp_inner;
HXDLIN( 550)							if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 550)								_this3->_validate();
            							}
            						}
HXDLIN( 550)						retx = (retx + (imp1->zpp_inner->x * ( (Float)(t3) )));
HXLINE( 551)						bool rety2;
HXDLIN( 551)						if (hx::IsNotNull( imp1 )) {
HXLINE( 551)							rety2 = imp1->zpp_disp;
            						}
            						else {
HXLINE( 551)							rety2 = false;
            						}
HXDLIN( 551)						if (rety2) {
HXLINE( 551)							HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            						}
HXDLIN( 551)						{
HXLINE( 551)							 ::zpp_nape::geom::ZPP_Vec3 _this4 = imp1->zpp_inner;
HXDLIN( 551)							if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 551)								_this4->_validate();
            							}
            						}
HXDLIN( 551)						rety = (rety + (imp1->zpp_inner->y * ( (Float)(t3) )));
            					}
HXLINE( 553)					bool retz2;
HXDLIN( 553)					if (hx::IsNotNull( imp1 )) {
HXLINE( 553)						retz2 = imp1->zpp_disp;
            					}
            					else {
HXLINE( 553)						retz2 = false;
            					}
HXDLIN( 553)					if (retz2) {
HXLINE( 553)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 553)					{
HXLINE( 553)						 ::zpp_nape::geom::ZPP_Vec3 _this5 = imp1->zpp_inner;
HXDLIN( 553)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 553)							_this5->_validate();
            						}
            					}
HXDLIN( 553)					retz = (retz + (imp1->zpp_inner->z * ( (Float)(t2) )));
            				}
HXLINE( 555)				imp1->dispose();
            			}
            		}
HXLINE( 558)		return ::nape::geom::Vec3_obj::get(retx,rety,retz);
            	}


Float CollisionArbiter_obj::rollingImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_573_rollingImpulse)
HXLINE( 575)		if (!(this->zpp_inner->active)) {
HXLINE( 575)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 578)		bool _hx_tmp;
HXDLIN( 578)		bool _hx_tmp1;
HXDLIN( 578)		if (hx::IsNotNull( body )) {
HXLINE( 578)			if (!(this->zpp_inner->active)) {
HXLINE( 578)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 578)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 578)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 578)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 578)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 578)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 578)			_hx_tmp1 = false;
            		}
HXDLIN( 578)		if (_hx_tmp1) {
HXLINE( 578)			if (!(this->zpp_inner->active)) {
HXLINE( 578)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 578)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 578)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 578)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 578)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 578)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 578)			_hx_tmp = false;
            		}
HXDLIN( 578)		if (_hx_tmp) {
HXLINE( 578)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 580)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 581)		bool _hx_tmp4;
HXDLIN( 581)		if (!(!(freshOnly))) {
HXLINE( 581)			_hx_tmp4 = colarb->oc1->fresh;
            		}
            		else {
HXLINE( 581)			_hx_tmp4 = true;
            		}
HXDLIN( 581)		if (_hx_tmp4) {
HXLINE( 581)			return colarb->oc1->wrapper()->rollingImpulse(body);
            		}
            		else {
HXLINE( 582)			return ((Float)0.0);
            		}
HXLINE( 581)		return ((Float)0.);
            	}


HX_DEFINE_DYNAMIC_FUNC2(CollisionArbiter_obj,rollingImpulse,return )

Float CollisionArbiter_obj::get_elasticity(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_596_get_elasticity)
HXLINE( 598)		if (!(this->zpp_inner->active)) {
HXLINE( 598)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 600)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 601)		if (colarb->invalidated) {
HXLINE( 601)			colarb->invalidated = false;
HXDLIN( 601)			{
HXLINE( 601)				if (!(colarb->userdef_restitution)) {
HXLINE( 601)					bool _hx_tmp;
HXDLIN( 601)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 601)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 601)						_hx_tmp = true;
            					}
HXDLIN( 601)					if (_hx_tmp) {
HXLINE( 601)						colarb->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 601)						bool _hx_tmp1;
HXDLIN( 601)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 601)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 601)							_hx_tmp1 = true;
            						}
HXDLIN( 601)						if (_hx_tmp1) {
HXLINE( 601)							colarb->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 601)							colarb->restitution = ((colarb->s1->material->elasticity + colarb->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 601)					if ((colarb->restitution < 0)) {
HXLINE( 601)						colarb->restitution = ( (Float)(0) );
            					}
HXDLIN( 601)					if ((colarb->restitution > 1)) {
HXLINE( 601)						colarb->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 601)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 601)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 601)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 601)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 601)				if (!(colarb->userdef_rfric)) {
HXLINE( 601)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 602)		return colarb->restitution;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_elasticity,return )

Float CollisionArbiter_obj::set_elasticity(Float elasticity){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_604_set_elasticity)
HXLINE( 605)		{
HXLINE( 607)			if (!(this->zpp_inner->colarb->_hx_mutable)) {
HXLINE( 607)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("elasticity",79,23,b4,4d)) + HX_(" is only mutable during a pre-handler",da,73,68,7a)));
            			}
HXLINE( 610)			if ((elasticity != elasticity)) {
HXLINE( 610)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("elasticity",79,23,b4,4d)) + HX_(" cannot be NaN",1b,77,40,38)));
            			}
HXLINE( 611)			if ((elasticity < 0)) {
HXLINE( 611)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("elasticity",79,23,b4,4d)) + HX_(" cannot be negative",f5,23,be,15)));
            			}
HXLINE( 614)			 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 615)			colarb->restitution = elasticity;
HXLINE( 616)			colarb->userdef_restitution = true;
            		}
HXLINE( 618)		if (!(this->zpp_inner->active)) {
HXLINE( 618)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXDLIN( 618)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb1 = this->zpp_inner->colarb;
HXDLIN( 618)		if (colarb1->invalidated) {
HXLINE( 618)			colarb1->invalidated = false;
HXDLIN( 618)			{
HXLINE( 618)				if (!(colarb1->userdef_restitution)) {
HXLINE( 618)					bool _hx_tmp;
HXDLIN( 618)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 618)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 618)						_hx_tmp = true;
            					}
HXDLIN( 618)					if (_hx_tmp) {
HXLINE( 618)						colarb1->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 618)						bool _hx_tmp1;
HXDLIN( 618)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 618)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 618)							_hx_tmp1 = true;
            						}
HXDLIN( 618)						if (_hx_tmp1) {
HXLINE( 618)							colarb1->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 618)							colarb1->restitution = ((colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 618)					if ((colarb1->restitution < 0)) {
HXLINE( 618)						colarb1->restitution = ( (Float)(0) );
            					}
HXDLIN( 618)					if ((colarb1->restitution > 1)) {
HXLINE( 618)						colarb1->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 618)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 618)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 618)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 618)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 618)				if (!(colarb1->userdef_rfric)) {
HXLINE( 618)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 618)		return colarb1->restitution;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_elasticity,return )

Float CollisionArbiter_obj::get_dynamicFriction(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_631_get_dynamicFriction)
HXLINE( 633)		if (!(this->zpp_inner->active)) {
HXLINE( 633)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 635)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 636)		if (colarb->invalidated) {
HXLINE( 636)			colarb->invalidated = false;
HXDLIN( 636)			{
HXLINE( 636)				if (!(colarb->userdef_restitution)) {
HXLINE( 636)					bool _hx_tmp;
HXDLIN( 636)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 636)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 636)						_hx_tmp = true;
            					}
HXDLIN( 636)					if (_hx_tmp) {
HXLINE( 636)						colarb->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 636)						bool _hx_tmp1;
HXDLIN( 636)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 636)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 636)							_hx_tmp1 = true;
            						}
HXDLIN( 636)						if (_hx_tmp1) {
HXLINE( 636)							colarb->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 636)							colarb->restitution = ((colarb->s1->material->elasticity + colarb->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 636)					if ((colarb->restitution < 0)) {
HXLINE( 636)						colarb->restitution = ( (Float)(0) );
            					}
HXDLIN( 636)					if ((colarb->restitution > 1)) {
HXLINE( 636)						colarb->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 636)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 636)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 636)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 636)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 636)				if (!(colarb->userdef_rfric)) {
HXLINE( 636)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 637)		return colarb->dyn_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_dynamicFriction,return )

Float CollisionArbiter_obj::set_dynamicFriction(Float dynamicFriction){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_639_set_dynamicFriction)
HXLINE( 640)		{
HXLINE( 642)			if (!(this->zpp_inner->colarb->_hx_mutable)) {
HXLINE( 642)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("dynamicFriction",99,eb,8a,da)) + HX_(" is only mutable during a pre-handler",da,73,68,7a)));
            			}
HXLINE( 645)			if ((dynamicFriction != dynamicFriction)) {
HXLINE( 645)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("dynamicFriction",99,eb,8a,da)) + HX_(" cannot be NaN",1b,77,40,38)));
            			}
HXLINE( 646)			if ((dynamicFriction < 0)) {
HXLINE( 646)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("dynamicFriction",99,eb,8a,da)) + HX_(" cannot be negative",f5,23,be,15)));
            			}
HXLINE( 649)			 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 650)			colarb->dyn_fric = dynamicFriction;
HXLINE( 651)			colarb->userdef_dyn_fric = true;
            		}
HXLINE( 653)		if (!(this->zpp_inner->active)) {
HXLINE( 653)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXDLIN( 653)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb1 = this->zpp_inner->colarb;
HXDLIN( 653)		if (colarb1->invalidated) {
HXLINE( 653)			colarb1->invalidated = false;
HXDLIN( 653)			{
HXLINE( 653)				if (!(colarb1->userdef_restitution)) {
HXLINE( 653)					bool _hx_tmp;
HXDLIN( 653)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 653)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 653)						_hx_tmp = true;
            					}
HXDLIN( 653)					if (_hx_tmp) {
HXLINE( 653)						colarb1->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 653)						bool _hx_tmp1;
HXDLIN( 653)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 653)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 653)							_hx_tmp1 = true;
            						}
HXDLIN( 653)						if (_hx_tmp1) {
HXLINE( 653)							colarb1->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 653)							colarb1->restitution = ((colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 653)					if ((colarb1->restitution < 0)) {
HXLINE( 653)						colarb1->restitution = ( (Float)(0) );
            					}
HXDLIN( 653)					if ((colarb1->restitution > 1)) {
HXLINE( 653)						colarb1->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 653)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 653)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 653)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 653)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 653)				if (!(colarb1->userdef_rfric)) {
HXLINE( 653)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 653)		return colarb1->dyn_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_dynamicFriction,return )

Float CollisionArbiter_obj::get_staticFriction(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_666_get_staticFriction)
HXLINE( 668)		if (!(this->zpp_inner->active)) {
HXLINE( 668)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 670)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 671)		if (colarb->invalidated) {
HXLINE( 671)			colarb->invalidated = false;
HXDLIN( 671)			{
HXLINE( 671)				if (!(colarb->userdef_restitution)) {
HXLINE( 671)					bool _hx_tmp;
HXDLIN( 671)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 671)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 671)						_hx_tmp = true;
            					}
HXDLIN( 671)					if (_hx_tmp) {
HXLINE( 671)						colarb->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 671)						bool _hx_tmp1;
HXDLIN( 671)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 671)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 671)							_hx_tmp1 = true;
            						}
HXDLIN( 671)						if (_hx_tmp1) {
HXLINE( 671)							colarb->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 671)							colarb->restitution = ((colarb->s1->material->elasticity + colarb->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 671)					if ((colarb->restitution < 0)) {
HXLINE( 671)						colarb->restitution = ( (Float)(0) );
            					}
HXDLIN( 671)					if ((colarb->restitution > 1)) {
HXLINE( 671)						colarb->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 671)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 671)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 671)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 671)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 671)				if (!(colarb->userdef_rfric)) {
HXLINE( 671)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 672)		return colarb->stat_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_staticFriction,return )

Float CollisionArbiter_obj::set_staticFriction(Float staticFriction){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_674_set_staticFriction)
HXLINE( 675)		{
HXLINE( 677)			if (!(this->zpp_inner->colarb->_hx_mutable)) {
HXLINE( 677)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("staticFriction",c8,6f,c8,40)) + HX_(" is only mutable during a pre-handler",da,73,68,7a)));
            			}
HXLINE( 680)			if ((staticFriction != staticFriction)) {
HXLINE( 680)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("staticFriction",c8,6f,c8,40)) + HX_(" cannot be NaN",1b,77,40,38)));
            			}
HXLINE( 681)			if ((staticFriction < 0)) {
HXLINE( 681)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("staticFriction",c8,6f,c8,40)) + HX_(" cannot be negative",f5,23,be,15)));
            			}
HXLINE( 684)			 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 685)			colarb->stat_fric = staticFriction;
HXLINE( 686)			colarb->userdef_stat_fric = true;
            		}
HXLINE( 688)		if (!(this->zpp_inner->active)) {
HXLINE( 688)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXDLIN( 688)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb1 = this->zpp_inner->colarb;
HXDLIN( 688)		if (colarb1->invalidated) {
HXLINE( 688)			colarb1->invalidated = false;
HXDLIN( 688)			{
HXLINE( 688)				if (!(colarb1->userdef_restitution)) {
HXLINE( 688)					bool _hx_tmp;
HXDLIN( 688)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 688)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 688)						_hx_tmp = true;
            					}
HXDLIN( 688)					if (_hx_tmp) {
HXLINE( 688)						colarb1->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 688)						bool _hx_tmp1;
HXDLIN( 688)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 688)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 688)							_hx_tmp1 = true;
            						}
HXDLIN( 688)						if (_hx_tmp1) {
HXLINE( 688)							colarb1->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 688)							colarb1->restitution = ((colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 688)					if ((colarb1->restitution < 0)) {
HXLINE( 688)						colarb1->restitution = ( (Float)(0) );
            					}
HXDLIN( 688)					if ((colarb1->restitution > 1)) {
HXLINE( 688)						colarb1->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 688)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 688)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 688)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 688)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 688)				if (!(colarb1->userdef_rfric)) {
HXLINE( 688)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 688)		return colarb1->stat_fric;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_staticFriction,return )

Float CollisionArbiter_obj::get_rollingFriction(){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_701_get_rollingFriction)
HXLINE( 703)		if (!(this->zpp_inner->active)) {
HXLINE( 703)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 705)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 706)		if (colarb->invalidated) {
HXLINE( 706)			colarb->invalidated = false;
HXDLIN( 706)			{
HXLINE( 706)				if (!(colarb->userdef_restitution)) {
HXLINE( 706)					bool _hx_tmp;
HXDLIN( 706)					if (!((colarb->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 706)						_hx_tmp = (colarb->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 706)						_hx_tmp = true;
            					}
HXDLIN( 706)					if (_hx_tmp) {
HXLINE( 706)						colarb->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 706)						bool _hx_tmp1;
HXDLIN( 706)						if (!((colarb->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 706)							_hx_tmp1 = (colarb->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 706)							_hx_tmp1 = true;
            						}
HXDLIN( 706)						if (_hx_tmp1) {
HXLINE( 706)							colarb->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 706)							colarb->restitution = ((colarb->s1->material->elasticity + colarb->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 706)					if ((colarb->restitution < 0)) {
HXLINE( 706)						colarb->restitution = ( (Float)(0) );
            					}
HXDLIN( 706)					if ((colarb->restitution > 1)) {
HXLINE( 706)						colarb->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 706)				if (!(colarb->userdef_dyn_fric)) {
HXLINE( 706)					colarb->dyn_fric = ::Math_obj::sqrt((colarb->s1->material->dynamicFriction * colarb->s2->material->dynamicFriction));
            				}
HXDLIN( 706)				if (!(colarb->userdef_stat_fric)) {
HXLINE( 706)					colarb->stat_fric = ::Math_obj::sqrt((colarb->s1->material->staticFriction * colarb->s2->material->staticFriction));
            				}
HXDLIN( 706)				if (!(colarb->userdef_rfric)) {
HXLINE( 706)					colarb->rfric = ::Math_obj::sqrt((colarb->s1->material->rollingFriction * colarb->s2->material->rollingFriction));
            				}
            			}
            		}
HXLINE( 707)		return colarb->rfric;
            	}


HX_DEFINE_DYNAMIC_FUNC0(CollisionArbiter_obj,get_rollingFriction,return )

Float CollisionArbiter_obj::set_rollingFriction(Float rollingFriction){
            	HX_STACKFRAME(&_hx_pos_841e18e210cad5d1_709_set_rollingFriction)
HXLINE( 710)		{
HXLINE( 712)			if (!(this->zpp_inner->colarb->_hx_mutable)) {
HXLINE( 712)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("rollingFriction",9f,6f,01,b7)) + HX_(" is only mutable during a pre-handler",da,73,68,7a)));
            			}
HXLINE( 715)			if ((rollingFriction != rollingFriction)) {
HXLINE( 715)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("rollingFriction",9f,6f,01,b7)) + HX_(" cannot be NaN",1b,77,40,38)));
            			}
HXLINE( 716)			if ((rollingFriction < 0)) {
HXLINE( 716)				HX_STACK_DO_THROW(((HX_("Error: CollisionArbiter::",05,10,45,e6) + HX_("rollingFriction",9f,6f,01,b7)) + HX_(" cannot be negative",f5,23,be,15)));
            			}
HXLINE( 719)			 ::zpp_nape::dynamics::ZPP_ColArbiter colarb = this->zpp_inner->colarb;
HXLINE( 720)			colarb->rfric = rollingFriction;
HXLINE( 721)			colarb->userdef_rfric = true;
            		}
HXLINE( 723)		if (!(this->zpp_inner->active)) {
HXLINE( 723)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXDLIN( 723)		 ::zpp_nape::dynamics::ZPP_ColArbiter colarb1 = this->zpp_inner->colarb;
HXDLIN( 723)		if (colarb1->invalidated) {
HXLINE( 723)			colarb1->invalidated = false;
HXDLIN( 723)			{
HXLINE( 723)				if (!(colarb1->userdef_restitution)) {
HXLINE( 723)					bool _hx_tmp;
HXDLIN( 723)					if (!((colarb1->s1->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY))) {
HXLINE( 723)						_hx_tmp = (colarb1->s2->material->elasticity <= ::Math_obj::NEGATIVE_INFINITY);
            					}
            					else {
HXLINE( 723)						_hx_tmp = true;
            					}
HXDLIN( 723)					if (_hx_tmp) {
HXLINE( 723)						colarb1->restitution = ( (Float)(0) );
            					}
            					else {
HXLINE( 723)						bool _hx_tmp1;
HXDLIN( 723)						if (!((colarb1->s1->material->elasticity >= ::Math_obj::POSITIVE_INFINITY))) {
HXLINE( 723)							_hx_tmp1 = (colarb1->s2->material->elasticity >= ::Math_obj::POSITIVE_INFINITY);
            						}
            						else {
HXLINE( 723)							_hx_tmp1 = true;
            						}
HXDLIN( 723)						if (_hx_tmp1) {
HXLINE( 723)							colarb1->restitution = ( (Float)(1) );
            						}
            						else {
HXLINE( 723)							colarb1->restitution = ((colarb1->s1->material->elasticity + colarb1->s2->material->elasticity) / ( (Float)(2) ));
            						}
            					}
HXDLIN( 723)					if ((colarb1->restitution < 0)) {
HXLINE( 723)						colarb1->restitution = ( (Float)(0) );
            					}
HXDLIN( 723)					if ((colarb1->restitution > 1)) {
HXLINE( 723)						colarb1->restitution = ( (Float)(1) );
            					}
            				}
HXDLIN( 723)				if (!(colarb1->userdef_dyn_fric)) {
HXLINE( 723)					colarb1->dyn_fric = ::Math_obj::sqrt((colarb1->s1->material->dynamicFriction * colarb1->s2->material->dynamicFriction));
            				}
HXDLIN( 723)				if (!(colarb1->userdef_stat_fric)) {
HXLINE( 723)					colarb1->stat_fric = ::Math_obj::sqrt((colarb1->s1->material->staticFriction * colarb1->s2->material->staticFriction));
            				}
HXDLIN( 723)				if (!(colarb1->userdef_rfric)) {
HXLINE( 723)					colarb1->rfric = ::Math_obj::sqrt((colarb1->s1->material->rollingFriction * colarb1->s2->material->rollingFriction));
            				}
            			}
            		}
HXDLIN( 723)		return colarb1->rfric;
            	}


HX_DEFINE_DYNAMIC_FUNC1(CollisionArbiter_obj,set_rollingFriction,return )


hx::ObjectPtr< CollisionArbiter_obj > CollisionArbiter_obj::__new() {
	hx::ObjectPtr< CollisionArbiter_obj > __this = new CollisionArbiter_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< CollisionArbiter_obj > CollisionArbiter_obj::__alloc(hx::Ctx *_hx_ctx) {
	CollisionArbiter_obj *__this = (CollisionArbiter_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(CollisionArbiter_obj), true, "nape.dynamics.CollisionArbiter"));
	*(void **)__this = CollisionArbiter_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

CollisionArbiter_obj::CollisionArbiter_obj()
{
}

hx::Val CollisionArbiter_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"normal") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_normal() ); }
		if (HX_FIELD_EQ(inName,"radius") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_radius() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"contacts") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_contacts() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_normal") ) { return hx::Val( get_normal_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_radius") ) { return hx::Val( get_radius_dyn() ); }
		if (HX_FIELD_EQ(inName,"elasticity") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_elasticity() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"firstVertex") ) { return hx::Val( firstVertex_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_contacts") ) { return hx::Val( get_contacts_dyn() ); }
		if (HX_FIELD_EQ(inName,"secondVertex") ) { return hx::Val( secondVertex_dyn() ); }
		if (HX_FIELD_EQ(inName,"totalImpulse") ) { return hx::Val( totalImpulse_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"normalImpulse") ) { return hx::Val( normalImpulse_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"referenceEdge1") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_referenceEdge1() ); }
		if (HX_FIELD_EQ(inName,"referenceEdge2") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_referenceEdge2() ); }
		if (HX_FIELD_EQ(inName,"tangentImpulse") ) { return hx::Val( tangentImpulse_dyn() ); }
		if (HX_FIELD_EQ(inName,"rollingImpulse") ) { return hx::Val( rollingImpulse_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_elasticity") ) { return hx::Val( get_elasticity_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_elasticity") ) { return hx::Val( set_elasticity_dyn() ); }
		if (HX_FIELD_EQ(inName,"staticFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_staticFriction() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"dynamicFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_dynamicFriction() ); }
		if (HX_FIELD_EQ(inName,"rollingFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_rollingFriction() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"get_referenceEdge1") ) { return hx::Val( get_referenceEdge1_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_referenceEdge2") ) { return hx::Val( get_referenceEdge2_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_staticFriction") ) { return hx::Val( get_staticFriction_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_staticFriction") ) { return hx::Val( set_staticFriction_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"get_dynamicFriction") ) { return hx::Val( get_dynamicFriction_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_dynamicFriction") ) { return hx::Val( set_dynamicFriction_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_rollingFriction") ) { return hx::Val( get_rollingFriction_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_rollingFriction") ) { return hx::Val( set_rollingFriction_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val CollisionArbiter_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"elasticity") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_elasticity(inValue.Cast< Float >()) ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"staticFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_staticFriction(inValue.Cast< Float >()) ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"dynamicFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_dynamicFriction(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"rollingFriction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_rollingFriction(inValue.Cast< Float >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void CollisionArbiter_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("contacts",d3,d1,76,2c));
	outFields->push(HX_("normal",27,72,69,30));
	outFields->push(HX_("radius",52,d0,f6,b0));
	outFields->push(HX_("referenceEdge1",89,b5,21,22));
	outFields->push(HX_("referenceEdge2",8a,b5,21,22));
	outFields->push(HX_("elasticity",79,23,b4,4d));
	outFields->push(HX_("dynamicFriction",99,eb,8a,da));
	outFields->push(HX_("staticFriction",c8,6f,c8,40));
	outFields->push(HX_("rollingFriction",9f,6f,01,b7));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *CollisionArbiter_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *CollisionArbiter_obj_sStaticStorageInfo = 0;
#endif

static ::String CollisionArbiter_obj_sMemberFields[] = {
	HX_("get_contacts",dc,85,90,e1),
	HX_("get_normal",f0,e1,f0,20),
	HX_("get_radius",1b,40,7e,a1),
	HX_("get_referenceEdge1",52,96,bb,bd),
	HX_("get_referenceEdge2",53,96,bb,bd),
	HX_("firstVertex",b4,0b,ea,85),
	HX_("secondVertex",f8,2d,23,dc),
	HX_("normalImpulse",4e,a9,46,07),
	HX_("tangentImpulse",70,2e,3e,65),
	HX_("totalImpulse",51,e5,bb,16),
	HX_("rollingImpulse",b0,b5,dd,ca),
	HX_("get_elasticity",c2,ab,a9,c3),
	HX_("set_elasticity",36,94,c9,e3),
	HX_("get_dynamicFriction",b0,ba,95,65),
	HX_("set_dynamicFriction",bc,ad,32,a2),
	HX_("get_staticFriction",91,50,62,dc),
	HX_("set_staticFriction",05,83,11,b9),
	HX_("get_rollingFriction",b6,3e,0c,42),
	HX_("set_rollingFriction",c2,31,a9,7e),
	::String(null()) };

hx::Class CollisionArbiter_obj::__mClass;

void CollisionArbiter_obj::__register()
{
	CollisionArbiter_obj _hx_dummy;
	CollisionArbiter_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.dynamics.CollisionArbiter",4b,a8,e3,0b);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(CollisionArbiter_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< CollisionArbiter_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CollisionArbiter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CollisionArbiter_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace dynamics
