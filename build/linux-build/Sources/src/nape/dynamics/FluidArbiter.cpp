// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_dynamics_Arbiter
#include <hxinc/nape/dynamics/Arbiter.h>
#endif
#ifndef INCLUDED_nape_dynamics_FluidArbiter
#include <hxinc/nape/dynamics/FluidArbiter.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_geom_Vec3
#include <hxinc/nape/geom/Vec3.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_Arbiter
#include <hxinc/zpp_nape/dynamics/ZPP_Arbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_dynamics_ZPP_FluidArbiter
#include <hxinc/zpp_nape/dynamics/ZPP_FluidArbiter.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec3
#include <hxinc/zpp_nape/geom/ZPP_Vec3.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <hxinc/zpp_nape/shape/ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_PubPool
#include <hxinc/zpp_nape/util/ZPP_PubPool.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_01914838f75225be_316_new,"nape.dynamics.FluidArbiter","new",0x49116625,"nape.dynamics.FluidArbiter.new","nape/dynamics/FluidArbiter.hx",316,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_185_get_position,"nape.dynamics.FluidArbiter","get_position",0x08ca5e4d,"nape.dynamics.FluidArbiter.get_position","nape/dynamics/FluidArbiter.hx",185,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_192_set_position,"nape.dynamics.FluidArbiter","set_position",0x1dc381c1,"nape.dynamics.FluidArbiter.set_position","nape/dynamics/FluidArbiter.hx",192,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_214_get_overlap,"nape.dynamics.FluidArbiter","get_overlap",0xd2ab0663,"nape.dynamics.FluidArbiter.get_overlap","nape/dynamics/FluidArbiter.hx",214,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_220_set_overlap,"nape.dynamics.FluidArbiter","set_overlap",0xdd180d6f,"nape.dynamics.FluidArbiter.set_overlap","nape/dynamics/FluidArbiter.hx",220,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_246_buoyancyImpulse,"nape.dynamics.FluidArbiter","buoyancyImpulse",0x456d50ba,"nape.dynamics.FluidArbiter.buoyancyImpulse","nape/dynamics/FluidArbiter.hx",246,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_275_dragImpulse,"nape.dynamics.FluidArbiter","dragImpulse",0xc77ed5e6,"nape.dynamics.FluidArbiter.dragImpulse","nape/dynamics/FluidArbiter.hx",275,0xd522c90b)
HX_LOCAL_STACK_FRAME(_hx_pos_01914838f75225be_298_totalImpulse,"nape.dynamics.FluidArbiter","totalImpulse",0x9f71eeec,"nape.dynamics.FluidArbiter.totalImpulse","nape/dynamics/FluidArbiter.hx",298,0xd522c90b)
namespace nape{
namespace dynamics{

void FluidArbiter_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_316_new)
HXLINE( 318)		if (!(::zpp_nape::dynamics::ZPP_Arbiter_obj::internal)) {
HXLINE( 318)			HX_STACK_DO_THROW(HX_("Error: Cannot instantiate FluidArbiter derp!",06,89,0e,27));
            		}
HXLINE( 320)		super::__construct();
            	}

Dynamic FluidArbiter_obj::__CreateEmpty() { return new FluidArbiter_obj; }

void *FluidArbiter_obj::_hx_vtable = 0;

Dynamic FluidArbiter_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FluidArbiter_obj > _hx_result = new FluidArbiter_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FluidArbiter_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3d1477e9) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x3d1477e9;
	} else {
		return inClassId==(int)0x4b698aff;
	}
}

 ::nape::geom::Vec2 FluidArbiter_obj::get_position(){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_185_get_position)
HXLINE( 187)		if (!(this->zpp_inner->active)) {
HXLINE( 187)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 189)		if (hx::IsNull( this->zpp_inner->fluidarb->wrap_position )) {
HXLINE( 189)			this->zpp_inner->fluidarb->getposition();
            		}
HXLINE( 190)		return this->zpp_inner->fluidarb->wrap_position;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FluidArbiter_obj,get_position,return )

 ::nape::geom::Vec2 FluidArbiter_obj::set_position( ::nape::geom::Vec2 position){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_192_set_position)
HXLINE( 193)		{
HXLINE( 195)			if (!(this->zpp_inner->fluidarb->_hx_mutable)) {
HXLINE( 195)				HX_STACK_DO_THROW(HX_("Error: Arbiter is mutable only within a pre-handler",35,62,cf,81));
            			}
HXLINE( 198)			if (hx::IsNull( position )) {
HXLINE( 198)				HX_STACK_DO_THROW(HX_("Error: FluidArbiter::position cannot be null",b1,f2,6d,24));
            			}
HXLINE( 200)			{
HXLINE( 200)				if (!(this->zpp_inner->active)) {
HXLINE( 200)					HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            				}
HXDLIN( 200)				if (hx::IsNull( this->zpp_inner->fluidarb->wrap_position )) {
HXLINE( 200)					this->zpp_inner->fluidarb->getposition();
            				}
HXDLIN( 200)				 ::nape::geom::Vec2 _this = this->zpp_inner->fluidarb->wrap_position;
HXDLIN( 200)				bool _hx_tmp;
HXDLIN( 200)				if (hx::IsNotNull( _this )) {
HXLINE( 200)					_hx_tmp = _this->zpp_disp;
            				}
            				else {
HXLINE( 200)					_hx_tmp = false;
            				}
HXDLIN( 200)				if (_hx_tmp) {
HXLINE( 200)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 200)				bool _hx_tmp1;
HXDLIN( 200)				if (hx::IsNotNull( position )) {
HXLINE( 200)					_hx_tmp1 = position->zpp_disp;
            				}
            				else {
HXLINE( 200)					_hx_tmp1 = false;
            				}
HXDLIN( 200)				if (_hx_tmp1) {
HXLINE( 200)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 200)				{
HXLINE( 200)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 200)					if (_this1->_immutable) {
HXLINE( 200)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 200)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 200)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 200)				if (hx::IsNull( position )) {
HXLINE( 200)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 200)				bool _hx_tmp2;
HXDLIN( 200)				if (hx::IsNotNull( position )) {
HXLINE( 200)					_hx_tmp2 = position->zpp_disp;
            				}
            				else {
HXLINE( 200)					_hx_tmp2 = false;
            				}
HXDLIN( 200)				if (_hx_tmp2) {
HXLINE( 200)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 200)				{
HXLINE( 200)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = position->zpp_inner;
HXDLIN( 200)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 200)						_this2->_validate();
            					}
            				}
HXDLIN( 200)				Float x = position->zpp_inner->x;
HXDLIN( 200)				bool _hx_tmp3;
HXDLIN( 200)				if (hx::IsNotNull( position )) {
HXLINE( 200)					_hx_tmp3 = position->zpp_disp;
            				}
            				else {
HXLINE( 200)					_hx_tmp3 = false;
            				}
HXDLIN( 200)				if (_hx_tmp3) {
HXLINE( 200)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 200)				{
HXLINE( 200)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = position->zpp_inner;
HXDLIN( 200)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 200)						_this3->_validate();
            					}
            				}
HXDLIN( 200)				Float y = position->zpp_inner->y;
HXDLIN( 200)				bool _hx_tmp4;
HXDLIN( 200)				if (hx::IsNotNull( _this )) {
HXLINE( 200)					_hx_tmp4 = _this->zpp_disp;
            				}
            				else {
HXLINE( 200)					_hx_tmp4 = false;
            				}
HXDLIN( 200)				if (_hx_tmp4) {
HXLINE( 200)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 200)				{
HXLINE( 200)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 200)					if (_this4->_immutable) {
HXLINE( 200)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 200)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 200)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 200)				bool _hx_tmp5;
HXDLIN( 200)				if ((x == x)) {
HXLINE( 200)					_hx_tmp5 = (y != y);
            				}
            				else {
HXLINE( 200)					_hx_tmp5 = true;
            				}
HXDLIN( 200)				if (_hx_tmp5) {
HXLINE( 200)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 200)				bool _hx_tmp6;
HXDLIN( 200)				bool _hx_tmp7;
HXDLIN( 200)				if (hx::IsNotNull( _this )) {
HXLINE( 200)					_hx_tmp7 = _this->zpp_disp;
            				}
            				else {
HXLINE( 200)					_hx_tmp7 = false;
            				}
HXDLIN( 200)				if (_hx_tmp7) {
HXLINE( 200)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 200)				{
HXLINE( 200)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 200)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 200)						_this5->_validate();
            					}
            				}
HXDLIN( 200)				if ((_this->zpp_inner->x == x)) {
HXLINE( 200)					bool _hx_tmp8;
HXDLIN( 200)					if (hx::IsNotNull( _this )) {
HXLINE( 200)						_hx_tmp8 = _this->zpp_disp;
            					}
            					else {
HXLINE( 200)						_hx_tmp8 = false;
            					}
HXDLIN( 200)					if (_hx_tmp8) {
HXLINE( 200)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 200)					{
HXLINE( 200)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 200)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 200)							_this6->_validate();
            						}
            					}
HXDLIN( 200)					_hx_tmp6 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 200)					_hx_tmp6 = false;
            				}
HXDLIN( 200)				if (!(_hx_tmp6)) {
HXLINE( 200)					{
HXLINE( 200)						_this->zpp_inner->x = x;
HXDLIN( 200)						_this->zpp_inner->y = y;
            					}
HXDLIN( 200)					{
HXLINE( 200)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 200)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 200)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 200)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 200)				if (position->zpp_inner->weak) {
HXLINE( 200)					bool _hx_tmp9;
HXDLIN( 200)					if (hx::IsNotNull( position )) {
HXLINE( 200)						_hx_tmp9 = position->zpp_disp;
            					}
            					else {
HXLINE( 200)						_hx_tmp9 = false;
            					}
HXDLIN( 200)					if (_hx_tmp9) {
HXLINE( 200)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 200)					{
HXLINE( 200)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = position->zpp_inner;
HXDLIN( 200)						if (_this8->_immutable) {
HXLINE( 200)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 200)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 200)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 200)					if (position->zpp_inner->_inuse) {
HXLINE( 200)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 200)					 ::zpp_nape::geom::ZPP_Vec2 inner = position->zpp_inner;
HXDLIN( 200)					position->zpp_inner->outer = null();
HXDLIN( 200)					position->zpp_inner = null();
HXDLIN( 200)					{
HXLINE( 200)						 ::nape::geom::Vec2 o = position;
HXDLIN( 200)						o->zpp_pool = null();
HXDLIN( 200)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 200)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 200)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 200)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 200)						o->zpp_disp = true;
            					}
HXDLIN( 200)					{
HXLINE( 200)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 200)						{
HXLINE( 200)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 200)								o1->outer->zpp_inner = null();
HXDLIN( 200)								o1->outer = null();
            							}
HXDLIN( 200)							o1->_isimmutable = null();
HXDLIN( 200)							o1->_validate = null();
HXDLIN( 200)							o1->_invalidate = null();
            						}
HXDLIN( 200)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 200)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 202)		if (!(this->zpp_inner->active)) {
HXLINE( 202)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXDLIN( 202)		if (hx::IsNull( this->zpp_inner->fluidarb->wrap_position )) {
HXLINE( 202)			this->zpp_inner->fluidarb->getposition();
            		}
HXDLIN( 202)		return this->zpp_inner->fluidarb->wrap_position;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FluidArbiter_obj,set_position,return )

Float FluidArbiter_obj::get_overlap(){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_214_get_overlap)
HXLINE( 216)		if (!(this->zpp_inner->active)) {
HXLINE( 216)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 218)		return this->zpp_inner->fluidarb->overlap;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FluidArbiter_obj,get_overlap,return )

Float FluidArbiter_obj::set_overlap(Float overlap){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_220_set_overlap)
HXLINE( 221)		{
HXLINE( 223)			if (!(this->zpp_inner->fluidarb->_hx_mutable)) {
HXLINE( 223)				HX_STACK_DO_THROW(HX_("Error: Arbiter is mutable only within a pre-handler",35,62,cf,81));
            			}
HXLINE( 226)			if ((overlap != overlap)) {
HXLINE( 226)				HX_STACK_DO_THROW(HX_("Error: FluidArbiter::overlap cannot be NaN",55,07,76,53));
            			}
HXLINE( 229)			bool _hx_tmp;
HXDLIN( 229)			if (!((overlap <= 0))) {
HXLINE( 229)				_hx_tmp = (overlap == ::Math_obj::POSITIVE_INFINITY);
            			}
            			else {
HXLINE( 229)				_hx_tmp = true;
            			}
HXDLIN( 229)			if (_hx_tmp) {
HXLINE( 229)				HX_STACK_DO_THROW(HX_("Error: FluidArbiter::overlap must be strictly positive and non infinite",79,3e,c6,e6));
            			}
HXLINE( 231)			this->zpp_inner->fluidarb->overlap = overlap;
            		}
HXLINE( 233)		if (!(this->zpp_inner->active)) {
HXLINE( 233)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXDLIN( 233)		return this->zpp_inner->fluidarb->overlap;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FluidArbiter_obj,set_overlap,return )

 ::nape::geom::Vec3 FluidArbiter_obj::buoyancyImpulse( ::nape::phys::Body body){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_246_buoyancyImpulse)
HXLINE( 248)		if (!(this->zpp_inner->active)) {
HXLINE( 248)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 251)		bool _hx_tmp;
HXDLIN( 251)		bool _hx_tmp1;
HXDLIN( 251)		if (hx::IsNotNull( body )) {
HXLINE( 251)			if (!(this->zpp_inner->active)) {
HXLINE( 251)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 251)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 251)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 251)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 251)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 251)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 251)			_hx_tmp1 = false;
            		}
HXDLIN( 251)		if (_hx_tmp1) {
HXLINE( 251)			if (!(this->zpp_inner->active)) {
HXLINE( 251)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 251)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 251)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 251)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 251)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 251)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 251)			_hx_tmp = false;
            		}
HXDLIN( 251)		if (_hx_tmp) {
HXLINE( 251)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 253)		 ::zpp_nape::dynamics::ZPP_FluidArbiter farb = this->zpp_inner->fluidarb;
HXLINE( 254)		if (hx::IsNull( body )) {
HXLINE( 255)			return ::nape::geom::Vec3_obj::get(farb->buoyx,farb->buoyy,0);
            		}
            		else {
HXLINE( 257)			if (hx::IsEq( body->zpp_inner,this->zpp_inner->b2 )) {
HXLINE( 258)				return ::nape::geom::Vec3_obj::get(farb->buoyx,farb->buoyy,((farb->buoyy * farb->r2x) - (farb->buoyx * farb->r2y)));
            			}
            			else {
HXLINE( 261)				return ::nape::geom::Vec3_obj::get(-(farb->buoyx),-(farb->buoyy),-(((farb->buoyy * farb->r1x) - (farb->buoyx * farb->r1y))));
            			}
            		}
HXLINE( 254)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FluidArbiter_obj,buoyancyImpulse,return )

 ::nape::geom::Vec3 FluidArbiter_obj::dragImpulse( ::nape::phys::Body body){
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_275_dragImpulse)
HXLINE( 277)		if (!(this->zpp_inner->active)) {
HXLINE( 277)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 280)		bool _hx_tmp;
HXDLIN( 280)		bool _hx_tmp1;
HXDLIN( 280)		if (hx::IsNotNull( body )) {
HXLINE( 280)			if (!(this->zpp_inner->active)) {
HXLINE( 280)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 280)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 280)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 280)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 280)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 280)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 280)			_hx_tmp1 = false;
            		}
HXDLIN( 280)		if (_hx_tmp1) {
HXLINE( 280)			if (!(this->zpp_inner->active)) {
HXLINE( 280)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 280)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 280)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 280)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 280)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 280)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 280)			_hx_tmp = false;
            		}
HXDLIN( 280)		if (_hx_tmp) {
HXLINE( 280)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 282)		 ::zpp_nape::dynamics::ZPP_FluidArbiter farb = this->zpp_inner->fluidarb;
HXLINE( 283)		int scale;
HXDLIN( 283)		bool scale1;
HXDLIN( 283)		if (hx::IsNotNull( body )) {
HXLINE( 283)			scale1 = hx::IsEq( body->zpp_inner,this->zpp_inner->b2 );
            		}
            		else {
HXLINE( 283)			scale1 = true;
            		}
HXDLIN( 283)		if (scale1) {
HXLINE( 283)			scale = 1;
            		}
            		else {
HXLINE( 283)			scale = -1;
            		}
HXLINE( 284)		return ::nape::geom::Vec3_obj::get((farb->dampx * ( (Float)(scale) )),(farb->dampy * ( (Float)(scale) )),(farb->adamp * ( (Float)(scale) )));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FluidArbiter_obj,dragImpulse,return )

 ::nape::geom::Vec3 FluidArbiter_obj::totalImpulse( ::nape::phys::Body body,hx::Null< bool >  __o_freshOnly){
            		bool freshOnly = __o_freshOnly.Default(false);
            	HX_STACKFRAME(&_hx_pos_01914838f75225be_298_totalImpulse)
HXLINE( 300)		if (!(this->zpp_inner->active)) {
HXLINE( 300)			HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            		}
HXLINE( 303)		bool _hx_tmp;
HXDLIN( 303)		bool _hx_tmp1;
HXDLIN( 303)		if (hx::IsNotNull( body )) {
HXLINE( 303)			if (!(this->zpp_inner->active)) {
HXLINE( 303)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 303)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 303)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 303)				_hx_tmp2 = this->zpp_inner->b2->outer;
            			}
            			else {
HXLINE( 303)				_hx_tmp2 = this->zpp_inner->b1->outer;
            			}
HXDLIN( 303)			_hx_tmp1 = hx::IsNotEq( body,_hx_tmp2 );
            		}
            		else {
HXLINE( 303)			_hx_tmp1 = false;
            		}
HXDLIN( 303)		if (_hx_tmp1) {
HXLINE( 303)			if (!(this->zpp_inner->active)) {
HXLINE( 303)				HX_STACK_DO_THROW(HX_("Error: Arbiter not currently in use",18,2d,13,a7));
            			}
HXDLIN( 303)			 ::nape::phys::Body _hx_tmp3;
HXDLIN( 303)			if ((this->zpp_inner->ws1->id > this->zpp_inner->ws2->id)) {
HXLINE( 303)				_hx_tmp3 = this->zpp_inner->b1->outer;
            			}
            			else {
HXLINE( 303)				_hx_tmp3 = this->zpp_inner->b2->outer;
            			}
HXDLIN( 303)			_hx_tmp = hx::IsNotEq( body,_hx_tmp3 );
            		}
            		else {
HXLINE( 303)			_hx_tmp = false;
            		}
HXDLIN( 303)		if (_hx_tmp) {
HXLINE( 303)			HX_STACK_DO_THROW(HX_("Error: Arbiter does not relate to body",2f,f6,45,99));
            		}
HXLINE( 305)		 ::nape::geom::Vec3 tmp = this->buoyancyImpulse(body);
HXLINE( 306)		 ::nape::geom::Vec3 ret = this->dragImpulse(body);
HXLINE( 307)		{
HXLINE( 307)			 ::nape::geom::Vec3 _g = ret;
HXDLIN( 307)			{
HXLINE( 307)				bool x;
HXDLIN( 307)				if (hx::IsNotNull( _g )) {
HXLINE( 307)					x = _g->zpp_disp;
            				}
            				else {
HXLINE( 307)					x = false;
            				}
HXDLIN( 307)				if (x) {
HXLINE( 307)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 307)				{
HXLINE( 307)					 ::zpp_nape::geom::ZPP_Vec3 _this = _g->zpp_inner;
HXDLIN( 307)					if (hx::IsNotNull( _this->_validate )) {
HXLINE( 307)						_this->_validate();
            					}
            				}
HXDLIN( 307)				Float x1 = _g->zpp_inner->x;
HXDLIN( 307)				bool x2;
HXDLIN( 307)				if (hx::IsNotNull( tmp )) {
HXLINE( 307)					x2 = tmp->zpp_disp;
            				}
            				else {
HXLINE( 307)					x2 = false;
            				}
HXDLIN( 307)				if (x2) {
HXLINE( 307)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 307)				{
HXLINE( 307)					 ::zpp_nape::geom::ZPP_Vec3 _this1 = tmp->zpp_inner;
HXDLIN( 307)					if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 307)						_this1->_validate();
            					}
            				}
HXDLIN( 307)				{
HXLINE( 307)					bool _hx_tmp4;
HXDLIN( 307)					if (hx::IsNotNull( _g )) {
HXLINE( 307)						_hx_tmp4 = _g->zpp_disp;
            					}
            					else {
HXLINE( 307)						_hx_tmp4 = false;
            					}
HXDLIN( 307)					if (_hx_tmp4) {
HXLINE( 307)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 307)					if (_g->zpp_inner->immutable) {
HXLINE( 307)						HX_STACK_DO_THROW(HX_("Error: Vec3 is immutable",bf,41,cd,7e));
            					}
HXDLIN( 307)					_g->zpp_inner->x = (x1 + tmp->zpp_inner->x);
            				}
HXDLIN( 307)				{
HXLINE( 307)					bool _hx_tmp5;
HXDLIN( 307)					if (hx::IsNotNull( _g )) {
HXLINE( 307)						_hx_tmp5 = _g->zpp_disp;
            					}
            					else {
HXLINE( 307)						_hx_tmp5 = false;
            					}
HXDLIN( 307)					if (_hx_tmp5) {
HXLINE( 307)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 307)					{
HXLINE( 307)						 ::zpp_nape::geom::ZPP_Vec3 _this2 = _g->zpp_inner;
HXDLIN( 307)						if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 307)							_this2->_validate();
            						}
            					}
            				}
            			}
            		}
HXLINE( 308)		{
HXLINE( 308)			 ::nape::geom::Vec3 _g1 = ret;
HXDLIN( 308)			{
HXLINE( 308)				bool y;
HXDLIN( 308)				if (hx::IsNotNull( _g1 )) {
HXLINE( 308)					y = _g1->zpp_disp;
            				}
            				else {
HXLINE( 308)					y = false;
            				}
HXDLIN( 308)				if (y) {
HXLINE( 308)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 308)				{
HXLINE( 308)					 ::zpp_nape::geom::ZPP_Vec3 _this3 = _g1->zpp_inner;
HXDLIN( 308)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 308)						_this3->_validate();
            					}
            				}
HXDLIN( 308)				Float y1 = _g1->zpp_inner->y;
HXDLIN( 308)				bool y2;
HXDLIN( 308)				if (hx::IsNotNull( tmp )) {
HXLINE( 308)					y2 = tmp->zpp_disp;
            				}
            				else {
HXLINE( 308)					y2 = false;
            				}
HXDLIN( 308)				if (y2) {
HXLINE( 308)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 308)				{
HXLINE( 308)					 ::zpp_nape::geom::ZPP_Vec3 _this4 = tmp->zpp_inner;
HXDLIN( 308)					if (hx::IsNotNull( _this4->_validate )) {
HXLINE( 308)						_this4->_validate();
            					}
            				}
HXDLIN( 308)				{
HXLINE( 308)					bool _hx_tmp6;
HXDLIN( 308)					if (hx::IsNotNull( _g1 )) {
HXLINE( 308)						_hx_tmp6 = _g1->zpp_disp;
            					}
            					else {
HXLINE( 308)						_hx_tmp6 = false;
            					}
HXDLIN( 308)					if (_hx_tmp6) {
HXLINE( 308)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 308)					if (_g1->zpp_inner->immutable) {
HXLINE( 308)						HX_STACK_DO_THROW(HX_("Error: Vec3 is immutable",bf,41,cd,7e));
            					}
HXDLIN( 308)					_g1->zpp_inner->y = (y1 + tmp->zpp_inner->y);
            				}
HXDLIN( 308)				{
HXLINE( 308)					bool _hx_tmp7;
HXDLIN( 308)					if (hx::IsNotNull( _g1 )) {
HXLINE( 308)						_hx_tmp7 = _g1->zpp_disp;
            					}
            					else {
HXLINE( 308)						_hx_tmp7 = false;
            					}
HXDLIN( 308)					if (_hx_tmp7) {
HXLINE( 308)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 308)					{
HXLINE( 308)						 ::zpp_nape::geom::ZPP_Vec3 _this5 = _g1->zpp_inner;
HXDLIN( 308)						if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 308)							_this5->_validate();
            						}
            					}
            				}
            			}
            		}
HXLINE( 309)		{
HXLINE( 309)			 ::nape::geom::Vec3 _g2 = ret;
HXDLIN( 309)			{
HXLINE( 309)				bool z;
HXDLIN( 309)				if (hx::IsNotNull( _g2 )) {
HXLINE( 309)					z = _g2->zpp_disp;
            				}
            				else {
HXLINE( 309)					z = false;
            				}
HXDLIN( 309)				if (z) {
HXLINE( 309)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 309)				{
HXLINE( 309)					 ::zpp_nape::geom::ZPP_Vec3 _this6 = _g2->zpp_inner;
HXDLIN( 309)					if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 309)						_this6->_validate();
            					}
            				}
HXDLIN( 309)				Float z1 = _g2->zpp_inner->z;
HXDLIN( 309)				bool z2;
HXDLIN( 309)				if (hx::IsNotNull( tmp )) {
HXLINE( 309)					z2 = tmp->zpp_disp;
            				}
            				else {
HXLINE( 309)					z2 = false;
            				}
HXDLIN( 309)				if (z2) {
HXLINE( 309)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 309)				{
HXLINE( 309)					 ::zpp_nape::geom::ZPP_Vec3 _this7 = tmp->zpp_inner;
HXDLIN( 309)					if (hx::IsNotNull( _this7->_validate )) {
HXLINE( 309)						_this7->_validate();
            					}
            				}
HXDLIN( 309)				{
HXLINE( 309)					bool _hx_tmp8;
HXDLIN( 309)					if (hx::IsNotNull( _g2 )) {
HXLINE( 309)						_hx_tmp8 = _g2->zpp_disp;
            					}
            					else {
HXLINE( 309)						_hx_tmp8 = false;
            					}
HXDLIN( 309)					if (_hx_tmp8) {
HXLINE( 309)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 309)					if (_g2->zpp_inner->immutable) {
HXLINE( 309)						HX_STACK_DO_THROW(HX_("Error: Vec3 is immutable",bf,41,cd,7e));
            					}
HXDLIN( 309)					_g2->zpp_inner->z = (z1 + tmp->zpp_inner->z);
            				}
HXDLIN( 309)				{
HXLINE( 309)					bool _hx_tmp9;
HXDLIN( 309)					if (hx::IsNotNull( _g2 )) {
HXLINE( 309)						_hx_tmp9 = _g2->zpp_disp;
            					}
            					else {
HXLINE( 309)						_hx_tmp9 = false;
            					}
HXDLIN( 309)					if (_hx_tmp9) {
HXLINE( 309)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec3",7f,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 309)					{
HXLINE( 309)						 ::zpp_nape::geom::ZPP_Vec3 _this8 = _g2->zpp_inner;
HXDLIN( 309)						if (hx::IsNotNull( _this8->_validate )) {
HXLINE( 309)							_this8->_validate();
            						}
            					}
            				}
            			}
            		}
HXLINE( 310)		tmp->dispose();
HXLINE( 311)		return ret;
            	}



hx::ObjectPtr< FluidArbiter_obj > FluidArbiter_obj::__new() {
	hx::ObjectPtr< FluidArbiter_obj > __this = new FluidArbiter_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< FluidArbiter_obj > FluidArbiter_obj::__alloc(hx::Ctx *_hx_ctx) {
	FluidArbiter_obj *__this = (FluidArbiter_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FluidArbiter_obj), true, "nape.dynamics.FluidArbiter"));
	*(void **)__this = FluidArbiter_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FluidArbiter_obj::FluidArbiter_obj()
{
}

hx::Val FluidArbiter_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"overlap") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_overlap() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_position() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"get_overlap") ) { return hx::Val( get_overlap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_overlap") ) { return hx::Val( set_overlap_dyn() ); }
		if (HX_FIELD_EQ(inName,"dragImpulse") ) { return hx::Val( dragImpulse_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_position") ) { return hx::Val( get_position_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_position") ) { return hx::Val( set_position_dyn() ); }
		if (HX_FIELD_EQ(inName,"totalImpulse") ) { return hx::Val( totalImpulse_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"buoyancyImpulse") ) { return hx::Val( buoyancyImpulse_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FluidArbiter_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"overlap") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_overlap(inValue.Cast< Float >()) ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"position") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_position(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FluidArbiter_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("position",a9,a0,fa,ca));
	outFields->push(HX_("overlap",87,43,10,a9));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *FluidArbiter_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *FluidArbiter_obj_sStaticStorageInfo = 0;
#endif

static ::String FluidArbiter_obj_sMemberFields[] = {
	HX_("get_position",b2,54,14,80),
	HX_("set_position",26,78,0d,95),
	HX_("get_overlap",9e,a3,0a,2f),
	HX_("set_overlap",aa,aa,77,39),
	HX_("buoyancyImpulse",75,a7,03,9f),
	HX_("dragImpulse",21,73,de,23),
	HX_("totalImpulse",51,e5,bb,16),
	::String(null()) };

hx::Class FluidArbiter_obj::__mClass;

void FluidArbiter_obj::__register()
{
	FluidArbiter_obj _hx_dummy;
	FluidArbiter_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.dynamics.FluidArbiter",b3,6f,38,a3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FluidArbiter_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FluidArbiter_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FluidArbiter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FluidArbiter_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace dynamics
