// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_Config
#include <hxinc/nape/Config.h>
#endif
#ifndef INCLUDED_nape_geom_Geom
#include <hxinc/nape/geom/Geom.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <hxinc/nape/shape/Shape.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeList
#include <hxinc/nape/shape/ShapeList.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_AABB
#include <hxinc/zpp_nape/geom/ZPP_AABB.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Collide
#include <hxinc/zpp_nape/geom/ZPP_Collide.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Geom
#include <hxinc/zpp_nape/geom/ZPP_Geom.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_SweepDistance
#include <hxinc/zpp_nape/geom/ZPP_SweepDistance.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Circle
#include <hxinc/zpp_nape/shape/ZPP_Circle.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Edge
#include <hxinc/zpp_nape/shape/ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Polygon
#include <hxinc/zpp_nape/shape/ZPP_Polygon.h>
#endif
#ifndef INCLUDED_zpp_nape_shape_ZPP_Shape
#include <hxinc/zpp_nape/shape/ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Edge
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPList_ZPP_Shape
#include <hxinc/zpp_nape/util/ZNPList_ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Edge
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Edge.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZNPNode_ZPP_Shape
#include <hxinc/zpp_nape/util/ZNPNode_ZPP_Shape.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ShapeList
#include <hxinc/zpp_nape/util/ZPP_ShapeList.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_ea88d4a00c1343cf_223_distanceBody,"nape.geom.Geom","distanceBody",0x7c10c5dd,"nape.geom.Geom.distanceBody","nape/geom/Geom.hx",223,0xa217fc96)
HX_LOCAL_STACK_FRAME(_hx_pos_ea88d4a00c1343cf_301_distance,"nape.geom.Geom","distance",0x3581b59b,"nape.geom.Geom.distance","nape/geom/Geom.hx",301,0xa217fc96)
HX_LOCAL_STACK_FRAME(_hx_pos_ea88d4a00c1343cf_370_intersectsBody,"nape.geom.Geom","intersectsBody",0x4ce4c65c,"nape.geom.Geom.intersectsBody","nape/geom/Geom.hx",370,0xa217fc96)
HX_LOCAL_STACK_FRAME(_hx_pos_ea88d4a00c1343cf_435_intersects,"nape.geom.Geom","intersects",0x398dca9a,"nape.geom.Geom.intersects","nape/geom/Geom.hx",435,0xa217fc96)
HX_LOCAL_STACK_FRAME(_hx_pos_ea88d4a00c1343cf_456_contains,"nape.geom.Geom","contains",0xf6037c85,"nape.geom.Geom.contains","nape/geom/Geom.hx",456,0xa217fc96)
namespace nape{
namespace geom{

void Geom_obj::__construct() { }

Dynamic Geom_obj::__CreateEmpty() { return new Geom_obj; }

void *Geom_obj::_hx_vtable = 0;

Dynamic Geom_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Geom_obj > _hx_result = new Geom_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Geom_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x262fde2c;
}

Float Geom_obj::distanceBody( ::nape::phys::Body body1, ::nape::phys::Body body2, ::nape::geom::Vec2 out1, ::nape::geom::Vec2 out2){
            	HX_STACKFRAME(&_hx_pos_ea88d4a00c1343cf_223_distanceBody)
HXLINE( 226)		bool _hx_tmp;
HXDLIN( 226)		if (hx::IsNotNull( out1 )) {
HXLINE( 226)			_hx_tmp = out1->zpp_disp;
            		}
            		else {
HXLINE( 226)			_hx_tmp = false;
            		}
HXDLIN( 226)		if (_hx_tmp) {
HXLINE( 226)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 231)		bool _hx_tmp1;
HXDLIN( 231)		if (hx::IsNotNull( out2 )) {
HXLINE( 231)			_hx_tmp1 = out2->zpp_disp;
            		}
            		else {
HXLINE( 231)			_hx_tmp1 = false;
            		}
HXDLIN( 231)		if (_hx_tmp1) {
HXLINE( 231)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 234)		{
HXLINE( 234)			 ::zpp_nape::geom::ZPP_Vec2 _this = out1->zpp_inner;
HXDLIN( 234)			if (_this->_immutable) {
HXLINE( 234)				HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            			}
HXDLIN( 234)			if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 234)				_this->_isimmutable();
            			}
            		}
HXLINE( 235)		{
HXLINE( 235)			 ::zpp_nape::geom::ZPP_Vec2 _this1 = out2->zpp_inner;
HXDLIN( 235)			if (_this1->_immutable) {
HXLINE( 235)				HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            			}
HXDLIN( 235)			if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 235)				_this1->_isimmutable();
            			}
            		}
HXLINE( 237)		bool _hx_tmp2;
HXDLIN( 237)		 ::nape::shape::ShapeList _this2 = body1->zpp_inner->wrap_shapes;
HXDLIN( 237)		if (hx::IsNotNull( _this2->zpp_inner->inner->head )) {
HXLINE( 237)			 ::nape::shape::ShapeList _this3 = body2->zpp_inner->wrap_shapes;
HXDLIN( 237)			_hx_tmp2 = hx::IsNull( _this3->zpp_inner->inner->head );
            		}
            		else {
HXLINE( 237)			_hx_tmp2 = true;
            		}
HXDLIN( 237)		if (_hx_tmp2) {
HXLINE( 237)			HX_STACK_DO_THROW(HX_("Error: Bodies cannot be empty in calculating distances",2b,04,64,cf));
            		}
HXLINE( 239)		{
HXLINE( 240)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = body1->zpp_inner->shapes->head;
HXLINE( 241)			while(hx::IsNotNull( cx_ite )){
HXLINE( 242)				 ::zpp_nape::shape::ZPP_Shape i = cx_ite->elt;
HXLINE( 243)				::zpp_nape::geom::ZPP_Geom_obj::validateShape(i);
HXLINE( 244)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE( 247)		{
HXLINE( 248)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite1 = body2->zpp_inner->shapes->head;
HXLINE( 249)			while(hx::IsNotNull( cx_ite1 )){
HXLINE( 250)				 ::zpp_nape::shape::ZPP_Shape i1 = cx_ite1->elt;
HXLINE( 251)				::zpp_nape::geom::ZPP_Geom_obj::validateShape(i1);
HXLINE( 252)				cx_ite1 = cx_ite1->next;
            			}
            		}
HXLINE( 255)		return ::zpp_nape::geom::ZPP_SweepDistance_obj::distanceBody(body1->zpp_inner,body2->zpp_inner,out1->zpp_inner,out2->zpp_inner);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Geom_obj,distanceBody,return )

Float Geom_obj::distance( ::nape::shape::Shape shape1, ::nape::shape::Shape shape2, ::nape::geom::Vec2 out1, ::nape::geom::Vec2 out2){
            	HX_GC_STACKFRAME(&_hx_pos_ea88d4a00c1343cf_301_distance)
HXLINE( 304)		bool _hx_tmp;
HXDLIN( 304)		if (hx::IsNotNull( out1 )) {
HXLINE( 304)			_hx_tmp = out1->zpp_disp;
            		}
            		else {
HXLINE( 304)			_hx_tmp = false;
            		}
HXDLIN( 304)		if (_hx_tmp) {
HXLINE( 304)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 309)		bool _hx_tmp1;
HXDLIN( 309)		if (hx::IsNotNull( out2 )) {
HXLINE( 309)			_hx_tmp1 = out2->zpp_disp;
            		}
            		else {
HXLINE( 309)			_hx_tmp1 = false;
            		}
HXDLIN( 309)		if (_hx_tmp1) {
HXLINE( 309)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 312)		{
HXLINE( 312)			 ::zpp_nape::geom::ZPP_Vec2 _this = out1->zpp_inner;
HXDLIN( 312)			if (_this->_immutable) {
HXLINE( 312)				HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            			}
HXDLIN( 312)			if (hx::IsNotNull( _this->_isimmutable )) {
HXLINE( 312)				_this->_isimmutable();
            			}
            		}
HXLINE( 313)		{
HXLINE( 313)			 ::zpp_nape::geom::ZPP_Vec2 _this1 = out2->zpp_inner;
HXDLIN( 313)			if (_this1->_immutable) {
HXLINE( 313)				HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            			}
HXDLIN( 313)			if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 313)				_this1->_isimmutable();
            			}
            		}
HXLINE( 315)		bool _hx_tmp2;
HXDLIN( 315)		 ::nape::phys::Body _hx_tmp3;
HXDLIN( 315)		if (hx::IsNotNull( shape1->zpp_inner->body )) {
HXLINE( 315)			_hx_tmp3 = shape1->zpp_inner->body->outer;
            		}
            		else {
HXLINE( 315)			_hx_tmp3 = null();
            		}
HXDLIN( 315)		if (hx::IsNotNull( _hx_tmp3 )) {
HXLINE( 315)			 ::nape::phys::Body _hx_tmp4;
HXDLIN( 315)			if (hx::IsNotNull( shape2->zpp_inner->body )) {
HXLINE( 315)				_hx_tmp4 = shape2->zpp_inner->body->outer;
            			}
            			else {
HXLINE( 315)				_hx_tmp4 = null();
            			}
HXDLIN( 315)			_hx_tmp2 = hx::IsNull( _hx_tmp4 );
            		}
            		else {
HXLINE( 315)			_hx_tmp2 = true;
            		}
HXDLIN( 315)		if (_hx_tmp2) {
HXLINE( 315)			HX_STACK_DO_THROW(HX_("Error: Shape must be part of a Body to calculate distances",8f,3a,06,f1));
            		}
HXLINE( 317)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(shape1->zpp_inner);
HXLINE( 318)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(shape2->zpp_inner);
HXLINE( 319)		 ::zpp_nape::geom::ZPP_Vec2 tmp;
HXLINE( 320)		{
HXLINE( 321)			if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE( 322)				tmp =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 328)				tmp = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXLINE( 329)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = tmp->next;
HXLINE( 330)				tmp->next = null();
            			}
HXLINE( 335)			tmp->weak = false;
            		}
HXLINE( 337)		 ::zpp_nape::shape::ZPP_Shape s1 = shape1->zpp_inner;
HXDLIN( 337)		 ::zpp_nape::shape::ZPP_Shape s2 = shape2->zpp_inner;
HXDLIN( 337)		 ::zpp_nape::geom::ZPP_Vec2 w1 = out1->zpp_inner;
HXDLIN( 337)		 ::zpp_nape::geom::ZPP_Vec2 w2 = out2->zpp_inner;
HXDLIN( 337)		Float ret;
HXDLIN( 337)		bool ret1;
HXDLIN( 337)		if ((s1->type == 0)) {
HXLINE( 337)			ret1 = (s2->type == 0);
            		}
            		else {
HXLINE( 337)			ret1 = false;
            		}
HXDLIN( 337)		if (ret1) {
HXLINE( 337)			 ::zpp_nape::shape::ZPP_Circle c1 = s1->circle;
HXDLIN( 337)			 ::zpp_nape::shape::ZPP_Circle c2 = s2->circle;
HXDLIN( 337)			Float dist;
HXDLIN( 337)			{
HXLINE( 337)				Float nx = ((Float)0.0);
HXDLIN( 337)				Float ny = ((Float)0.0);
HXDLIN( 337)				{
HXLINE( 337)					nx = (c2->worldCOMx - c1->worldCOMx);
HXDLIN( 337)					ny = (c2->worldCOMy - c1->worldCOMy);
            				}
HXDLIN( 337)				Float len = ::Math_obj::sqrt(((nx * nx) + (ny * ny)));
HXDLIN( 337)				dist = (len - (c1->radius + c2->radius));
HXDLIN( 337)				if ((dist < ((Float)1e100))) {
HXLINE( 337)					if ((len == 0)) {
HXLINE( 337)						nx = ( (Float)(1) );
HXDLIN( 337)						ny = ( (Float)(0) );
            					}
            					else {
HXLINE( 337)						Float t = (((Float)1.0) / len);
HXDLIN( 337)						nx = (nx * t);
HXDLIN( 337)						ny = (ny * t);
            					}
HXDLIN( 337)					{
HXLINE( 337)						Float t1 = c1->radius;
HXDLIN( 337)						w1->x = (c1->worldCOMx + (nx * t1));
HXDLIN( 337)						w1->y = (c1->worldCOMy + (ny * t1));
            					}
HXDLIN( 337)					{
HXLINE( 337)						Float t2 = -(c2->radius);
HXDLIN( 337)						w2->x = (c2->worldCOMx + (nx * t2));
HXDLIN( 337)						w2->y = (c2->worldCOMy + (ny * t2));
            					}
HXDLIN( 337)					{
HXLINE( 337)						tmp->x = nx;
HXDLIN( 337)						tmp->y = ny;
            					}
            				}
            			}
HXDLIN( 337)			ret = dist;
            		}
            		else {
HXLINE( 337)			bool swapped = false;
HXDLIN( 337)			bool ret2;
HXDLIN( 337)			if ((s1->type == 0)) {
HXLINE( 337)				ret2 = (s2->type == 1);
            			}
            			else {
HXLINE( 337)				ret2 = false;
            			}
HXDLIN( 337)			if (ret2) {
HXLINE( 337)				 ::zpp_nape::shape::ZPP_Shape tmp1 = s1;
HXDLIN( 337)				s1 = s2;
HXDLIN( 337)				s2 = tmp1;
HXDLIN( 337)				 ::zpp_nape::geom::ZPP_Vec2 tmp2 = w1;
HXDLIN( 337)				w1 = w2;
HXDLIN( 337)				w2 = tmp2;
HXDLIN( 337)				swapped = true;
            			}
HXDLIN( 337)			bool ret3;
HXDLIN( 337)			if ((s1->type == 1)) {
HXLINE( 337)				ret3 = (s2->type == 0);
            			}
            			else {
HXLINE( 337)				ret3 = false;
            			}
HXDLIN( 337)			if (ret3) {
HXLINE( 337)				 ::zpp_nape::shape::ZPP_Polygon poly = s1->polygon;
HXDLIN( 337)				 ::zpp_nape::shape::ZPP_Circle circle = s2->circle;
HXDLIN( 337)				Float best = ((Float)-1e+100);
HXDLIN( 337)				 ::zpp_nape::shape::ZPP_Edge a0 = null();
HXDLIN( 337)				{
HXLINE( 337)					 ::zpp_nape::util::ZNPNode_ZPP_Edge cx_ite = poly->edges->head;
HXDLIN( 337)					while(hx::IsNotNull( cx_ite )){
HXLINE( 337)						 ::zpp_nape::shape::ZPP_Edge a = cx_ite->elt;
HXDLIN( 337)						{
HXLINE( 337)							Float dist1 = ((((a->gnormx * circle->worldCOMx) + (a->gnormy * circle->worldCOMy)) - a->gprojection) - circle->radius);
HXDLIN( 337)							if ((dist1 > ((Float)1e100))) {
HXLINE( 337)								best = dist1;
HXDLIN( 337)								goto _hx_goto_3;
            							}
HXDLIN( 337)							if ((dist1 > 0)) {
HXLINE( 337)								if ((dist1 > best)) {
HXLINE( 337)									best = dist1;
HXDLIN( 337)									a0 = a;
            								}
            							}
            							else {
HXLINE( 337)								bool ret4;
HXDLIN( 337)								if ((best < 0)) {
HXLINE( 337)									ret4 = (dist1 > best);
            								}
            								else {
HXLINE( 337)									ret4 = false;
            								}
HXDLIN( 337)								if (ret4) {
HXLINE( 337)									best = dist1;
HXDLIN( 337)									a0 = a;
            								}
            							}
            						}
HXDLIN( 337)						cx_ite = cx_ite->next;
            					}
            					_hx_goto_3:;
            				}
HXDLIN( 337)				if ((best < ((Float)1e100))) {
HXLINE( 337)					 ::zpp_nape::geom::ZPP_Vec2 v0 = a0->gp0;
HXDLIN( 337)					 ::zpp_nape::geom::ZPP_Vec2 v1 = a0->gp1;
HXDLIN( 337)					Float dt = ((circle->worldCOMy * a0->gnormx) - (circle->worldCOMx * a0->gnormy));
HXDLIN( 337)					if ((dt <= ((v0->y * a0->gnormx) - (v0->x * a0->gnormy)))) {
HXLINE( 337)						Float nx1 = ((Float)0.0);
HXDLIN( 337)						Float ny1 = ((Float)0.0);
HXDLIN( 337)						{
HXLINE( 337)							nx1 = (circle->worldCOMx - v0->x);
HXDLIN( 337)							ny1 = (circle->worldCOMy - v0->y);
            						}
HXDLIN( 337)						Float len1 = ::Math_obj::sqrt(((nx1 * nx1) + (ny1 * ny1)));
HXDLIN( 337)						best = (len1 - circle->radius);
HXDLIN( 337)						if ((best < ((Float)1e100))) {
HXLINE( 337)							if ((len1 == 0)) {
HXLINE( 337)								nx1 = ( (Float)(1) );
HXDLIN( 337)								ny1 = ( (Float)(0) );
            							}
            							else {
HXLINE( 337)								Float t3 = (((Float)1.0) / len1);
HXDLIN( 337)								nx1 = (nx1 * t3);
HXDLIN( 337)								ny1 = (ny1 * t3);
            							}
HXDLIN( 337)							{
HXLINE( 337)								int t4 = 0;
HXDLIN( 337)								w1->x = (v0->x + (nx1 * ( (Float)(t4) )));
HXDLIN( 337)								w1->y = (v0->y + (ny1 * ( (Float)(t4) )));
            							}
HXDLIN( 337)							{
HXLINE( 337)								Float t5 = -(circle->radius);
HXDLIN( 337)								w2->x = (circle->worldCOMx + (nx1 * t5));
HXDLIN( 337)								w2->y = (circle->worldCOMy + (ny1 * t5));
            							}
HXDLIN( 337)							{
HXLINE( 337)								tmp->x = nx1;
HXDLIN( 337)								tmp->y = ny1;
            							}
            						}
            					}
            					else {
HXLINE( 337)						if ((dt >= ((v1->y * a0->gnormx) - (v1->x * a0->gnormy)))) {
HXLINE( 337)							Float nx2 = ((Float)0.0);
HXDLIN( 337)							Float ny2 = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								nx2 = (circle->worldCOMx - v1->x);
HXDLIN( 337)								ny2 = (circle->worldCOMy - v1->y);
            							}
HXDLIN( 337)							Float len2 = ::Math_obj::sqrt(((nx2 * nx2) + (ny2 * ny2)));
HXDLIN( 337)							best = (len2 - circle->radius);
HXDLIN( 337)							if ((best < ((Float)1e100))) {
HXLINE( 337)								if ((len2 == 0)) {
HXLINE( 337)									nx2 = ( (Float)(1) );
HXDLIN( 337)									ny2 = ( (Float)(0) );
            								}
            								else {
HXLINE( 337)									Float t6 = (((Float)1.0) / len2);
HXDLIN( 337)									nx2 = (nx2 * t6);
HXDLIN( 337)									ny2 = (ny2 * t6);
            								}
HXDLIN( 337)								{
HXLINE( 337)									int t7 = 0;
HXDLIN( 337)									w1->x = (v1->x + (nx2 * ( (Float)(t7) )));
HXDLIN( 337)									w1->y = (v1->y + (ny2 * ( (Float)(t7) )));
            								}
HXDLIN( 337)								{
HXLINE( 337)									Float t8 = -(circle->radius);
HXDLIN( 337)									w2->x = (circle->worldCOMx + (nx2 * t8));
HXDLIN( 337)									w2->y = (circle->worldCOMy + (ny2 * t8));
            								}
HXDLIN( 337)								{
HXLINE( 337)									tmp->x = nx2;
HXDLIN( 337)									tmp->y = ny2;
            								}
            							}
            						}
            						else {
HXLINE( 337)							{
HXLINE( 337)								Float t9 = -(circle->radius);
HXDLIN( 337)								w2->x = (circle->worldCOMx + (a0->gnormx * t9));
HXDLIN( 337)								w2->y = (circle->worldCOMy + (a0->gnormy * t9));
            							}
HXDLIN( 337)							{
HXLINE( 337)								Float t10 = -(best);
HXDLIN( 337)								w1->x = (w2->x + (a0->gnormx * t10));
HXDLIN( 337)								w1->y = (w2->y + (a0->gnormy * t10));
            							}
HXDLIN( 337)							{
HXLINE( 337)								tmp->x = a0->gnormx;
HXDLIN( 337)								tmp->y = a0->gnormy;
            							}
            						}
            					}
            				}
HXDLIN( 337)				if (swapped) {
HXLINE( 337)					tmp->x = -(tmp->x);
HXDLIN( 337)					tmp->y = -(tmp->y);
            				}
HXDLIN( 337)				ret = best;
            			}
            			else {
HXLINE( 337)				 ::zpp_nape::shape::ZPP_Polygon p1 = s1->polygon;
HXDLIN( 337)				 ::zpp_nape::shape::ZPP_Polygon p2 = s2->polygon;
HXDLIN( 337)				Float best1 = ((Float)-1e+100);
HXDLIN( 337)				 ::zpp_nape::shape::ZPP_Edge a1 = null();
HXDLIN( 337)				 ::zpp_nape::shape::ZPP_Edge a2 = null();
HXDLIN( 337)				int besti = 0;
HXDLIN( 337)				{
HXLINE( 337)					 ::zpp_nape::util::ZNPNode_ZPP_Edge cx_ite1 = p1->edges->head;
HXDLIN( 337)					while(hx::IsNotNull( cx_ite1 )){
HXLINE( 337)						 ::zpp_nape::shape::ZPP_Edge a3 = cx_ite1->elt;
HXDLIN( 337)						{
HXLINE( 337)							Float min = ((Float)1e100);
HXDLIN( 337)							{
HXLINE( 337)								 ::zpp_nape::geom::ZPP_Vec2 cx_ite2 = p2->gverts->next;
HXDLIN( 337)								while(hx::IsNotNull( cx_ite2 )){
HXLINE( 337)									 ::zpp_nape::geom::ZPP_Vec2 v = cx_ite2;
HXDLIN( 337)									{
HXLINE( 337)										Float k = ((a3->gnormx * v->x) + (a3->gnormy * v->y));
HXDLIN( 337)										if ((k < min)) {
HXLINE( 337)											min = k;
            										}
            									}
HXDLIN( 337)									cx_ite2 = cx_ite2->next;
            								}
            							}
HXDLIN( 337)							min = (min - a3->gprojection);
HXDLIN( 337)							if ((min > ((Float)1e100))) {
HXLINE( 337)								best1 = min;
HXDLIN( 337)								goto _hx_goto_4;
            							}
HXDLIN( 337)							if ((min > 0)) {
HXLINE( 337)								if ((min > best1)) {
HXLINE( 337)									best1 = min;
HXDLIN( 337)									a1 = a3;
HXDLIN( 337)									besti = 1;
            								}
            							}
            							else {
HXLINE( 337)								bool ret5;
HXDLIN( 337)								if ((best1 < 0)) {
HXLINE( 337)									ret5 = (min > best1);
            								}
            								else {
HXLINE( 337)									ret5 = false;
            								}
HXDLIN( 337)								if (ret5) {
HXLINE( 337)									best1 = min;
HXDLIN( 337)									a1 = a3;
HXDLIN( 337)									besti = 1;
            								}
            							}
            						}
HXDLIN( 337)						cx_ite1 = cx_ite1->next;
            					}
            					_hx_goto_4:;
            				}
HXDLIN( 337)				if ((best1 < ((Float)1e100))) {
HXLINE( 337)					{
HXLINE( 337)						 ::zpp_nape::util::ZNPNode_ZPP_Edge cx_ite3 = p2->edges->head;
HXDLIN( 337)						while(hx::IsNotNull( cx_ite3 )){
HXLINE( 337)							 ::zpp_nape::shape::ZPP_Edge a4 = cx_ite3->elt;
HXDLIN( 337)							{
HXLINE( 337)								Float min1 = ((Float)1e100);
HXDLIN( 337)								{
HXLINE( 337)									 ::zpp_nape::geom::ZPP_Vec2 cx_ite4 = p1->gverts->next;
HXDLIN( 337)									while(hx::IsNotNull( cx_ite4 )){
HXLINE( 337)										 ::zpp_nape::geom::ZPP_Vec2 v2 = cx_ite4;
HXDLIN( 337)										{
HXLINE( 337)											Float k1 = ((a4->gnormx * v2->x) + (a4->gnormy * v2->y));
HXDLIN( 337)											if ((k1 < min1)) {
HXLINE( 337)												min1 = k1;
            											}
            										}
HXDLIN( 337)										cx_ite4 = cx_ite4->next;
            									}
            								}
HXDLIN( 337)								min1 = (min1 - a4->gprojection);
HXDLIN( 337)								if ((min1 > ((Float)1e100))) {
HXLINE( 337)									best1 = min1;
HXDLIN( 337)									goto _hx_goto_6;
            								}
HXDLIN( 337)								if ((min1 > 0)) {
HXLINE( 337)									if ((min1 > best1)) {
HXLINE( 337)										best1 = min1;
HXDLIN( 337)										a2 = a4;
HXDLIN( 337)										besti = 2;
            									}
            								}
            								else {
HXLINE( 337)									bool ret6;
HXDLIN( 337)									if ((best1 < 0)) {
HXLINE( 337)										ret6 = (min1 > best1);
            									}
            									else {
HXLINE( 337)										ret6 = false;
            									}
HXDLIN( 337)									if (ret6) {
HXLINE( 337)										best1 = min1;
HXDLIN( 337)										a2 = a4;
HXDLIN( 337)										besti = 2;
            									}
            								}
            							}
HXDLIN( 337)							cx_ite3 = cx_ite3->next;
            						}
            						_hx_goto_6:;
            					}
HXDLIN( 337)					if ((best1 < ((Float)1e100))) {
HXLINE( 337)						 ::zpp_nape::shape::ZPP_Polygon q1;
HXDLIN( 337)						 ::zpp_nape::shape::ZPP_Polygon q2;
HXDLIN( 337)						 ::zpp_nape::shape::ZPP_Edge ax;
HXDLIN( 337)						if ((besti == 1)) {
HXLINE( 337)							q1 = p1;
HXDLIN( 337)							q2 = p2;
HXDLIN( 337)							ax = a1;
            						}
            						else {
HXLINE( 337)							q1 = p2;
HXDLIN( 337)							q2 = p1;
HXDLIN( 337)							ax = a2;
HXDLIN( 337)							 ::zpp_nape::geom::ZPP_Vec2 tmp3 = w1;
HXDLIN( 337)							w1 = w2;
HXDLIN( 337)							w2 = tmp3;
HXDLIN( 337)							swapped = !(swapped);
            						}
HXDLIN( 337)						 ::zpp_nape::shape::ZPP_Edge ay = null();
HXDLIN( 337)						Float min2 = ((Float)1e100);
HXDLIN( 337)						{
HXLINE( 337)							 ::zpp_nape::util::ZNPNode_ZPP_Edge cx_ite5 = q2->edges->head;
HXDLIN( 337)							while(hx::IsNotNull( cx_ite5 )){
HXLINE( 337)								 ::zpp_nape::shape::ZPP_Edge a5 = cx_ite5->elt;
HXDLIN( 337)								{
HXLINE( 337)									Float k2 = ((ax->gnormx * a5->gnormx) + (ax->gnormy * a5->gnormy));
HXDLIN( 337)									if ((k2 < min2)) {
HXLINE( 337)										min2 = k2;
HXDLIN( 337)										ay = a5;
            									}
            								}
HXDLIN( 337)								cx_ite5 = cx_ite5->next;
            							}
            						}
HXDLIN( 337)						if (swapped) {
HXLINE( 337)							tmp->x = -(ax->gnormx);
HXDLIN( 337)							tmp->y = -(ax->gnormy);
            						}
            						else {
HXLINE( 337)							tmp->x = ax->gnormx;
HXDLIN( 337)							tmp->y = ax->gnormy;
            						}
HXDLIN( 337)						if ((best1 >= 0)) {
HXLINE( 337)							 ::zpp_nape::geom::ZPP_Vec2 v01 = ax->gp0;
HXDLIN( 337)							 ::zpp_nape::geom::ZPP_Vec2 v11 = ax->gp1;
HXDLIN( 337)							 ::zpp_nape::geom::ZPP_Vec2 q0 = ay->gp0;
HXDLIN( 337)							 ::zpp_nape::geom::ZPP_Vec2 q11 = ay->gp1;
HXDLIN( 337)							Float vx = ((Float)0.0);
HXDLIN( 337)							Float vy = ((Float)0.0);
HXDLIN( 337)							Float qx = ((Float)0.0);
HXDLIN( 337)							Float qy = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								vx = (v11->x - v01->x);
HXDLIN( 337)								vy = (v11->y - v01->y);
            							}
HXDLIN( 337)							{
HXLINE( 337)								qx = (q11->x - q0->x);
HXDLIN( 337)								qy = (q11->y - q0->y);
            							}
HXDLIN( 337)							Float vdot = (( (Float)(1) ) / ((vx * vx) + (vy * vy)));
HXDLIN( 337)							Float qdot = (( (Float)(1) ) / ((qx * qx) + (qy * qy)));
HXDLIN( 337)							Float t11 = (-(((vx * (v01->x - q0->x)) + (vy * (v01->y - q0->y)))) * vdot);
HXDLIN( 337)							Float t21 = (-(((vx * (v01->x - q11->x)) + (vy * (v01->y - q11->y)))) * vdot);
HXDLIN( 337)							Float s11 = (-(((qx * (q0->x - v01->x)) + (qy * (q0->y - v01->y)))) * qdot);
HXDLIN( 337)							Float s21 = (-(((qx * (q0->x - v11->x)) + (qy * (q0->y - v11->y)))) * qdot);
HXDLIN( 337)							if ((t11 < 0)) {
HXLINE( 337)								t11 = ( (Float)(0) );
            							}
            							else {
HXLINE( 337)								if ((t11 > 1)) {
HXLINE( 337)									t11 = ( (Float)(1) );
            								}
            							}
HXDLIN( 337)							if ((t21 < 0)) {
HXLINE( 337)								t21 = ( (Float)(0) );
            							}
            							else {
HXLINE( 337)								if ((t21 > 1)) {
HXLINE( 337)									t21 = ( (Float)(1) );
            								}
            							}
HXDLIN( 337)							if ((s11 < 0)) {
HXLINE( 337)								s11 = ( (Float)(0) );
            							}
            							else {
HXLINE( 337)								if ((s11 > 1)) {
HXLINE( 337)									s11 = ( (Float)(1) );
            								}
            							}
HXDLIN( 337)							if ((s21 < 0)) {
HXLINE( 337)								s21 = ( (Float)(0) );
            							}
            							else {
HXLINE( 337)								if ((s21 > 1)) {
HXLINE( 337)									s21 = ( (Float)(1) );
            								}
            							}
HXDLIN( 337)							Float f1x = ((Float)0.0);
HXDLIN( 337)							Float f1y = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								Float t12 = t11;
HXDLIN( 337)								f1x = (v01->x + (vx * t12));
HXDLIN( 337)								f1y = (v01->y + (vy * t12));
            							}
HXDLIN( 337)							Float f2x = ((Float)0.0);
HXDLIN( 337)							Float f2y = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								Float t13 = t21;
HXDLIN( 337)								f2x = (v01->x + (vx * t13));
HXDLIN( 337)								f2y = (v01->y + (vy * t13));
            							}
HXDLIN( 337)							Float g1x = ((Float)0.0);
HXDLIN( 337)							Float g1y = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								Float t14 = s11;
HXDLIN( 337)								g1x = (q0->x + (qx * t14));
HXDLIN( 337)								g1y = (q0->y + (qy * t14));
            							}
HXDLIN( 337)							Float g2x = ((Float)0.0);
HXDLIN( 337)							Float g2y = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								Float t15 = s21;
HXDLIN( 337)								g2x = (q0->x + (qx * t15));
HXDLIN( 337)								g2y = (q0->y + (qy * t15));
            							}
HXDLIN( 337)							Float dx = ((Float)0.0);
HXDLIN( 337)							Float dy = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								dx = (f1x - q0->x);
HXDLIN( 337)								dy = (f1y - q0->y);
            							}
HXDLIN( 337)							Float d1 = ((dx * dx) + (dy * dy));
HXDLIN( 337)							Float dx1 = ((Float)0.0);
HXDLIN( 337)							Float dy1 = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								dx1 = (f2x - q11->x);
HXDLIN( 337)								dy1 = (f2y - q11->y);
            							}
HXDLIN( 337)							Float d2 = ((dx1 * dx1) + (dy1 * dy1));
HXDLIN( 337)							Float dx2 = ((Float)0.0);
HXDLIN( 337)							Float dy2 = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								dx2 = (g1x - v01->x);
HXDLIN( 337)								dy2 = (g1y - v01->y);
            							}
HXDLIN( 337)							Float e1 = ((dx2 * dx2) + (dy2 * dy2));
HXDLIN( 337)							Float dx3 = ((Float)0.0);
HXDLIN( 337)							Float dy3 = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								dx3 = (g2x - v11->x);
HXDLIN( 337)								dy3 = (g2y - v11->y);
            							}
HXDLIN( 337)							Float e2 = ((dx3 * dx3) + (dy3 * dy3));
HXDLIN( 337)							Float minfx = ((Float)0.0);
HXDLIN( 337)							Float minfy = ((Float)0.0);
HXDLIN( 337)							 ::zpp_nape::geom::ZPP_Vec2 minq = null();
HXDLIN( 337)							if ((d1 < d2)) {
HXLINE( 337)								{
HXLINE( 337)									minfx = f1x;
HXDLIN( 337)									minfy = f1y;
            								}
HXDLIN( 337)								minq = q0;
            							}
            							else {
HXLINE( 337)								{
HXLINE( 337)									minfx = f2x;
HXDLIN( 337)									minfy = f2y;
            								}
HXDLIN( 337)								minq = q11;
HXDLIN( 337)								d1 = d2;
            							}
HXDLIN( 337)							Float mingx = ((Float)0.0);
HXDLIN( 337)							Float mingy = ((Float)0.0);
HXDLIN( 337)							 ::zpp_nape::geom::ZPP_Vec2 minv = null();
HXDLIN( 337)							if ((e1 < e2)) {
HXLINE( 337)								{
HXLINE( 337)									mingx = g1x;
HXDLIN( 337)									mingy = g1y;
            								}
HXDLIN( 337)								minv = v01;
            							}
            							else {
HXLINE( 337)								{
HXLINE( 337)									mingx = g2x;
HXDLIN( 337)									mingy = g2y;
            								}
HXDLIN( 337)								minv = v11;
HXDLIN( 337)								e1 = e2;
            							}
HXDLIN( 337)							if ((d1 < e1)) {
HXLINE( 337)								{
HXLINE( 337)									w1->x = minfx;
HXDLIN( 337)									w1->y = minfy;
            								}
HXDLIN( 337)								{
HXLINE( 337)									w2->x = minq->x;
HXDLIN( 337)									w2->y = minq->y;
            								}
HXDLIN( 337)								best1 = ::Math_obj::sqrt(d1);
            							}
            							else {
HXLINE( 337)								{
HXLINE( 337)									w2->x = mingx;
HXDLIN( 337)									w2->y = mingy;
            								}
HXDLIN( 337)								{
HXLINE( 337)									w1->x = minv->x;
HXDLIN( 337)									w1->y = minv->y;
            								}
HXDLIN( 337)								best1 = ::Math_obj::sqrt(e1);
            							}
HXDLIN( 337)							if ((best1 != 0)) {
HXLINE( 337)								{
HXLINE( 337)									tmp->x = (w2->x - w1->x);
HXDLIN( 337)									tmp->y = (w2->y - w1->y);
            								}
HXDLIN( 337)								{
HXLINE( 337)									Float t16 = (((Float)1.0) / best1);
HXDLIN( 337)									 ::zpp_nape::geom::ZPP_Vec2 tmp4 = tmp;
HXDLIN( 337)									tmp4->x = (tmp4->x * t16);
HXDLIN( 337)									 ::zpp_nape::geom::ZPP_Vec2 tmp5 = tmp;
HXDLIN( 337)									tmp5->y = (tmp5->y * t16);
            								}
HXDLIN( 337)								if (swapped) {
HXLINE( 337)									tmp->x = -(tmp->x);
HXDLIN( 337)									tmp->y = -(tmp->y);
            								}
            							}
HXDLIN( 337)							ret = best1;
            						}
            						else {
HXLINE( 337)							Float c0x = ((Float)0.0);
HXDLIN( 337)							Float c0y = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								c0x = ay->gp0->x;
HXDLIN( 337)								c0y = ay->gp0->y;
            							}
HXDLIN( 337)							Float c1x = ((Float)0.0);
HXDLIN( 337)							Float c1y = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								c1x = ay->gp1->x;
HXDLIN( 337)								c1y = ay->gp1->y;
            							}
HXDLIN( 337)							Float dvx = ((Float)0.0);
HXDLIN( 337)							Float dvy = ((Float)0.0);
HXDLIN( 337)							{
HXLINE( 337)								dvx = (c1x - c0x);
HXDLIN( 337)								dvy = (c1y - c0y);
            							}
HXDLIN( 337)							Float d0 = ((ax->gnormy * c0x) - (ax->gnormx * c0y));
HXDLIN( 337)							Float d11 = ((ax->gnormy * c1x) - (ax->gnormx * c1y));
HXDLIN( 337)							Float den = (( (Float)(1) ) / (d11 - d0));
HXDLIN( 337)							Float t17 = ((-(ax->tp1) - d0) * den);
HXDLIN( 337)							if ((t17 > ::nape::Config_obj::epsilon)) {
HXLINE( 337)								Float t18 = t17;
HXDLIN( 337)								c0x = (c0x + (dvx * t18));
HXDLIN( 337)								c0y = (c0y + (dvy * t18));
            							}
HXDLIN( 337)							Float t19 = ((-(ax->tp0) - d11) * den);
HXDLIN( 337)							if ((t19 < -(::nape::Config_obj::epsilon))) {
HXLINE( 337)								Float t20 = t19;
HXDLIN( 337)								c1x = (c1x + (dvx * t20));
HXDLIN( 337)								c1y = (c1y + (dvy * t20));
            							}
HXDLIN( 337)							Float c0d = (((c0x * ax->gnormx) + (c0y * ax->gnormy)) - ax->gprojection);
HXDLIN( 337)							Float c1d = (((c1x * ax->gnormx) + (c1y * ax->gnormy)) - ax->gprojection);
HXDLIN( 337)							if ((c0d < c1d)) {
HXLINE( 337)								{
HXLINE( 337)									w2->x = c0x;
HXDLIN( 337)									w2->y = c0y;
            								}
HXDLIN( 337)								{
HXLINE( 337)									Float t22 = -(c0d);
HXDLIN( 337)									w1->x = (w2->x + (ax->gnormx * t22));
HXDLIN( 337)									w1->y = (w2->y + (ax->gnormy * t22));
            								}
HXDLIN( 337)								ret = c0d;
            							}
            							else {
HXLINE( 337)								{
HXLINE( 337)									w2->x = c1x;
HXDLIN( 337)									w2->y = c1y;
            								}
HXDLIN( 337)								{
HXLINE( 337)									Float t23 = -(c1d);
HXDLIN( 337)									w1->x = (w2->x + (ax->gnormx * t23));
HXDLIN( 337)									w1->y = (w2->y + (ax->gnormy * t23));
            								}
HXDLIN( 337)								ret = c1d;
            							}
            						}
            					}
            					else {
HXLINE( 337)						ret = ((Float)1e100);
            					}
            				}
            				else {
HXLINE( 337)					ret = ((Float)1e100);
            				}
            			}
            		}
HXLINE( 338)		{
HXLINE( 339)			 ::zpp_nape::geom::ZPP_Vec2 o = tmp;
HXLINE( 348)			{
HXLINE( 348)				if (hx::IsNotNull( o->outer )) {
HXLINE( 348)					o->outer->zpp_inner = null();
HXDLIN( 348)					o->outer = null();
            				}
HXDLIN( 348)				o->_isimmutable = null();
HXDLIN( 348)				o->_validate = null();
HXDLIN( 348)				o->_invalidate = null();
            			}
HXLINE( 349)			o->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXLINE( 350)			::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o;
            		}
HXLINE( 355)		return ret;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Geom_obj,distance,return )

bool Geom_obj::intersectsBody( ::nape::phys::Body body1, ::nape::phys::Body body2){
            	HX_STACKFRAME(&_hx_pos_ea88d4a00c1343cf_370_intersectsBody)
HXLINE( 372)		bool _hx_tmp;
HXDLIN( 372)		 ::nape::shape::ShapeList _this = body1->zpp_inner->wrap_shapes;
HXDLIN( 372)		if (hx::IsNotNull( _this->zpp_inner->inner->head )) {
HXLINE( 372)			 ::nape::shape::ShapeList _this1 = body2->zpp_inner->wrap_shapes;
HXDLIN( 372)			_hx_tmp = hx::IsNull( _this1->zpp_inner->inner->head );
            		}
            		else {
HXLINE( 372)			_hx_tmp = true;
            		}
HXDLIN( 372)		if (_hx_tmp) {
HXLINE( 372)			HX_STACK_DO_THROW(HX_("Error: Bodies must have shapes to test for intersection.",8a,35,fe,55));
            		}
HXLINE( 374)		{
HXLINE( 375)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite = body1->zpp_inner->shapes->head;
HXLINE( 376)			while(hx::IsNotNull( cx_ite )){
HXLINE( 377)				 ::zpp_nape::shape::ZPP_Shape i = cx_ite->elt;
HXLINE( 378)				::zpp_nape::geom::ZPP_Geom_obj::validateShape(i);
HXLINE( 379)				cx_ite = cx_ite->next;
            			}
            		}
HXLINE( 382)		{
HXLINE( 383)			 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite1 = body2->zpp_inner->shapes->head;
HXLINE( 384)			while(hx::IsNotNull( cx_ite1 )){
HXLINE( 385)				 ::zpp_nape::shape::ZPP_Shape i1 = cx_ite1->elt;
HXLINE( 386)				::zpp_nape::geom::ZPP_Geom_obj::validateShape(i1);
HXLINE( 387)				cx_ite1 = cx_ite1->next;
            			}
            		}
HXLINE( 390)		 ::zpp_nape::geom::ZPP_AABB _this2 = body1->zpp_inner->aabb;
HXDLIN( 390)		 ::zpp_nape::geom::ZPP_AABB x = body2->zpp_inner->aabb;
HXDLIN( 390)		bool _hx_tmp1;
HXDLIN( 390)		bool _hx_tmp2;
HXDLIN( 390)		bool _hx_tmp3;
HXDLIN( 390)		if ((x->miny <= _this2->maxy)) {
HXLINE( 390)			_hx_tmp3 = (_this2->miny <= x->maxy);
            		}
            		else {
HXLINE( 390)			_hx_tmp3 = false;
            		}
HXDLIN( 390)		if (_hx_tmp3) {
HXLINE( 390)			_hx_tmp2 = (x->minx <= _this2->maxx);
            		}
            		else {
HXLINE( 390)			_hx_tmp2 = false;
            		}
HXDLIN( 390)		if (_hx_tmp2) {
HXLINE( 390)			_hx_tmp1 = (_this2->minx <= x->maxx);
            		}
            		else {
HXLINE( 390)			_hx_tmp1 = false;
            		}
HXDLIN( 390)		if (!(_hx_tmp1)) {
HXLINE( 391)			return false;
            		}
            		else {
HXLINE( 394)			{
HXLINE( 395)				 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite2 = body1->zpp_inner->shapes->head;
HXLINE( 396)				while(hx::IsNotNull( cx_ite2 )){
HXLINE( 397)					 ::zpp_nape::shape::ZPP_Shape s1 = cx_ite2->elt;
HXLINE( 399)					{
HXLINE( 400)						 ::zpp_nape::util::ZNPNode_ZPP_Shape cx_ite3 = body2->zpp_inner->shapes->head;
HXLINE( 401)						while(hx::IsNotNull( cx_ite3 )){
HXLINE( 402)							 ::zpp_nape::shape::ZPP_Shape s2 = cx_ite3->elt;
HXLINE( 404)							if (::zpp_nape::geom::ZPP_Collide_obj::testCollide_safe(s1,s2)) {
HXLINE( 405)								return true;
            							}
HXLINE( 408)							cx_ite3 = cx_ite3->next;
            						}
            					}
HXLINE( 412)					cx_ite2 = cx_ite2->next;
            				}
            			}
HXLINE( 415)			return false;
            		}
HXLINE( 390)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Geom_obj,intersectsBody,return )

bool Geom_obj::intersects( ::nape::shape::Shape shape1, ::nape::shape::Shape shape2){
            	HX_STACKFRAME(&_hx_pos_ea88d4a00c1343cf_435_intersects)
HXLINE( 437)		bool _hx_tmp;
HXDLIN( 437)		 ::nape::phys::Body _hx_tmp1;
HXDLIN( 437)		if (hx::IsNotNull( shape1->zpp_inner->body )) {
HXLINE( 437)			_hx_tmp1 = shape1->zpp_inner->body->outer;
            		}
            		else {
HXLINE( 437)			_hx_tmp1 = null();
            		}
HXDLIN( 437)		if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 437)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 437)			if (hx::IsNotNull( shape2->zpp_inner->body )) {
HXLINE( 437)				_hx_tmp2 = shape2->zpp_inner->body->outer;
            			}
            			else {
HXLINE( 437)				_hx_tmp2 = null();
            			}
HXDLIN( 437)			_hx_tmp = hx::IsNull( _hx_tmp2 );
            		}
            		else {
HXLINE( 437)			_hx_tmp = true;
            		}
HXDLIN( 437)		if (_hx_tmp) {
HXLINE( 437)			HX_STACK_DO_THROW(HX_("Error: Shape must be part of a Body to calculate intersection",f8,cf,01,20));
            		}
HXLINE( 439)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(shape1->zpp_inner);
HXLINE( 440)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(shape2->zpp_inner);
HXLINE( 441)		 ::zpp_nape::geom::ZPP_AABB _this = shape1->zpp_inner->aabb;
HXDLIN( 441)		 ::zpp_nape::geom::ZPP_AABB x = shape2->zpp_inner->aabb;
HXDLIN( 441)		bool _hx_tmp3;
HXDLIN( 441)		bool _hx_tmp4;
HXDLIN( 441)		bool _hx_tmp5;
HXDLIN( 441)		if ((x->miny <= _this->maxy)) {
HXLINE( 441)			_hx_tmp5 = (_this->miny <= x->maxy);
            		}
            		else {
HXLINE( 441)			_hx_tmp5 = false;
            		}
HXDLIN( 441)		if (_hx_tmp5) {
HXLINE( 441)			_hx_tmp4 = (x->minx <= _this->maxx);
            		}
            		else {
HXLINE( 441)			_hx_tmp4 = false;
            		}
HXDLIN( 441)		if (_hx_tmp4) {
HXLINE( 441)			_hx_tmp3 = (_this->minx <= x->maxx);
            		}
            		else {
HXLINE( 441)			_hx_tmp3 = false;
            		}
HXDLIN( 441)		if (_hx_tmp3) {
HXLINE( 441)			return ::zpp_nape::geom::ZPP_Collide_obj::testCollide_safe(shape1->zpp_inner,shape2->zpp_inner);
            		}
            		else {
HXLINE( 441)			return false;
            		}
HXDLIN( 441)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Geom_obj,intersects,return )

bool Geom_obj::contains( ::nape::shape::Shape shape1, ::nape::shape::Shape shape2){
            	HX_STACKFRAME(&_hx_pos_ea88d4a00c1343cf_456_contains)
HXLINE( 458)		bool _hx_tmp;
HXDLIN( 458)		 ::nape::phys::Body _hx_tmp1;
HXDLIN( 458)		if (hx::IsNotNull( shape1->zpp_inner->body )) {
HXLINE( 458)			_hx_tmp1 = shape1->zpp_inner->body->outer;
            		}
            		else {
HXLINE( 458)			_hx_tmp1 = null();
            		}
HXDLIN( 458)		if (hx::IsNotNull( _hx_tmp1 )) {
HXLINE( 458)			 ::nape::phys::Body _hx_tmp2;
HXDLIN( 458)			if (hx::IsNotNull( shape2->zpp_inner->body )) {
HXLINE( 458)				_hx_tmp2 = shape2->zpp_inner->body->outer;
            			}
            			else {
HXLINE( 458)				_hx_tmp2 = null();
            			}
HXDLIN( 458)			_hx_tmp = hx::IsNull( _hx_tmp2 );
            		}
            		else {
HXLINE( 458)			_hx_tmp = true;
            		}
HXDLIN( 458)		if (_hx_tmp) {
HXLINE( 458)			HX_STACK_DO_THROW(HX_("Error: Shape must be part of a Body to calculate containment",a3,9c,fd,27));
            		}
HXLINE( 460)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(shape1->zpp_inner);
HXLINE( 461)		::zpp_nape::geom::ZPP_Geom_obj::validateShape(shape2->zpp_inner);
HXLINE( 462)		return ::zpp_nape::geom::ZPP_Collide_obj::containTest(shape1->zpp_inner,shape2->zpp_inner);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Geom_obj,contains,return )


Geom_obj::Geom_obj()
{
}

bool Geom_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"distance") ) { outValue = distance_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"contains") ) { outValue = contains_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"intersects") ) { outValue = intersects_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"distanceBody") ) { outValue = distanceBody_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"intersectsBody") ) { outValue = intersectsBody_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *Geom_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *Geom_obj_sStaticStorageInfo = 0;
#endif

hx::Class Geom_obj::__mClass;

static ::String Geom_obj_sStaticFields[] = {
	HX_("distanceBody",77,78,f0,f3),
	HX_("distance",35,93,f9,6b),
	HX_("intersectsBody",76,d3,09,42),
	HX_("intersects",b4,c2,eb,e3),
	HX_("contains",1f,5a,7b,2c),
	::String(null())
};

void Geom_obj::__register()
{
	Geom_obj _hx_dummy;
	Geom_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.geom.Geom",c8,22,b2,f5);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Geom_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Geom_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Geom_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Geom_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Geom_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace geom
