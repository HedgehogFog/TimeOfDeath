// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_nape_geom_AABB
#include <hxinc/nape/geom/AABB.h>
#endif
#ifndef INCLUDED_nape_geom_Ray
#include <hxinc/nape/geom/Ray.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_AABB
#include <hxinc/zpp_nape/geom/ZPP_AABB.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Ray
#include <hxinc/zpp_nape/geom/ZPP_Ray.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_PubPool
#include <hxinc/zpp_nape/util/ZPP_PubPool.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_177_new,"nape.geom.Ray","new",0xebb19f50,"nape.geom.Ray.new","nape/geom/Ray.hx",177,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_195_get_userData,"nape.geom.Ray","get_userData",0x2d8b1d2e,"nape.geom.Ray.get_userData","nape/geom/Ray.hx",195,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_210_get_origin,"nape.geom.Ray","get_origin",0x5ceb78bf,"nape.geom.Ray.get_origin","nape/geom/Ray.hx",210,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_212_set_origin,"nape.geom.Ray","set_origin",0x60691733,"nape.geom.Ray.set_origin","nape/geom/Ray.hx",212,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_240_get_direction,"nape.geom.Ray","get_direction",0x3e141106,"nape.geom.Ray.get_direction","nape/geom/Ray.hx",240,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_242_set_direction,"nape.geom.Ray","set_direction",0x8319f312,"nape.geom.Ray.set_direction","nape/geom/Ray.hx",242,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_273_get_maxDistance,"nape.geom.Ray","get_maxDistance",0xeef1cc80,"nape.geom.Ray.get_maxDistance","nape/geom/Ray.hx",273,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_275_set_maxDistance,"nape.geom.Ray","set_maxDistance",0xeabd498c,"nape.geom.Ray.set_maxDistance","nape/geom/Ray.hx",275,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_296_aabb,"nape.geom.Ray","aabb",0x471ee5b0,"nape.geom.Ray.aabb","nape/geom/Ray.hx",296,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_313_at,"nape.geom.Ray","at",0x7f55b403,"nape.geom.Ray.at","nape/geom/Ray.hx",313,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_350_copy,"nape.geom.Ray","copy",0x487bfec5,"nape.geom.Ray.copy","nape/geom/Ray.hx",350,0xeaaa9e80)
HX_LOCAL_STACK_FRAME(_hx_pos_4f8965e3d8a05fef_370_fromSegment,"nape.geom.Ray","fromSegment",0x543d7259,"nape.geom.Ray.fromSegment","nape/geom/Ray.hx",370,0xeaaa9e80)
namespace nape{
namespace geom{

void Ray_obj::__construct( ::nape::geom::Vec2 origin, ::nape::geom::Vec2 direction){
            	HX_GC_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_177_new)
HXLINE( 181)		this->zpp_inner = null();
HXLINE( 330)		bool _hx_tmp;
HXDLIN( 330)		if (hx::IsNotNull( origin )) {
HXLINE( 330)			_hx_tmp = origin->zpp_disp;
            		}
            		else {
HXLINE( 330)			_hx_tmp = false;
            		}
HXDLIN( 330)		if (_hx_tmp) {
HXLINE( 330)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 335)		bool _hx_tmp1;
HXDLIN( 335)		if (hx::IsNotNull( direction )) {
HXLINE( 335)			_hx_tmp1 = direction->zpp_disp;
            		}
            		else {
HXLINE( 335)			_hx_tmp1 = false;
            		}
HXDLIN( 335)		if (_hx_tmp1) {
HXLINE( 335)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 338)		this->zpp_inner =  ::zpp_nape::geom::ZPP_Ray_obj::__alloc( HX_CTX );
HXLINE( 339)		{
HXLINE( 339)			bool _hx_tmp2;
HXDLIN( 339)			if (hx::IsNotNull( origin )) {
HXLINE( 339)				_hx_tmp2 = origin->zpp_disp;
            			}
            			else {
HXLINE( 339)				_hx_tmp2 = false;
            			}
HXDLIN( 339)			if (_hx_tmp2) {
HXLINE( 339)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 339)			if (hx::IsNull( origin )) {
HXLINE( 339)				HX_STACK_DO_THROW(HX_("Error: Ray::origin cannot be null",65,67,2f,83));
            			}
HXDLIN( 339)			{
HXLINE( 339)				 ::nape::geom::Vec2 _this = this->zpp_inner->origin;
HXDLIN( 339)				bool _hx_tmp3;
HXDLIN( 339)				if (hx::IsNotNull( _this )) {
HXLINE( 339)					_hx_tmp3 = _this->zpp_disp;
            				}
            				else {
HXLINE( 339)					_hx_tmp3 = false;
            				}
HXDLIN( 339)				if (_hx_tmp3) {
HXLINE( 339)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 339)				bool _hx_tmp4;
HXDLIN( 339)				if (hx::IsNotNull( origin )) {
HXLINE( 339)					_hx_tmp4 = origin->zpp_disp;
            				}
            				else {
HXLINE( 339)					_hx_tmp4 = false;
            				}
HXDLIN( 339)				if (_hx_tmp4) {
HXLINE( 339)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 339)				{
HXLINE( 339)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 339)					if (_this1->_immutable) {
HXLINE( 339)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 339)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 339)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 339)				if (hx::IsNull( origin )) {
HXLINE( 339)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 339)				bool _hx_tmp5;
HXDLIN( 339)				if (hx::IsNotNull( origin )) {
HXLINE( 339)					_hx_tmp5 = origin->zpp_disp;
            				}
            				else {
HXLINE( 339)					_hx_tmp5 = false;
            				}
HXDLIN( 339)				if (_hx_tmp5) {
HXLINE( 339)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 339)				{
HXLINE( 339)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = origin->zpp_inner;
HXDLIN( 339)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 339)						_this2->_validate();
            					}
            				}
HXDLIN( 339)				Float x = origin->zpp_inner->x;
HXDLIN( 339)				bool _hx_tmp6;
HXDLIN( 339)				if (hx::IsNotNull( origin )) {
HXLINE( 339)					_hx_tmp6 = origin->zpp_disp;
            				}
            				else {
HXLINE( 339)					_hx_tmp6 = false;
            				}
HXDLIN( 339)				if (_hx_tmp6) {
HXLINE( 339)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 339)				{
HXLINE( 339)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = origin->zpp_inner;
HXDLIN( 339)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 339)						_this3->_validate();
            					}
            				}
HXDLIN( 339)				Float y = origin->zpp_inner->y;
HXDLIN( 339)				bool _hx_tmp7;
HXDLIN( 339)				if (hx::IsNotNull( _this )) {
HXLINE( 339)					_hx_tmp7 = _this->zpp_disp;
            				}
            				else {
HXLINE( 339)					_hx_tmp7 = false;
            				}
HXDLIN( 339)				if (_hx_tmp7) {
HXLINE( 339)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 339)				{
HXLINE( 339)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 339)					if (_this4->_immutable) {
HXLINE( 339)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 339)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 339)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 339)				bool _hx_tmp8;
HXDLIN( 339)				if ((x == x)) {
HXLINE( 339)					_hx_tmp8 = (y != y);
            				}
            				else {
HXLINE( 339)					_hx_tmp8 = true;
            				}
HXDLIN( 339)				if (_hx_tmp8) {
HXLINE( 339)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 339)				bool _hx_tmp9;
HXDLIN( 339)				bool _hx_tmp10;
HXDLIN( 339)				if (hx::IsNotNull( _this )) {
HXLINE( 339)					_hx_tmp10 = _this->zpp_disp;
            				}
            				else {
HXLINE( 339)					_hx_tmp10 = false;
            				}
HXDLIN( 339)				if (_hx_tmp10) {
HXLINE( 339)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 339)				{
HXLINE( 339)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 339)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 339)						_this5->_validate();
            					}
            				}
HXDLIN( 339)				if ((_this->zpp_inner->x == x)) {
HXLINE( 339)					bool _hx_tmp11;
HXDLIN( 339)					if (hx::IsNotNull( _this )) {
HXLINE( 339)						_hx_tmp11 = _this->zpp_disp;
            					}
            					else {
HXLINE( 339)						_hx_tmp11 = false;
            					}
HXDLIN( 339)					if (_hx_tmp11) {
HXLINE( 339)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 339)					{
HXLINE( 339)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 339)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 339)							_this6->_validate();
            						}
            					}
HXDLIN( 339)					_hx_tmp9 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 339)					_hx_tmp9 = false;
            				}
HXDLIN( 339)				if (!(_hx_tmp9)) {
HXLINE( 339)					{
HXLINE( 339)						_this->zpp_inner->x = x;
HXDLIN( 339)						_this->zpp_inner->y = y;
            					}
HXDLIN( 339)					{
HXLINE( 339)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 339)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 339)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 339)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 339)				if (origin->zpp_inner->weak) {
HXLINE( 339)					bool _hx_tmp12;
HXDLIN( 339)					if (hx::IsNotNull( origin )) {
HXLINE( 339)						_hx_tmp12 = origin->zpp_disp;
            					}
            					else {
HXLINE( 339)						_hx_tmp12 = false;
            					}
HXDLIN( 339)					if (_hx_tmp12) {
HXLINE( 339)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 339)					{
HXLINE( 339)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = origin->zpp_inner;
HXDLIN( 339)						if (_this8->_immutable) {
HXLINE( 339)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 339)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 339)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 339)					if (origin->zpp_inner->_inuse) {
HXLINE( 339)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 339)					 ::zpp_nape::geom::ZPP_Vec2 inner = origin->zpp_inner;
HXDLIN( 339)					origin->zpp_inner->outer = null();
HXDLIN( 339)					origin->zpp_inner = null();
HXDLIN( 339)					{
HXLINE( 339)						 ::nape::geom::Vec2 o = origin;
HXDLIN( 339)						o->zpp_pool = null();
HXDLIN( 339)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 339)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 339)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 339)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 339)						o->zpp_disp = true;
            					}
HXDLIN( 339)					{
HXLINE( 339)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 339)						{
HXLINE( 339)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 339)								o1->outer->zpp_inner = null();
HXDLIN( 339)								o1->outer = null();
            							}
HXDLIN( 339)							o1->_isimmutable = null();
HXDLIN( 339)							o1->_validate = null();
HXDLIN( 339)							o1->_invalidate = null();
            						}
HXDLIN( 339)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 339)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 340)		{
HXLINE( 340)			bool _hx_tmp13;
HXDLIN( 340)			if (hx::IsNotNull( direction )) {
HXLINE( 340)				_hx_tmp13 = direction->zpp_disp;
            			}
            			else {
HXLINE( 340)				_hx_tmp13 = false;
            			}
HXDLIN( 340)			if (_hx_tmp13) {
HXLINE( 340)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 340)			if (hx::IsNull( direction )) {
HXLINE( 340)				HX_STACK_DO_THROW(HX_("Error: Ray::direction cannot be null",a4,b0,53,3b));
            			}
HXDLIN( 340)			{
HXLINE( 340)				 ::nape::geom::Vec2 _this9 = this->zpp_inner->direction;
HXDLIN( 340)				bool _hx_tmp14;
HXDLIN( 340)				if (hx::IsNotNull( _this9 )) {
HXLINE( 340)					_hx_tmp14 = _this9->zpp_disp;
            				}
            				else {
HXLINE( 340)					_hx_tmp14 = false;
            				}
HXDLIN( 340)				if (_hx_tmp14) {
HXLINE( 340)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 340)				bool _hx_tmp15;
HXDLIN( 340)				if (hx::IsNotNull( direction )) {
HXLINE( 340)					_hx_tmp15 = direction->zpp_disp;
            				}
            				else {
HXLINE( 340)					_hx_tmp15 = false;
            				}
HXDLIN( 340)				if (_hx_tmp15) {
HXLINE( 340)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 340)				{
HXLINE( 340)					 ::zpp_nape::geom::ZPP_Vec2 _this10 = _this9->zpp_inner;
HXDLIN( 340)					if (_this10->_immutable) {
HXLINE( 340)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 340)					if (hx::IsNotNull( _this10->_isimmutable )) {
HXLINE( 340)						_this10->_isimmutable();
            					}
            				}
HXDLIN( 340)				if (hx::IsNull( direction )) {
HXLINE( 340)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 340)				bool _hx_tmp16;
HXDLIN( 340)				if (hx::IsNotNull( direction )) {
HXLINE( 340)					_hx_tmp16 = direction->zpp_disp;
            				}
            				else {
HXLINE( 340)					_hx_tmp16 = false;
            				}
HXDLIN( 340)				if (_hx_tmp16) {
HXLINE( 340)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 340)				{
HXLINE( 340)					 ::zpp_nape::geom::ZPP_Vec2 _this11 = direction->zpp_inner;
HXDLIN( 340)					if (hx::IsNotNull( _this11->_validate )) {
HXLINE( 340)						_this11->_validate();
            					}
            				}
HXDLIN( 340)				Float x1 = direction->zpp_inner->x;
HXDLIN( 340)				bool _hx_tmp17;
HXDLIN( 340)				if (hx::IsNotNull( direction )) {
HXLINE( 340)					_hx_tmp17 = direction->zpp_disp;
            				}
            				else {
HXLINE( 340)					_hx_tmp17 = false;
            				}
HXDLIN( 340)				if (_hx_tmp17) {
HXLINE( 340)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 340)				{
HXLINE( 340)					 ::zpp_nape::geom::ZPP_Vec2 _this12 = direction->zpp_inner;
HXDLIN( 340)					if (hx::IsNotNull( _this12->_validate )) {
HXLINE( 340)						_this12->_validate();
            					}
            				}
HXDLIN( 340)				Float y1 = direction->zpp_inner->y;
HXDLIN( 340)				bool _hx_tmp18;
HXDLIN( 340)				if (hx::IsNotNull( _this9 )) {
HXLINE( 340)					_hx_tmp18 = _this9->zpp_disp;
            				}
            				else {
HXLINE( 340)					_hx_tmp18 = false;
            				}
HXDLIN( 340)				if (_hx_tmp18) {
HXLINE( 340)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 340)				{
HXLINE( 340)					 ::zpp_nape::geom::ZPP_Vec2 _this13 = _this9->zpp_inner;
HXDLIN( 340)					if (_this13->_immutable) {
HXLINE( 340)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 340)					if (hx::IsNotNull( _this13->_isimmutable )) {
HXLINE( 340)						_this13->_isimmutable();
            					}
            				}
HXDLIN( 340)				bool _hx_tmp19;
HXDLIN( 340)				if ((x1 == x1)) {
HXLINE( 340)					_hx_tmp19 = (y1 != y1);
            				}
            				else {
HXLINE( 340)					_hx_tmp19 = true;
            				}
HXDLIN( 340)				if (_hx_tmp19) {
HXLINE( 340)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 340)				bool _hx_tmp20;
HXDLIN( 340)				bool _hx_tmp21;
HXDLIN( 340)				if (hx::IsNotNull( _this9 )) {
HXLINE( 340)					_hx_tmp21 = _this9->zpp_disp;
            				}
            				else {
HXLINE( 340)					_hx_tmp21 = false;
            				}
HXDLIN( 340)				if (_hx_tmp21) {
HXLINE( 340)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 340)				{
HXLINE( 340)					 ::zpp_nape::geom::ZPP_Vec2 _this14 = _this9->zpp_inner;
HXDLIN( 340)					if (hx::IsNotNull( _this14->_validate )) {
HXLINE( 340)						_this14->_validate();
            					}
            				}
HXDLIN( 340)				if ((_this9->zpp_inner->x == x1)) {
HXLINE( 340)					bool _hx_tmp22;
HXDLIN( 340)					if (hx::IsNotNull( _this9 )) {
HXLINE( 340)						_hx_tmp22 = _this9->zpp_disp;
            					}
            					else {
HXLINE( 340)						_hx_tmp22 = false;
            					}
HXDLIN( 340)					if (_hx_tmp22) {
HXLINE( 340)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 340)					{
HXLINE( 340)						 ::zpp_nape::geom::ZPP_Vec2 _this15 = _this9->zpp_inner;
HXDLIN( 340)						if (hx::IsNotNull( _this15->_validate )) {
HXLINE( 340)							_this15->_validate();
            						}
            					}
HXDLIN( 340)					_hx_tmp20 = (_this9->zpp_inner->y == y1);
            				}
            				else {
HXLINE( 340)					_hx_tmp20 = false;
            				}
HXDLIN( 340)				if (!(_hx_tmp20)) {
HXLINE( 340)					{
HXLINE( 340)						_this9->zpp_inner->x = x1;
HXDLIN( 340)						_this9->zpp_inner->y = y1;
            					}
HXDLIN( 340)					{
HXLINE( 340)						 ::zpp_nape::geom::ZPP_Vec2 _this16 = _this9->zpp_inner;
HXDLIN( 340)						if (hx::IsNotNull( _this16->_invalidate )) {
HXLINE( 340)							_this16->_invalidate(_this16);
            						}
            					}
            				}
HXDLIN( 340)				 ::nape::geom::Vec2 ret1 = _this9;
HXDLIN( 340)				if (direction->zpp_inner->weak) {
HXLINE( 340)					bool _hx_tmp23;
HXDLIN( 340)					if (hx::IsNotNull( direction )) {
HXLINE( 340)						_hx_tmp23 = direction->zpp_disp;
            					}
            					else {
HXLINE( 340)						_hx_tmp23 = false;
            					}
HXDLIN( 340)					if (_hx_tmp23) {
HXLINE( 340)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 340)					{
HXLINE( 340)						 ::zpp_nape::geom::ZPP_Vec2 _this17 = direction->zpp_inner;
HXDLIN( 340)						if (_this17->_immutable) {
HXLINE( 340)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 340)						if (hx::IsNotNull( _this17->_isimmutable )) {
HXLINE( 340)							_this17->_isimmutable();
            						}
            					}
HXDLIN( 340)					if (direction->zpp_inner->_inuse) {
HXLINE( 340)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 340)					 ::zpp_nape::geom::ZPP_Vec2 inner1 = direction->zpp_inner;
HXDLIN( 340)					direction->zpp_inner->outer = null();
HXDLIN( 340)					direction->zpp_inner = null();
HXDLIN( 340)					{
HXLINE( 340)						 ::nape::geom::Vec2 o2 = direction;
HXDLIN( 340)						o2->zpp_pool = null();
HXDLIN( 340)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 340)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            						}
            						else {
HXLINE( 340)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            						}
HXDLIN( 340)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN( 340)						o2->zpp_disp = true;
            					}
HXDLIN( 340)					{
HXLINE( 340)						 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN( 340)						{
HXLINE( 340)							if (hx::IsNotNull( o3->outer )) {
HXLINE( 340)								o3->outer->zpp_inner = null();
HXDLIN( 340)								o3->outer = null();
            							}
HXDLIN( 340)							o3->_isimmutable = null();
HXDLIN( 340)							o3->_validate = null();
HXDLIN( 340)							o3->_invalidate = null();
            						}
HXDLIN( 340)						o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 340)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            					}
            				}
            			}
HXDLIN( 340)			this->zpp_inner->zip_dir = true;
            		}
HXLINE( 341)		this->zpp_inner->maxdist = ::Math_obj::POSITIVE_INFINITY;
            	}

Dynamic Ray_obj::__CreateEmpty() { return new Ray_obj; }

void *Ray_obj::_hx_vtable = 0;

Dynamic Ray_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Ray_obj > _hx_result = new Ray_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Ray_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x672b9442;
}

 ::Dynamic Ray_obj::get_userData(){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_195_get_userData)
HXLINE( 196)		if (hx::IsNull( this->zpp_inner->userData )) {
HXLINE( 197)			this->zpp_inner->userData =  ::Dynamic(hx::Anon_obj::Create(0));
            		}
HXLINE( 199)		return this->zpp_inner->userData;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray_obj,get_userData,return )

 ::nape::geom::Vec2 Ray_obj::get_origin(){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_210_get_origin)
HXDLIN( 210)		return this->zpp_inner->origin;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray_obj,get_origin,return )

 ::nape::geom::Vec2 Ray_obj::set_origin( ::nape::geom::Vec2 origin){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_212_set_origin)
HXLINE( 213)		{
HXLINE( 216)			bool _hx_tmp;
HXDLIN( 216)			if (hx::IsNotNull( origin )) {
HXLINE( 216)				_hx_tmp = origin->zpp_disp;
            			}
            			else {
HXLINE( 216)				_hx_tmp = false;
            			}
HXDLIN( 216)			if (_hx_tmp) {
HXLINE( 216)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 220)			if (hx::IsNull( origin )) {
HXLINE( 221)				HX_STACK_DO_THROW(HX_("Error: Ray::origin cannot be null",65,67,2f,83));
            			}
HXLINE( 224)			{
HXLINE( 224)				 ::nape::geom::Vec2 _this = this->zpp_inner->origin;
HXDLIN( 224)				bool _hx_tmp1;
HXDLIN( 224)				if (hx::IsNotNull( _this )) {
HXLINE( 224)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 224)					_hx_tmp1 = false;
            				}
HXDLIN( 224)				if (_hx_tmp1) {
HXLINE( 224)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 224)				bool _hx_tmp2;
HXDLIN( 224)				if (hx::IsNotNull( origin )) {
HXLINE( 224)					_hx_tmp2 = origin->zpp_disp;
            				}
            				else {
HXLINE( 224)					_hx_tmp2 = false;
            				}
HXDLIN( 224)				if (_hx_tmp2) {
HXLINE( 224)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 224)				{
HXLINE( 224)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 224)					if (_this1->_immutable) {
HXLINE( 224)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 224)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 224)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 224)				if (hx::IsNull( origin )) {
HXLINE( 224)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 224)				bool _hx_tmp3;
HXDLIN( 224)				if (hx::IsNotNull( origin )) {
HXLINE( 224)					_hx_tmp3 = origin->zpp_disp;
            				}
            				else {
HXLINE( 224)					_hx_tmp3 = false;
            				}
HXDLIN( 224)				if (_hx_tmp3) {
HXLINE( 224)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 224)				{
HXLINE( 224)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = origin->zpp_inner;
HXDLIN( 224)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 224)						_this2->_validate();
            					}
            				}
HXDLIN( 224)				Float x = origin->zpp_inner->x;
HXDLIN( 224)				bool _hx_tmp4;
HXDLIN( 224)				if (hx::IsNotNull( origin )) {
HXLINE( 224)					_hx_tmp4 = origin->zpp_disp;
            				}
            				else {
HXLINE( 224)					_hx_tmp4 = false;
            				}
HXDLIN( 224)				if (_hx_tmp4) {
HXLINE( 224)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 224)				{
HXLINE( 224)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = origin->zpp_inner;
HXDLIN( 224)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 224)						_this3->_validate();
            					}
            				}
HXDLIN( 224)				Float y = origin->zpp_inner->y;
HXDLIN( 224)				bool _hx_tmp5;
HXDLIN( 224)				if (hx::IsNotNull( _this )) {
HXLINE( 224)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 224)					_hx_tmp5 = false;
            				}
HXDLIN( 224)				if (_hx_tmp5) {
HXLINE( 224)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 224)				{
HXLINE( 224)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 224)					if (_this4->_immutable) {
HXLINE( 224)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 224)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 224)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 224)				bool _hx_tmp6;
HXDLIN( 224)				if ((x == x)) {
HXLINE( 224)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 224)					_hx_tmp6 = true;
            				}
HXDLIN( 224)				if (_hx_tmp6) {
HXLINE( 224)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 224)				bool _hx_tmp7;
HXDLIN( 224)				bool _hx_tmp8;
HXDLIN( 224)				if (hx::IsNotNull( _this )) {
HXLINE( 224)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 224)					_hx_tmp8 = false;
            				}
HXDLIN( 224)				if (_hx_tmp8) {
HXLINE( 224)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 224)				{
HXLINE( 224)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 224)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 224)						_this5->_validate();
            					}
            				}
HXDLIN( 224)				if ((_this->zpp_inner->x == x)) {
HXLINE( 224)					bool _hx_tmp9;
HXDLIN( 224)					if (hx::IsNotNull( _this )) {
HXLINE( 224)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 224)						_hx_tmp9 = false;
            					}
HXDLIN( 224)					if (_hx_tmp9) {
HXLINE( 224)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 224)					{
HXLINE( 224)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 224)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 224)							_this6->_validate();
            						}
            					}
HXDLIN( 224)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 224)					_hx_tmp7 = false;
            				}
HXDLIN( 224)				if (!(_hx_tmp7)) {
HXLINE( 224)					{
HXLINE( 224)						_this->zpp_inner->x = x;
HXDLIN( 224)						_this->zpp_inner->y = y;
            					}
HXDLIN( 224)					{
HXLINE( 224)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 224)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 224)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 224)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 224)				if (origin->zpp_inner->weak) {
HXLINE( 224)					bool _hx_tmp10;
HXDLIN( 224)					if (hx::IsNotNull( origin )) {
HXLINE( 224)						_hx_tmp10 = origin->zpp_disp;
            					}
            					else {
HXLINE( 224)						_hx_tmp10 = false;
            					}
HXDLIN( 224)					if (_hx_tmp10) {
HXLINE( 224)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 224)					{
HXLINE( 224)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = origin->zpp_inner;
HXDLIN( 224)						if (_this8->_immutable) {
HXLINE( 224)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 224)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 224)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 224)					if (origin->zpp_inner->_inuse) {
HXLINE( 224)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 224)					 ::zpp_nape::geom::ZPP_Vec2 inner = origin->zpp_inner;
HXDLIN( 224)					origin->zpp_inner->outer = null();
HXDLIN( 224)					origin->zpp_inner = null();
HXDLIN( 224)					{
HXLINE( 224)						 ::nape::geom::Vec2 o = origin;
HXDLIN( 224)						o->zpp_pool = null();
HXDLIN( 224)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 224)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 224)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 224)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 224)						o->zpp_disp = true;
            					}
HXDLIN( 224)					{
HXLINE( 224)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 224)						{
HXLINE( 224)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 224)								o1->outer->zpp_inner = null();
HXDLIN( 224)								o1->outer = null();
            							}
HXDLIN( 224)							o1->_isimmutable = null();
HXDLIN( 224)							o1->_validate = null();
HXDLIN( 224)							o1->_invalidate = null();
            						}
HXDLIN( 224)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 224)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
            		}
HXLINE( 226)		return this->zpp_inner->origin;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray_obj,set_origin,return )

 ::nape::geom::Vec2 Ray_obj::get_direction(){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_240_get_direction)
HXDLIN( 240)		return this->zpp_inner->direction;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray_obj,get_direction,return )

 ::nape::geom::Vec2 Ray_obj::set_direction( ::nape::geom::Vec2 direction){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_242_set_direction)
HXLINE( 243)		{
HXLINE( 246)			bool _hx_tmp;
HXDLIN( 246)			if (hx::IsNotNull( direction )) {
HXLINE( 246)				_hx_tmp = direction->zpp_disp;
            			}
            			else {
HXLINE( 246)				_hx_tmp = false;
            			}
HXDLIN( 246)			if (_hx_tmp) {
HXLINE( 246)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXLINE( 250)			if (hx::IsNull( direction )) {
HXLINE( 251)				HX_STACK_DO_THROW(HX_("Error: Ray::direction cannot be null",a4,b0,53,3b));
            			}
HXLINE( 254)			{
HXLINE( 254)				 ::nape::geom::Vec2 _this = this->zpp_inner->direction;
HXDLIN( 254)				bool _hx_tmp1;
HXDLIN( 254)				if (hx::IsNotNull( _this )) {
HXLINE( 254)					_hx_tmp1 = _this->zpp_disp;
            				}
            				else {
HXLINE( 254)					_hx_tmp1 = false;
            				}
HXDLIN( 254)				if (_hx_tmp1) {
HXLINE( 254)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 254)				bool _hx_tmp2;
HXDLIN( 254)				if (hx::IsNotNull( direction )) {
HXLINE( 254)					_hx_tmp2 = direction->zpp_disp;
            				}
            				else {
HXLINE( 254)					_hx_tmp2 = false;
            				}
HXDLIN( 254)				if (_hx_tmp2) {
HXLINE( 254)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 254)				{
HXLINE( 254)					 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 254)					if (_this1->_immutable) {
HXLINE( 254)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 254)					if (hx::IsNotNull( _this1->_isimmutable )) {
HXLINE( 254)						_this1->_isimmutable();
            					}
            				}
HXDLIN( 254)				if (hx::IsNull( direction )) {
HXLINE( 254)					HX_STACK_DO_THROW(HX_("Error: Cannot assign null Vec2",95,15,46,66));
            				}
HXDLIN( 254)				bool _hx_tmp3;
HXDLIN( 254)				if (hx::IsNotNull( direction )) {
HXLINE( 254)					_hx_tmp3 = direction->zpp_disp;
            				}
            				else {
HXLINE( 254)					_hx_tmp3 = false;
            				}
HXDLIN( 254)				if (_hx_tmp3) {
HXLINE( 254)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 254)				{
HXLINE( 254)					 ::zpp_nape::geom::ZPP_Vec2 _this2 = direction->zpp_inner;
HXDLIN( 254)					if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 254)						_this2->_validate();
            					}
            				}
HXDLIN( 254)				Float x = direction->zpp_inner->x;
HXDLIN( 254)				bool _hx_tmp4;
HXDLIN( 254)				if (hx::IsNotNull( direction )) {
HXLINE( 254)					_hx_tmp4 = direction->zpp_disp;
            				}
            				else {
HXLINE( 254)					_hx_tmp4 = false;
            				}
HXDLIN( 254)				if (_hx_tmp4) {
HXLINE( 254)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 254)				{
HXLINE( 254)					 ::zpp_nape::geom::ZPP_Vec2 _this3 = direction->zpp_inner;
HXDLIN( 254)					if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 254)						_this3->_validate();
            					}
            				}
HXDLIN( 254)				Float y = direction->zpp_inner->y;
HXDLIN( 254)				bool _hx_tmp5;
HXDLIN( 254)				if (hx::IsNotNull( _this )) {
HXLINE( 254)					_hx_tmp5 = _this->zpp_disp;
            				}
            				else {
HXLINE( 254)					_hx_tmp5 = false;
            				}
HXDLIN( 254)				if (_hx_tmp5) {
HXLINE( 254)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 254)				{
HXLINE( 254)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this->zpp_inner;
HXDLIN( 254)					if (_this4->_immutable) {
HXLINE( 254)						HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            					}
HXDLIN( 254)					if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 254)						_this4->_isimmutable();
            					}
            				}
HXDLIN( 254)				bool _hx_tmp6;
HXDLIN( 254)				if ((x == x)) {
HXLINE( 254)					_hx_tmp6 = (y != y);
            				}
            				else {
HXLINE( 254)					_hx_tmp6 = true;
            				}
HXDLIN( 254)				if (_hx_tmp6) {
HXLINE( 254)					HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            				}
HXDLIN( 254)				bool _hx_tmp7;
HXDLIN( 254)				bool _hx_tmp8;
HXDLIN( 254)				if (hx::IsNotNull( _this )) {
HXLINE( 254)					_hx_tmp8 = _this->zpp_disp;
            				}
            				else {
HXLINE( 254)					_hx_tmp8 = false;
            				}
HXDLIN( 254)				if (_hx_tmp8) {
HXLINE( 254)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 254)				{
HXLINE( 254)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this->zpp_inner;
HXDLIN( 254)					if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 254)						_this5->_validate();
            					}
            				}
HXDLIN( 254)				if ((_this->zpp_inner->x == x)) {
HXLINE( 254)					bool _hx_tmp9;
HXDLIN( 254)					if (hx::IsNotNull( _this )) {
HXLINE( 254)						_hx_tmp9 = _this->zpp_disp;
            					}
            					else {
HXLINE( 254)						_hx_tmp9 = false;
            					}
HXDLIN( 254)					if (_hx_tmp9) {
HXLINE( 254)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 254)					{
HXLINE( 254)						 ::zpp_nape::geom::ZPP_Vec2 _this6 = _this->zpp_inner;
HXDLIN( 254)						if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 254)							_this6->_validate();
            						}
            					}
HXDLIN( 254)					_hx_tmp7 = (_this->zpp_inner->y == y);
            				}
            				else {
HXLINE( 254)					_hx_tmp7 = false;
            				}
HXDLIN( 254)				if (!(_hx_tmp7)) {
HXLINE( 254)					{
HXLINE( 254)						_this->zpp_inner->x = x;
HXDLIN( 254)						_this->zpp_inner->y = y;
            					}
HXDLIN( 254)					{
HXLINE( 254)						 ::zpp_nape::geom::ZPP_Vec2 _this7 = _this->zpp_inner;
HXDLIN( 254)						if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 254)							_this7->_invalidate(_this7);
            						}
            					}
            				}
HXDLIN( 254)				 ::nape::geom::Vec2 ret = _this;
HXDLIN( 254)				if (direction->zpp_inner->weak) {
HXLINE( 254)					bool _hx_tmp10;
HXDLIN( 254)					if (hx::IsNotNull( direction )) {
HXLINE( 254)						_hx_tmp10 = direction->zpp_disp;
            					}
            					else {
HXLINE( 254)						_hx_tmp10 = false;
            					}
HXDLIN( 254)					if (_hx_tmp10) {
HXLINE( 254)						HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            					}
HXDLIN( 254)					{
HXLINE( 254)						 ::zpp_nape::geom::ZPP_Vec2 _this8 = direction->zpp_inner;
HXDLIN( 254)						if (_this8->_immutable) {
HXLINE( 254)							HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            						}
HXDLIN( 254)						if (hx::IsNotNull( _this8->_isimmutable )) {
HXLINE( 254)							_this8->_isimmutable();
            						}
            					}
HXDLIN( 254)					if (direction->zpp_inner->_inuse) {
HXLINE( 254)						HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            					}
HXDLIN( 254)					 ::zpp_nape::geom::ZPP_Vec2 inner = direction->zpp_inner;
HXDLIN( 254)					direction->zpp_inner->outer = null();
HXDLIN( 254)					direction->zpp_inner = null();
HXDLIN( 254)					{
HXLINE( 254)						 ::nape::geom::Vec2 o = direction;
HXDLIN( 254)						o->zpp_pool = null();
HXDLIN( 254)						if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 254)							::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            						}
            						else {
HXLINE( 254)							::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            						}
HXDLIN( 254)						::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 254)						o->zpp_disp = true;
            					}
HXDLIN( 254)					{
HXLINE( 254)						 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 254)						{
HXLINE( 254)							if (hx::IsNotNull( o1->outer )) {
HXLINE( 254)								o1->outer->zpp_inner = null();
HXDLIN( 254)								o1->outer = null();
            							}
HXDLIN( 254)							o1->_isimmutable = null();
HXDLIN( 254)							o1->_validate = null();
HXDLIN( 254)							o1->_invalidate = null();
            						}
HXDLIN( 254)						o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 254)						::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            					}
            				}
            			}
HXLINE( 255)			this->zpp_inner->zip_dir = true;
            		}
HXLINE( 257)		return this->zpp_inner->direction;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray_obj,set_direction,return )

Float Ray_obj::get_maxDistance(){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_273_get_maxDistance)
HXDLIN( 273)		return this->zpp_inner->maxdist;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray_obj,get_maxDistance,return )

Float Ray_obj::set_maxDistance(Float maxDistance){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_275_set_maxDistance)
HXLINE( 276)		{
HXLINE( 278)			if ((maxDistance != maxDistance)) {
HXLINE( 279)				HX_STACK_DO_THROW(HX_("Error: maxDistance cannot be NaN",c6,98,5d,73));
            			}
HXLINE( 282)			this->zpp_inner->maxdist = maxDistance;
            		}
HXLINE( 284)		return this->zpp_inner->maxdist;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Ray_obj,set_maxDistance,return )

 ::nape::geom::AABB Ray_obj::aabb(){
            	HX_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_296_aabb)
HXDLIN( 296)		return this->zpp_inner->rayAABB()->wrapper();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray_obj,aabb,return )

 ::nape::geom::Vec2 Ray_obj::at(Float distance,hx::Null< bool >  __o_weak){
            		bool weak = __o_weak.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_313_at)
HXLINE( 314)		this->zpp_inner->validate_dir();
HXLINE( 315)		 ::nape::geom::Vec2 _this = this->zpp_inner->origin;
HXDLIN( 315)		bool x;
HXDLIN( 315)		if (hx::IsNotNull( _this )) {
HXLINE( 315)			x = _this->zpp_disp;
            		}
            		else {
HXLINE( 315)			x = false;
            		}
HXDLIN( 315)		if (x) {
HXLINE( 315)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN( 315)		{
HXLINE( 315)			 ::zpp_nape::geom::ZPP_Vec2 _this1 = _this->zpp_inner;
HXDLIN( 315)			if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 315)				_this1->_validate();
            			}
            		}
HXDLIN( 315)		Float x1 = (_this->zpp_inner->x + (distance * this->zpp_inner->dirx));
HXDLIN( 315)		 ::nape::geom::Vec2 _this2 = this->zpp_inner->origin;
HXDLIN( 315)		bool y;
HXDLIN( 315)		if (hx::IsNotNull( _this2 )) {
HXLINE( 315)			y = _this2->zpp_disp;
            		}
            		else {
HXLINE( 315)			y = false;
            		}
HXDLIN( 315)		if (y) {
HXLINE( 315)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN( 315)		{
HXLINE( 315)			 ::zpp_nape::geom::ZPP_Vec2 _this3 = _this2->zpp_inner;
HXDLIN( 315)			if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 315)				_this3->_validate();
            			}
            		}
HXDLIN( 315)		Float y1 = (_this2->zpp_inner->y + (distance * this->zpp_inner->diry));
HXDLIN( 315)		bool _hx_tmp;
HXDLIN( 315)		if ((x1 == x1)) {
HXLINE( 315)			_hx_tmp = (y1 != y1);
            		}
            		else {
HXLINE( 315)			_hx_tmp = true;
            		}
HXDLIN( 315)		if (_hx_tmp) {
HXLINE( 315)			HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            		}
HXDLIN( 315)		 ::nape::geom::Vec2 ret;
HXDLIN( 315)		if (hx::IsNull( ::zpp_nape::util::ZPP_PubPool_obj::poolVec2 )) {
HXLINE( 315)			ret =  ::nape::geom::Vec2_obj::__alloc( HX_CTX ,null(),null());
            		}
            		else {
HXLINE( 315)			ret = ::zpp_nape::util::ZPP_PubPool_obj::poolVec2;
HXDLIN( 315)			::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = ret->zpp_pool;
HXDLIN( 315)			ret->zpp_pool = null();
HXDLIN( 315)			ret->zpp_disp = false;
HXDLIN( 315)			if (hx::IsEq( ret,::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 315)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = null();
            			}
            		}
HXDLIN( 315)		if (hx::IsNull( ret->zpp_inner )) {
HXLINE( 315)			 ::zpp_nape::geom::ZPP_Vec2 ret1;
HXDLIN( 315)			{
HXLINE( 315)				if (hx::IsNull( ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool )) {
HXLINE( 315)					ret1 =  ::zpp_nape::geom::ZPP_Vec2_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 315)					ret1 = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 315)					::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = ret1->next;
HXDLIN( 315)					ret1->next = null();
            				}
HXDLIN( 315)				ret1->weak = false;
            			}
HXDLIN( 315)			ret1->_immutable = false;
HXDLIN( 315)			{
HXLINE( 315)				ret1->x = x1;
HXDLIN( 315)				ret1->y = y1;
            			}
HXDLIN( 315)			ret->zpp_inner = ret1;
HXDLIN( 315)			ret->zpp_inner->outer = ret;
            		}
            		else {
HXLINE( 315)			bool _hx_tmp1;
HXDLIN( 315)			if (hx::IsNotNull( ret )) {
HXLINE( 315)				_hx_tmp1 = ret->zpp_disp;
            			}
            			else {
HXLINE( 315)				_hx_tmp1 = false;
            			}
HXDLIN( 315)			if (_hx_tmp1) {
HXLINE( 315)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 315)			{
HXLINE( 315)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = ret->zpp_inner;
HXDLIN( 315)				if (_this4->_immutable) {
HXLINE( 315)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 315)				if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 315)					_this4->_isimmutable();
            				}
            			}
HXDLIN( 315)			bool _hx_tmp2;
HXDLIN( 315)			if ((x1 == x1)) {
HXLINE( 315)				_hx_tmp2 = (y1 != y1);
            			}
            			else {
HXLINE( 315)				_hx_tmp2 = true;
            			}
HXDLIN( 315)			if (_hx_tmp2) {
HXLINE( 315)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN( 315)			bool _hx_tmp3;
HXDLIN( 315)			bool _hx_tmp4;
HXDLIN( 315)			if (hx::IsNotNull( ret )) {
HXLINE( 315)				_hx_tmp4 = ret->zpp_disp;
            			}
            			else {
HXLINE( 315)				_hx_tmp4 = false;
            			}
HXDLIN( 315)			if (_hx_tmp4) {
HXLINE( 315)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 315)			{
HXLINE( 315)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = ret->zpp_inner;
HXDLIN( 315)				if (hx::IsNotNull( _this5->_validate )) {
HXLINE( 315)					_this5->_validate();
            				}
            			}
HXDLIN( 315)			if ((ret->zpp_inner->x == x1)) {
HXLINE( 315)				bool _hx_tmp5;
HXDLIN( 315)				if (hx::IsNotNull( ret )) {
HXLINE( 315)					_hx_tmp5 = ret->zpp_disp;
            				}
            				else {
HXLINE( 315)					_hx_tmp5 = false;
            				}
HXDLIN( 315)				if (_hx_tmp5) {
HXLINE( 315)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN( 315)				{
HXLINE( 315)					 ::zpp_nape::geom::ZPP_Vec2 _this6 = ret->zpp_inner;
HXDLIN( 315)					if (hx::IsNotNull( _this6->_validate )) {
HXLINE( 315)						_this6->_validate();
            					}
            				}
HXDLIN( 315)				_hx_tmp3 = (ret->zpp_inner->y == y1);
            			}
            			else {
HXLINE( 315)				_hx_tmp3 = false;
            			}
HXDLIN( 315)			if (!(_hx_tmp3)) {
HXLINE( 315)				{
HXLINE( 315)					ret->zpp_inner->x = x1;
HXDLIN( 315)					ret->zpp_inner->y = y1;
            				}
HXDLIN( 315)				{
HXLINE( 315)					 ::zpp_nape::geom::ZPP_Vec2 _this7 = ret->zpp_inner;
HXDLIN( 315)					if (hx::IsNotNull( _this7->_invalidate )) {
HXLINE( 315)						_this7->_invalidate(_this7);
            					}
            				}
            			}
            		}
HXDLIN( 315)		ret->zpp_inner->weak = weak;
HXDLIN( 315)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Ray_obj,at,return )

 ::nape::geom::Ray Ray_obj::copy(){
            	HX_GC_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_350_copy)
HXLINE( 351)		 ::nape::geom::Ray ret =  ::nape::geom::Ray_obj::__alloc( HX_CTX ,this->zpp_inner->origin,this->zpp_inner->direction);
HXLINE( 352)		{
HXLINE( 352)			Float maxDistance = this->zpp_inner->maxdist;
HXDLIN( 352)			{
HXLINE( 352)				if ((maxDistance != maxDistance)) {
HXLINE( 352)					HX_STACK_DO_THROW(HX_("Error: maxDistance cannot be NaN",c6,98,5d,73));
            				}
HXDLIN( 352)				ret->zpp_inner->maxdist = maxDistance;
            			}
            		}
HXLINE( 353)		return ret;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Ray_obj,copy,return )

 ::nape::geom::Ray Ray_obj::fromSegment( ::nape::geom::Vec2 start, ::nape::geom::Vec2 end){
            	HX_GC_STACKFRAME(&_hx_pos_4f8965e3d8a05fef_370_fromSegment)
HXLINE( 373)		bool _hx_tmp;
HXDLIN( 373)		if (hx::IsNotNull( start )) {
HXLINE( 373)			_hx_tmp = start->zpp_disp;
            		}
            		else {
HXLINE( 373)			_hx_tmp = false;
            		}
HXDLIN( 373)		if (_hx_tmp) {
HXLINE( 373)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 378)		bool _hx_tmp1;
HXDLIN( 378)		if (hx::IsNotNull( end )) {
HXLINE( 378)			_hx_tmp1 = end->zpp_disp;
            		}
            		else {
HXLINE( 378)			_hx_tmp1 = false;
            		}
HXDLIN( 378)		if (_hx_tmp1) {
HXLINE( 378)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXLINE( 382)		if (hx::IsNull( start )) {
HXLINE( 383)			HX_STACK_DO_THROW(HX_("Error: Ray::fromSegment::start is null",b2,3b,5c,c0));
            		}
HXLINE( 385)		if (hx::IsNull( end )) {
HXLINE( 386)			HX_STACK_DO_THROW(HX_("Error: Ray::fromSegment::end is null",6b,b9,71,94));
            		}
HXLINE( 389)		 ::nape::geom::Vec2 dir = end->sub(start,true);
HXLINE( 390)		 ::nape::geom::Ray ret =  ::nape::geom::Ray_obj::__alloc( HX_CTX ,start,dir);
HXLINE( 391)		{
HXLINE( 391)			bool maxDistance;
HXDLIN( 391)			if (hx::IsNotNull( start )) {
HXLINE( 391)				maxDistance = start->zpp_disp;
            			}
            			else {
HXLINE( 391)				maxDistance = false;
            			}
HXDLIN( 391)			if (maxDistance) {
HXLINE( 391)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 391)			{
HXLINE( 391)				 ::zpp_nape::geom::ZPP_Vec2 _this = start->zpp_inner;
HXDLIN( 391)				if (hx::IsNotNull( _this->_validate )) {
HXLINE( 391)					_this->_validate();
            				}
            			}
HXDLIN( 391)			Float ax = start->zpp_inner->x;
HXDLIN( 391)			bool maxDistance1;
HXDLIN( 391)			if (hx::IsNotNull( start )) {
HXLINE( 391)				maxDistance1 = start->zpp_disp;
            			}
            			else {
HXLINE( 391)				maxDistance1 = false;
            			}
HXDLIN( 391)			if (maxDistance1) {
HXLINE( 391)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 391)			{
HXLINE( 391)				 ::zpp_nape::geom::ZPP_Vec2 _this1 = start->zpp_inner;
HXDLIN( 391)				if (hx::IsNotNull( _this1->_validate )) {
HXLINE( 391)					_this1->_validate();
            				}
            			}
HXDLIN( 391)			Float ay = start->zpp_inner->y;
HXDLIN( 391)			bool maxDistance2;
HXDLIN( 391)			if (hx::IsNotNull( end )) {
HXLINE( 391)				maxDistance2 = end->zpp_disp;
            			}
            			else {
HXLINE( 391)				maxDistance2 = false;
            			}
HXDLIN( 391)			if (maxDistance2) {
HXLINE( 391)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 391)			{
HXLINE( 391)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = end->zpp_inner;
HXDLIN( 391)				if (hx::IsNotNull( _this2->_validate )) {
HXLINE( 391)					_this2->_validate();
            				}
            			}
HXDLIN( 391)			Float bx = end->zpp_inner->x;
HXDLIN( 391)			bool maxDistance3;
HXDLIN( 391)			if (hx::IsNotNull( end )) {
HXLINE( 391)				maxDistance3 = end->zpp_disp;
            			}
            			else {
HXLINE( 391)				maxDistance3 = false;
            			}
HXDLIN( 391)			if (maxDistance3) {
HXLINE( 391)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 391)			{
HXLINE( 391)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = end->zpp_inner;
HXDLIN( 391)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE( 391)					_this3->_validate();
            				}
            			}
HXDLIN( 391)			Float dx = ((Float)0.0);
HXDLIN( 391)			Float dy = ((Float)0.0);
HXDLIN( 391)			{
HXLINE( 391)				dx = (ax - bx);
HXDLIN( 391)				dy = (ay - end->zpp_inner->y);
            			}
HXDLIN( 391)			Float maxDistance4 = ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
HXDLIN( 391)			{
HXLINE( 391)				if ((maxDistance4 != maxDistance4)) {
HXLINE( 391)					HX_STACK_DO_THROW(HX_("Error: maxDistance cannot be NaN",c6,98,5d,73));
            				}
HXDLIN( 391)				ret->zpp_inner->maxdist = maxDistance4;
            			}
            		}
HXLINE( 392)		if (start->zpp_inner->weak) {
HXLINE( 396)			bool _hx_tmp2;
HXDLIN( 396)			if (hx::IsNotNull( start )) {
HXLINE( 396)				_hx_tmp2 = start->zpp_disp;
            			}
            			else {
HXLINE( 396)				_hx_tmp2 = false;
            			}
HXDLIN( 396)			if (_hx_tmp2) {
HXLINE( 396)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 396)			{
HXLINE( 396)				 ::zpp_nape::geom::ZPP_Vec2 _this4 = start->zpp_inner;
HXDLIN( 396)				if (_this4->_immutable) {
HXLINE( 396)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 396)				if (hx::IsNotNull( _this4->_isimmutable )) {
HXLINE( 396)					_this4->_isimmutable();
            				}
            			}
HXDLIN( 396)			if (start->zpp_inner->_inuse) {
HXLINE( 396)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 396)			 ::zpp_nape::geom::ZPP_Vec2 inner = start->zpp_inner;
HXDLIN( 396)			start->zpp_inner->outer = null();
HXDLIN( 396)			start->zpp_inner = null();
HXDLIN( 396)			{
HXLINE( 396)				 ::nape::geom::Vec2 o = start;
HXDLIN( 396)				o->zpp_pool = null();
HXDLIN( 396)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 396)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o;
            				}
            				else {
HXLINE( 396)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o;
            				}
HXDLIN( 396)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o;
HXDLIN( 396)				o->zpp_disp = true;
            			}
HXDLIN( 396)			{
HXLINE( 396)				 ::zpp_nape::geom::ZPP_Vec2 o1 = inner;
HXDLIN( 396)				{
HXLINE( 396)					if (hx::IsNotNull( o1->outer )) {
HXLINE( 396)						o1->outer->zpp_inner = null();
HXDLIN( 396)						o1->outer = null();
            					}
HXDLIN( 396)					o1->_isimmutable = null();
HXDLIN( 396)					o1->_validate = null();
HXDLIN( 396)					o1->_invalidate = null();
            				}
HXDLIN( 396)				o1->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 396)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o1;
            			}
            		}
HXLINE( 403)		if (end->zpp_inner->weak) {
HXLINE( 407)			bool _hx_tmp3;
HXDLIN( 407)			if (hx::IsNotNull( end )) {
HXLINE( 407)				_hx_tmp3 = end->zpp_disp;
            			}
            			else {
HXLINE( 407)				_hx_tmp3 = false;
            			}
HXDLIN( 407)			if (_hx_tmp3) {
HXLINE( 407)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN( 407)			{
HXLINE( 407)				 ::zpp_nape::geom::ZPP_Vec2 _this5 = end->zpp_inner;
HXDLIN( 407)				if (_this5->_immutable) {
HXLINE( 407)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN( 407)				if (hx::IsNotNull( _this5->_isimmutable )) {
HXLINE( 407)					_this5->_isimmutable();
            				}
            			}
HXDLIN( 407)			if (end->zpp_inner->_inuse) {
HXLINE( 407)				HX_STACK_DO_THROW(HX_("Error: This Vec2 is not disposable",b5,d1,d1,d8));
            			}
HXDLIN( 407)			 ::zpp_nape::geom::ZPP_Vec2 inner1 = end->zpp_inner;
HXDLIN( 407)			end->zpp_inner->outer = null();
HXDLIN( 407)			end->zpp_inner = null();
HXDLIN( 407)			{
HXLINE( 407)				 ::nape::geom::Vec2 o2 = end;
HXDLIN( 407)				o2->zpp_pool = null();
HXDLIN( 407)				if (hx::IsNotNull( ::zpp_nape::util::ZPP_PubPool_obj::nextVec2 )) {
HXLINE( 407)					::zpp_nape::util::ZPP_PubPool_obj::nextVec2->zpp_pool = o2;
            				}
            				else {
HXLINE( 407)					::zpp_nape::util::ZPP_PubPool_obj::poolVec2 = o2;
            				}
HXDLIN( 407)				::zpp_nape::util::ZPP_PubPool_obj::nextVec2 = o2;
HXDLIN( 407)				o2->zpp_disp = true;
            			}
HXDLIN( 407)			{
HXLINE( 407)				 ::zpp_nape::geom::ZPP_Vec2 o3 = inner1;
HXDLIN( 407)				{
HXLINE( 407)					if (hx::IsNotNull( o3->outer )) {
HXLINE( 407)						o3->outer->zpp_inner = null();
HXDLIN( 407)						o3->outer = null();
            					}
HXDLIN( 407)					o3->_isimmutable = null();
HXDLIN( 407)					o3->_validate = null();
HXDLIN( 407)					o3->_invalidate = null();
            				}
HXDLIN( 407)				o3->next = ::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool;
HXDLIN( 407)				::zpp_nape::geom::ZPP_Vec2_obj::zpp_pool = o3;
            			}
            		}
HXLINE( 414)		return ret;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Ray_obj,fromSegment,return )


hx::ObjectPtr< Ray_obj > Ray_obj::__new( ::nape::geom::Vec2 origin, ::nape::geom::Vec2 direction) {
	hx::ObjectPtr< Ray_obj > __this = new Ray_obj();
	__this->__construct(origin,direction);
	return __this;
}

hx::ObjectPtr< Ray_obj > Ray_obj::__alloc(hx::Ctx *_hx_ctx, ::nape::geom::Vec2 origin, ::nape::geom::Vec2 direction) {
	Ray_obj *__this = (Ray_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Ray_obj), true, "nape.geom.Ray"));
	*(void **)__this = Ray_obj::_hx_vtable;
	__this->__construct(origin,direction);
	return __this;
}

Ray_obj::Ray_obj()
{
}

void Ray_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Ray);
	HX_MARK_MEMBER_NAME(zpp_inner,"zpp_inner");
	HX_MARK_END_CLASS();
}

void Ray_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(zpp_inner,"zpp_inner");
}

hx::Val Ray_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"at") ) { return hx::Val( at_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"aabb") ) { return hx::Val( aabb_dyn() ); }
		if (HX_FIELD_EQ(inName,"copy") ) { return hx::Val( copy_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"origin") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_origin() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"userData") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_userData() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { return hx::Val( zpp_inner ); }
		if (HX_FIELD_EQ(inName,"direction") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_direction() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"get_origin") ) { return hx::Val( get_origin_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_origin") ) { return hx::Val( set_origin_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"maxDistance") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_maxDistance() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"get_userData") ) { return hx::Val( get_userData_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"get_direction") ) { return hx::Val( get_direction_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_direction") ) { return hx::Val( set_direction_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"get_maxDistance") ) { return hx::Val( get_maxDistance_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_maxDistance") ) { return hx::Val( set_maxDistance_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Ray_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"fromSegment") ) { outValue = fromSegment_dyn(); return true; }
	}
	return false;
}

hx::Val Ray_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"origin") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_origin(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"zpp_inner") ) { zpp_inner=inValue.Cast<  ::zpp_nape::geom::ZPP_Ray >(); return inValue; }
		if (HX_FIELD_EQ(inName,"direction") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_direction(inValue.Cast<  ::nape::geom::Vec2 >()) ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"maxDistance") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_maxDistance(inValue.Cast< Float >()) ); }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Ray_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("zpp_inner",51,65,85,78));
	outFields->push(HX_("userData",15,96,28,05));
	outFields->push(HX_("origin",e6,19,01,4b));
	outFields->push(HX_("direction",3f,62,40,10));
	outFields->push(HX_("maxDistance",f9,9d,bf,e1));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Ray_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::zpp_nape::geom::ZPP_Ray */ ,(int)offsetof(Ray_obj,zpp_inner),HX_("zpp_inner",51,65,85,78)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Ray_obj_sStaticStorageInfo = 0;
#endif

static ::String Ray_obj_sMemberFields[] = {
	HX_("zpp_inner",51,65,85,78),
	HX_("get_userData",1e,4a,42,ba),
	HX_("get_origin",af,89,88,3b),
	HX_("set_origin",23,28,06,3f),
	HX_("get_direction",16,36,a4,d1),
	HX_("set_direction",22,18,aa,16),
	HX_("get_maxDistance",90,55,a1,a2),
	HX_("set_maxDistance",9c,d2,6c,9e),
	HX_("aabb",a0,a2,67,40),
	HX_("at",f3,54,00,00),
	HX_("copy",b5,bb,c4,41),
	::String(null()) };

hx::Class Ray_obj::__mClass;

static ::String Ray_obj_sStaticFields[] = {
	HX_("fromSegment",69,33,0f,3f),
	::String(null())
};

void Ray_obj::__register()
{
	Ray_obj _hx_dummy;
	Ray_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("nape.geom.Ray",5e,f7,83,b6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Ray_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Ray_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Ray_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Ray_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Ray_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Ray_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace nape
} // end namespace geom
