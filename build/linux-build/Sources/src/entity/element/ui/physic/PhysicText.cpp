// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_entity_element_Entity
#include <hxinc/entity/element/Entity.h>
#endif
#ifndef INCLUDED_entity_element_IEntity
#include <hxinc/entity/element/IEntity.h>
#endif
#ifndef INCLUDED_entity_element_ui_physic_PhysicText
#include <hxinc/entity/element/ui/physic/PhysicText.h>
#endif
#ifndef INCLUDED_entity_element_ui_physic_PhysicUI
#include <hxinc/entity/element/ui/physic/PhysicUI.h>
#endif
#ifndef INCLUDED_kha_graphics2_Graphics
#include <hxinc/kha/graphics2/Graphics.h>
#endif
#ifndef INCLUDED_kha_math_FastMatrix3
#include <hxinc/kha/math/FastMatrix3.h>
#endif
#ifndef INCLUDED_nape_dynamics_InteractionFilter
#include <hxinc/nape/dynamics/InteractionFilter.h>
#endif
#ifndef INCLUDED_nape_geom_Vec2
#include <hxinc/nape/geom/Vec2.h>
#endif
#ifndef INCLUDED_nape_phys_Body
#include <hxinc/nape/phys/Body.h>
#endif
#ifndef INCLUDED_nape_phys_BodyList
#include <hxinc/nape/phys/BodyList.h>
#endif
#ifndef INCLUDED_nape_phys_BodyType
#include <hxinc/nape/phys/BodyType.h>
#endif
#ifndef INCLUDED_nape_phys_Interactor
#include <hxinc/nape/phys/Interactor.h>
#endif
#ifndef INCLUDED_nape_phys_Material
#include <hxinc/nape/phys/Material.h>
#endif
#ifndef INCLUDED_nape_shape_Polygon
#include <hxinc/nape/shape/Polygon.h>
#endif
#ifndef INCLUDED_nape_shape_Shape
#include <hxinc/nape/shape/Shape.h>
#endif
#ifndef INCLUDED_nape_shape_ShapeList
#include <hxinc/nape/shape/ShapeList.h>
#endif
#ifndef INCLUDED_nape_space_Space
#include <hxinc/nape/space/Space.h>
#endif
#ifndef INCLUDED_zpp_nape_geom_ZPP_Vec2
#include <hxinc/zpp_nape/geom/ZPP_Vec2.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Body
#include <hxinc/zpp_nape/phys/ZPP_Body.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Compound
#include <hxinc/zpp_nape/phys/ZPP_Compound.h>
#endif
#ifndef INCLUDED_zpp_nape_phys_ZPP_Interactor
#include <hxinc/zpp_nape/phys/ZPP_Interactor.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Component
#include <hxinc/zpp_nape/space/ZPP_Component.h>
#endif
#ifndef INCLUDED_zpp_nape_space_ZPP_Space
#include <hxinc/zpp_nape/space/ZPP_Space.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_BodyList
#include <hxinc/zpp_nape/util/ZPP_BodyList.h>
#endif
#ifndef INCLUDED_zpp_nape_util_ZPP_ShapeList
#include <hxinc/zpp_nape/util/ZPP_ShapeList.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_08700a0760c392ba_17_new,"entity.element.ui.physic.PhysicText","new",0x3eb30090,"entity.element.ui.physic.PhysicText.new","entity/element/ui/physic/PhysicText.hx",17,0x723871fe)
HX_LOCAL_STACK_FRAME(_hx_pos_08700a0760c392ba_38_draw,"entity.element.ui.physic.PhysicText","draw",0x975b25d4,"entity.element.ui.physic.PhysicText.draw","entity/element/ui/physic/PhysicText.hx",38,0x723871fe)
HX_LOCAL_STACK_FRAME(_hx_pos_08700a0760c392ba_47_update,"entity.element.ui.physic.PhysicText","update",0x27fe93d9,"entity.element.ui.physic.PhysicText.update","entity/element/ui/physic/PhysicText.hx",47,0x723871fe)
namespace entity{
namespace element{
namespace ui{
namespace physic{

void PhysicText_obj::__construct(Float x,Float y,::String __o_text,hx::Null< int >  __o_size, ::Dynamic width){
            		::String text = __o_text;
            		if (hx::IsNull(__o_text)) text = HX_("",00,00,00,00);
            		int size = __o_size.Default(12);
            	HX_GC_STACKFRAME(&_hx_pos_08700a0760c392ba_17_new)
HXLINE(  18)		super::__construct(x,y);
HXLINE(  20)		this->body =  ::nape::phys::Body_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  21)		{
HXLINE(  21)			 ::nape::phys::Body _this = this->body;
HXDLIN(  21)			if (hx::IsNull( _this->zpp_inner->wrap_pos )) {
HXLINE(  21)				_this->zpp_inner->setupPosition();
            			}
HXDLIN(  21)			 ::nape::geom::Vec2 _this1 = _this->zpp_inner->wrap_pos;
HXDLIN(  21)			bool _hx_tmp;
HXDLIN(  21)			if (hx::IsNotNull( _this1 )) {
HXLINE(  21)				_hx_tmp = _this1->zpp_disp;
            			}
            			else {
HXLINE(  21)				_hx_tmp = false;
            			}
HXDLIN(  21)			if (_hx_tmp) {
HXLINE(  21)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(  21)			{
HXLINE(  21)				 ::zpp_nape::geom::ZPP_Vec2 _this2 = _this1->zpp_inner;
HXDLIN(  21)				if (_this2->_immutable) {
HXLINE(  21)					HX_STACK_DO_THROW(HX_("Error: Vec2 is immutable",60,ee,1f,bc));
            				}
HXDLIN(  21)				if (hx::IsNotNull( _this2->_isimmutable )) {
HXLINE(  21)					_this2->_isimmutable();
            				}
            			}
HXDLIN(  21)			bool _hx_tmp1;
HXDLIN(  21)			if ((x == x)) {
HXLINE(  21)				_hx_tmp1 = (y != y);
            			}
            			else {
HXLINE(  21)				_hx_tmp1 = true;
            			}
HXDLIN(  21)			if (_hx_tmp1) {
HXLINE(  21)				HX_STACK_DO_THROW(HX_("Error: Vec2 components cannot be NaN",85,ba,d8,c1));
            			}
HXDLIN(  21)			bool _hx_tmp2;
HXDLIN(  21)			bool _hx_tmp3;
HXDLIN(  21)			if (hx::IsNotNull( _this1 )) {
HXLINE(  21)				_hx_tmp3 = _this1->zpp_disp;
            			}
            			else {
HXLINE(  21)				_hx_tmp3 = false;
            			}
HXDLIN(  21)			if (_hx_tmp3) {
HXLINE(  21)				HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            			}
HXDLIN(  21)			{
HXLINE(  21)				 ::zpp_nape::geom::ZPP_Vec2 _this3 = _this1->zpp_inner;
HXDLIN(  21)				if (hx::IsNotNull( _this3->_validate )) {
HXLINE(  21)					_this3->_validate();
            				}
            			}
HXDLIN(  21)			if ((_this1->zpp_inner->x == x)) {
HXLINE(  21)				bool _hx_tmp4;
HXDLIN(  21)				if (hx::IsNotNull( _this1 )) {
HXLINE(  21)					_hx_tmp4 = _this1->zpp_disp;
            				}
            				else {
HXLINE(  21)					_hx_tmp4 = false;
            				}
HXDLIN(  21)				if (_hx_tmp4) {
HXLINE(  21)					HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            				}
HXDLIN(  21)				{
HXLINE(  21)					 ::zpp_nape::geom::ZPP_Vec2 _this4 = _this1->zpp_inner;
HXDLIN(  21)					if (hx::IsNotNull( _this4->_validate )) {
HXLINE(  21)						_this4->_validate();
            					}
            				}
HXDLIN(  21)				_hx_tmp2 = (_this1->zpp_inner->y == y);
            			}
            			else {
HXLINE(  21)				_hx_tmp2 = false;
            			}
HXDLIN(  21)			if (!(_hx_tmp2)) {
HXLINE(  21)				{
HXLINE(  21)					_this1->zpp_inner->x = x;
HXDLIN(  21)					_this1->zpp_inner->y = y;
            				}
HXDLIN(  21)				{
HXLINE(  21)					 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this1->zpp_inner;
HXDLIN(  21)					if (hx::IsNotNull( _this5->_invalidate )) {
HXLINE(  21)						_this5->_invalidate(_this5);
            					}
            				}
            			}
            		}
HXLINE(  22)		this->text = text;
HXLINE(  23)		this->size = size;
HXLINE(  24)		this->height = ( (Float)(size) );
HXLINE(  26)		if (hx::IsNotNull( width )) {
HXLINE(  27)			this->risizeble = false;
HXLINE(  28)			this->width = ( (Float)(width) );
            		}
            		else {
HXLINE(  30)			this->width = ( (Float)((text.length + (3 * size))) );
            		}
HXLINE(  33)		{
HXLINE(  33)			 ::nape::shape::ShapeList _this6 = this->body->zpp_inner->wrap_shapes;
HXDLIN(  33)			 ::nape::shape::Shape obj =  ::nape::shape::Polygon_obj::__alloc( HX_CTX ,::nape::shape::Polygon_obj::rect(x,y,this->width,this->height,null()),null(),null());
HXDLIN(  33)			if (_this6->zpp_inner->reverse_flag) {
HXLINE(  33)				_this6->push(obj);
            			}
            			else {
HXLINE(  33)				_this6->unshift(obj);
            			}
            		}
HXLINE(  34)		{
HXLINE(  34)			 ::nape::phys::Body _this7 = this->body;
HXDLIN(  34)			 ::nape::space::Space space = this->space;
HXDLIN(  34)			{
HXLINE(  34)				if (hx::IsNotNull( _this7->zpp_inner->compound )) {
HXLINE(  34)					HX_STACK_DO_THROW(HX_("Error: Cannot set the space of a Body belonging to a Compound, only the root Compound space can be set",2f,88,46,ff));
            				}
HXDLIN(  34)				_this7->zpp_inner->immutable_midstep(HX_("Body::space",84,f7,bc,26));
HXDLIN(  34)				if (_this7->zpp_inner->world) {
HXLINE(  34)					HX_STACK_DO_THROW(HX_("Error: Space::world is immutable",72,0f,57,56));
            				}
HXDLIN(  34)				 ::nape::space::Space _hx_tmp5;
HXDLIN(  34)				if (hx::IsNull( _this7->zpp_inner->space )) {
HXLINE(  34)					_hx_tmp5 = null();
            				}
            				else {
HXLINE(  34)					_hx_tmp5 = _this7->zpp_inner->space->outer;
            				}
HXDLIN(  34)				if (hx::IsNotEq( _hx_tmp5,space )) {
HXLINE(  34)					 ::nape::space::Space _hx_tmp6;
HXDLIN(  34)					if (hx::IsNull( _this7->zpp_inner->space )) {
HXLINE(  34)						_hx_tmp6 = null();
            					}
            					else {
HXLINE(  34)						_hx_tmp6 = _this7->zpp_inner->space->outer;
            					}
HXDLIN(  34)					if (hx::IsNotNull( _hx_tmp6 )) {
HXLINE(  34)						_this7->zpp_inner->component->woken = false;
            					}
HXDLIN(  34)					 ::nape::space::Space _hx_tmp7;
HXDLIN(  34)					if (hx::IsNull( _this7->zpp_inner->space )) {
HXLINE(  34)						_hx_tmp7 = null();
            					}
            					else {
HXLINE(  34)						_hx_tmp7 = _this7->zpp_inner->space->outer;
            					}
HXDLIN(  34)					if (hx::IsNotNull( _hx_tmp7 )) {
HXLINE(  34)						 ::nape::space::Space _hx_tmp8;
HXDLIN(  34)						if (hx::IsNull( _this7->zpp_inner->space )) {
HXLINE(  34)							_hx_tmp8 = null();
            						}
            						else {
HXLINE(  34)							_hx_tmp8 = _this7->zpp_inner->space->outer;
            						}
HXDLIN(  34)						_hx_tmp8->zpp_inner->wrap_bodies->remove(_this7);
            					}
HXDLIN(  34)					if (hx::IsNotNull( space )) {
HXLINE(  34)						 ::nape::phys::BodyList _this8 = space->zpp_inner->wrap_bodies;
HXDLIN(  34)						if (_this8->zpp_inner->reverse_flag) {
HXLINE(  34)							_this8->push(_this7);
            						}
            						else {
HXLINE(  34)							_this8->unshift(_this7);
            						}
            					}
            				}
            			}
HXDLIN(  34)			bool _hx_tmp9 = hx::IsNull( _this7->zpp_inner->space );
            		}
            	}

Dynamic PhysicText_obj::__CreateEmpty() { return new PhysicText_obj; }

void *PhysicText_obj::_hx_vtable = 0;

Dynamic PhysicText_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< PhysicText_obj > _hx_result = new PhysicText_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool PhysicText_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2e1ea9d1) {
		if (inClassId<=(int)0x213075a6) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x213075a6;
		} else {
			return inClassId==(int)0x2e1ea9d1;
		}
	} else {
		return inClassId==(int)0x49e62f7c;
	}
}

void PhysicText_obj::draw( ::kha::graphics2::Graphics gr){
            	HX_STACKFRAME(&_hx_pos_08700a0760c392ba_38_draw)
HXLINE(  39)		Float _hx_tmp = this->body->zpp_inner->rot;
HXDLIN(  39)		 ::nape::phys::Body _this = this->body;
HXDLIN(  39)		if (hx::IsNull( _this->zpp_inner->wrap_pos )) {
HXLINE(  39)			_this->zpp_inner->setupPosition();
            		}
HXDLIN(  39)		 ::nape::geom::Vec2 _this1 = _this->zpp_inner->wrap_pos;
HXDLIN(  39)		bool _hx_tmp1;
HXDLIN(  39)		if (hx::IsNotNull( _this1 )) {
HXLINE(  39)			_hx_tmp1 = _this1->zpp_disp;
            		}
            		else {
HXLINE(  39)			_hx_tmp1 = false;
            		}
HXDLIN(  39)		if (_hx_tmp1) {
HXLINE(  39)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(  39)		{
HXLINE(  39)			 ::zpp_nape::geom::ZPP_Vec2 _this2 = _this1->zpp_inner;
HXDLIN(  39)			if (hx::IsNotNull( _this2->_validate )) {
HXLINE(  39)				_this2->_validate();
            			}
            		}
HXDLIN(  39)		Float _hx_tmp2 = _this1->zpp_inner->x;
HXDLIN(  39)		 ::nape::phys::Body _this3 = this->body;
HXDLIN(  39)		if (hx::IsNull( _this3->zpp_inner->wrap_pos )) {
HXLINE(  39)			_this3->zpp_inner->setupPosition();
            		}
HXDLIN(  39)		 ::nape::geom::Vec2 _this4 = _this3->zpp_inner->wrap_pos;
HXDLIN(  39)		bool _hx_tmp3;
HXDLIN(  39)		if (hx::IsNotNull( _this4 )) {
HXLINE(  39)			_hx_tmp3 = _this4->zpp_disp;
            		}
            		else {
HXLINE(  39)			_hx_tmp3 = false;
            		}
HXDLIN(  39)		if (_hx_tmp3) {
HXLINE(  39)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(  39)		{
HXLINE(  39)			 ::zpp_nape::geom::ZPP_Vec2 _this5 = _this4->zpp_inner;
HXDLIN(  39)			if (hx::IsNotNull( _this5->_validate )) {
HXLINE(  39)				_this5->_validate();
            			}
            		}
HXDLIN(  39)		gr->pushRotation(( (float)(_hx_tmp) ),( (float)(_hx_tmp2) ),( (float)(_this4->zpp_inner->y) ));
HXLINE(  40)		gr->set_fontSize(this->size);
HXLINE(  41)		::String _hx_tmp4 = this->text;
HXDLIN(  41)		 ::nape::phys::Body _this6 = this->body;
HXDLIN(  41)		if (hx::IsNull( _this6->zpp_inner->wrap_pos )) {
HXLINE(  41)			_this6->zpp_inner->setupPosition();
            		}
HXDLIN(  41)		 ::nape::geom::Vec2 _this7 = _this6->zpp_inner->wrap_pos;
HXDLIN(  41)		bool _hx_tmp5;
HXDLIN(  41)		if (hx::IsNotNull( _this7 )) {
HXLINE(  41)			_hx_tmp5 = _this7->zpp_disp;
            		}
            		else {
HXLINE(  41)			_hx_tmp5 = false;
            		}
HXDLIN(  41)		if (_hx_tmp5) {
HXLINE(  41)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(  41)		{
HXLINE(  41)			 ::zpp_nape::geom::ZPP_Vec2 _this8 = _this7->zpp_inner;
HXDLIN(  41)			if (hx::IsNotNull( _this8->_validate )) {
HXLINE(  41)				_this8->_validate();
            			}
            		}
HXDLIN(  41)		Float _hx_tmp6 = _this7->zpp_inner->x;
HXDLIN(  41)		 ::nape::phys::Body _this9 = this->body;
HXDLIN(  41)		if (hx::IsNull( _this9->zpp_inner->wrap_pos )) {
HXLINE(  41)			_this9->zpp_inner->setupPosition();
            		}
HXDLIN(  41)		 ::nape::geom::Vec2 _this10 = _this9->zpp_inner->wrap_pos;
HXDLIN(  41)		bool _hx_tmp7;
HXDLIN(  41)		if (hx::IsNotNull( _this10 )) {
HXLINE(  41)			_hx_tmp7 = _this10->zpp_disp;
            		}
            		else {
HXLINE(  41)			_hx_tmp7 = false;
            		}
HXDLIN(  41)		if (_hx_tmp7) {
HXLINE(  41)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(  41)		{
HXLINE(  41)			 ::zpp_nape::geom::ZPP_Vec2 _this11 = _this10->zpp_inner;
HXDLIN(  41)			if (hx::IsNotNull( _this11->_validate )) {
HXLINE(  41)				_this11->_validate();
            			}
            		}
HXDLIN(  41)		gr->drawString(_hx_tmp4,_hx_tmp6,_this10->zpp_inner->y);
HXLINE(  43)		 ::nape::phys::Body _this12 = this->body;
HXDLIN(  43)		if (hx::IsNull( _this12->zpp_inner->wrap_pos )) {
HXLINE(  43)			_this12->zpp_inner->setupPosition();
            		}
HXDLIN(  43)		 ::nape::geom::Vec2 _this13 = _this12->zpp_inner->wrap_pos;
HXDLIN(  43)		bool _hx_tmp8;
HXDLIN(  43)		if (hx::IsNotNull( _this13 )) {
HXLINE(  43)			_hx_tmp8 = _this13->zpp_disp;
            		}
            		else {
HXLINE(  43)			_hx_tmp8 = false;
            		}
HXDLIN(  43)		if (_hx_tmp8) {
HXLINE(  43)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(  43)		{
HXLINE(  43)			 ::zpp_nape::geom::ZPP_Vec2 _this14 = _this13->zpp_inner;
HXDLIN(  43)			if (hx::IsNotNull( _this14->_validate )) {
HXLINE(  43)				_this14->_validate();
            			}
            		}
HXDLIN(  43)		Float _hx_tmp9 = _this13->zpp_inner->x;
HXDLIN(  43)		 ::nape::phys::Body _this15 = this->body;
HXDLIN(  43)		if (hx::IsNull( _this15->zpp_inner->wrap_pos )) {
HXLINE(  43)			_this15->zpp_inner->setupPosition();
            		}
HXDLIN(  43)		 ::nape::geom::Vec2 _this16 = _this15->zpp_inner->wrap_pos;
HXDLIN(  43)		bool _hx_tmp10;
HXDLIN(  43)		if (hx::IsNotNull( _this16 )) {
HXLINE(  43)			_hx_tmp10 = _this16->zpp_disp;
            		}
            		else {
HXLINE(  43)			_hx_tmp10 = false;
            		}
HXDLIN(  43)		if (_hx_tmp10) {
HXLINE(  43)			HX_STACK_DO_THROW(((HX_("Error: ",4e,a8,5b,b7) + HX_("Vec2",7e,53,25,39)) + HX_(" has been disposed and cannot be used!",2e,07,ae,74)));
            		}
HXDLIN(  43)		{
HXLINE(  43)			 ::zpp_nape::geom::ZPP_Vec2 _this17 = _this16->zpp_inner;
HXDLIN(  43)			if (hx::IsNotNull( _this17->_validate )) {
HXLINE(  43)				_this17->_validate();
            			}
            		}
HXDLIN(  43)		gr->drawRect(_hx_tmp9,_this16->zpp_inner->y,this->width,this->height,null());
HXLINE(  44)		gr->popTransformation();
            	}


void PhysicText_obj::update(Float dt){
            	HX_STACKFRAME(&_hx_pos_08700a0760c392ba_47_update)
            	}



hx::ObjectPtr< PhysicText_obj > PhysicText_obj::__new(Float x,Float y,::String __o_text,hx::Null< int >  __o_size, ::Dynamic width) {
	hx::ObjectPtr< PhysicText_obj > __this = new PhysicText_obj();
	__this->__construct(x,y,__o_text,__o_size,width);
	return __this;
}

hx::ObjectPtr< PhysicText_obj > PhysicText_obj::__alloc(hx::Ctx *_hx_ctx,Float x,Float y,::String __o_text,hx::Null< int >  __o_size, ::Dynamic width) {
	PhysicText_obj *__this = (PhysicText_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(PhysicText_obj), true, "entity.element.ui.physic.PhysicText"));
	*(void **)__this = PhysicText_obj::_hx_vtable;
	__this->__construct(x,y,__o_text,__o_size,width);
	return __this;
}

PhysicText_obj::PhysicText_obj()
{
}

void PhysicText_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PhysicText);
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(size,"size");
	HX_MARK_MEMBER_NAME(risizeble,"risizeble");
	 ::entity::element::ui::physic::PhysicUI_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PhysicText_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(size,"size");
	HX_VISIT_MEMBER_NAME(risizeble,"risizeble");
	 ::entity::element::ui::physic::PhysicUI_obj::__Visit(HX_VISIT_ARG);
}

hx::Val PhysicText_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"text") ) { return hx::Val( text ); }
		if (HX_FIELD_EQ(inName,"size") ) { return hx::Val( size ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"risizeble") ) { return hx::Val( risizeble ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val PhysicText_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"text") ) { text=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"size") ) { size=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"risizeble") ) { risizeble=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PhysicText_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("text",ad,cc,f9,4c));
	outFields->push(HX_("size",c1,a0,53,4c));
	outFields->push(HX_("risizeble",63,da,be,90));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo PhysicText_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(PhysicText_obj,text),HX_("text",ad,cc,f9,4c)},
	{hx::fsInt,(int)offsetof(PhysicText_obj,size),HX_("size",c1,a0,53,4c)},
	{hx::fsBool,(int)offsetof(PhysicText_obj,risizeble),HX_("risizeble",63,da,be,90)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *PhysicText_obj_sStaticStorageInfo = 0;
#endif

static ::String PhysicText_obj_sMemberFields[] = {
	HX_("text",ad,cc,f9,4c),
	HX_("size",c1,a0,53,4c),
	HX_("risizeble",63,da,be,90),
	HX_("draw",04,2c,70,42),
	HX_("update",09,86,05,87),
	::String(null()) };

hx::Class PhysicText_obj::__mClass;

void PhysicText_obj::__register()
{
	PhysicText_obj _hx_dummy;
	PhysicText_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("entity.element.ui.physic.PhysicText",9e,b8,6b,5a);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(PhysicText_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< PhysicText_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PhysicText_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PhysicText_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace entity
} // end namespace element
} // end namespace ui
} // end namespace physic
