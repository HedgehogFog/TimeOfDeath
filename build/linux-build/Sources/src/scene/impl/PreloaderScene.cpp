// Generated by Haxe 4.0.0-preview.5
#include <hxcpp.h>

#ifndef INCLUDED_haxe_IMap
#include <hxinc/haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <hxinc/haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_iterators_MapKeyValueIterator
#include <hxinc/haxe/iterators/MapKeyValueIterator.h>
#endif
#ifndef INCLUDED_kha_Assets
#include <hxinc/kha/Assets.h>
#endif
#ifndef INCLUDED_kha_Canvas
#include <hxinc/kha/Canvas.h>
#endif
#ifndef INCLUDED_kha_Image
#include <hxinc/kha/Image.h>
#endif
#ifndef INCLUDED_kha_Kravur
#include <hxinc/kha/Kravur.h>
#endif
#ifndef INCLUDED_kha_KravurImage
#include <hxinc/kha/KravurImage.h>
#endif
#ifndef INCLUDED_kha_Resource
#include <hxinc/kha/Resource.h>
#endif
#ifndef INCLUDED_kha__Assets_FontList
#include <hxinc/kha/_Assets/FontList.h>
#endif
#ifndef INCLUDED_kha_graphics2_Graphics
#include <hxinc/kha/graphics2/Graphics.h>
#endif
#ifndef INCLUDED_scene_Scene
#include <hxinc/scene/Scene.h>
#endif
#ifndef INCLUDED_scene_impl_GameScene
#include <hxinc/scene/impl/GameScene.h>
#endif
#ifndef INCLUDED_scene_impl_PreloaderScene
#include <hxinc/scene/impl/PreloaderScene.h>
#endif
#ifndef INCLUDED_scene_managment_SceneManager
#include <hxinc/scene/managment/SceneManager.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_6b3eecea49489c27_33_new,"scene.impl.PreloaderScene","new",0x90d284b4,"scene.impl.PreloaderScene.new","scene/impl/PreloaderScene.hx",33,0xada444dc)
HX_LOCAL_STACK_FRAME(_hx_pos_6b3eecea49489c27_17_draw,"scene.impl.PreloaderScene","draw",0x20cf4130,"scene.impl.PreloaderScene.draw","scene/impl/PreloaderScene.hx",17,0xada444dc)
HX_LOCAL_STACK_FRAME(_hx_pos_6b3eecea49489c27_36_update,"scene.impl.PreloaderScene","update",0x0b353e35,"scene.impl.PreloaderScene.update","scene/impl/PreloaderScene.hx",36,0xada444dc)
HX_LOCAL_STACK_FRAME(_hx_pos_6b3eecea49489c27_42_destroy,"scene.impl.PreloaderScene","destroy",0x4a179b4e,"scene.impl.PreloaderScene.destroy","scene/impl/PreloaderScene.hx",42,0xada444dc)
namespace scene{
namespace impl{

void PreloaderScene_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_6b3eecea49489c27_33_new)
HXDLIN(  33)		this->loadTime = ((Float)2.0);
            	}

Dynamic PreloaderScene_obj::__CreateEmpty() { return new PreloaderScene_obj; }

void *PreloaderScene_obj::_hx_vtable = 0;

Dynamic PreloaderScene_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< PreloaderScene_obj > _hx_result = new PreloaderScene_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PreloaderScene_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x681713c2;
}

static ::scene::Scene_obj _hx_scene_impl_PreloaderScene__hx_scene_Scene= {
	( void (hx::Object::*)( ::kha::graphics2::Graphics))&::scene::impl::PreloaderScene_obj::draw,
	( void (hx::Object::*)(Float))&::scene::impl::PreloaderScene_obj::update,
	( void (hx::Object::*)())&::scene::impl::PreloaderScene_obj::destroy,
};

void *PreloaderScene_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0x199446a0: return &_hx_scene_impl_PreloaderScene__hx_scene_Scene;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void PreloaderScene_obj::draw( ::kha::graphics2::Graphics gr){
            	HX_GC_STACKFRAME(&_hx_pos_6b3eecea49489c27_17_draw)
HXLINE(  18)		gr->begin(true,-16777216);
HXLINE(  20)		gr->set_font(::kha::Assets_obj::fonts->OpenSans);
HXLINE(  21)		gr->set_fontSize(24);
HXLINE(  22)		gr->drawString(HX_("Hello world",a4,86,ae,dc),( (Float)(100) ),( (Float)(100) ));
HXLINE(  23)		int x = 0;
HXLINE(  24)		{
HXLINE(  24)			 ::Dynamic image =  ::haxe::iterators::MapKeyValueIterator_obj::__alloc( HX_CTX ,gr->get_font()->images);
HXDLIN(  24)			while(( (bool)(image->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  24)				 ::Dynamic image1 = image->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)();
HXLINE(  26)				gr->drawImage(( ( ::kha::KravurImage)(image1->__Field(HX_("value",71,7f,b8,31),hx::paccDynamic)) )->getTexture(),( (float)(x) ),( (float)(50) ));
HXLINE(  27)				x = (x + 10);
            			}
            		}
HXLINE(  30)		gr->end();
            	}


HX_DEFINE_DYNAMIC_FUNC1(PreloaderScene_obj,draw,(void))

void PreloaderScene_obj::update(Float dt){
            	HX_GC_STACKFRAME(&_hx_pos_6b3eecea49489c27_36_update)
HXDLIN(  36)		if (!((this->loadTime > 0))) {
HXLINE(  39)			 ::scene::managment::SceneManager _hx_tmp = ::scene::managment::SceneManager_obj::instance;
HXDLIN(  39)			_hx_tmp->setScene( ::scene::impl::GameScene_obj::__alloc( HX_CTX ));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(PreloaderScene_obj,update,(void))

void PreloaderScene_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_6b3eecea49489c27_42_destroy)
            	}


HX_DEFINE_DYNAMIC_FUNC0(PreloaderScene_obj,destroy,(void))


hx::ObjectPtr< PreloaderScene_obj > PreloaderScene_obj::__new() {
	hx::ObjectPtr< PreloaderScene_obj > __this = new PreloaderScene_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< PreloaderScene_obj > PreloaderScene_obj::__alloc(hx::Ctx *_hx_ctx) {
	PreloaderScene_obj *__this = (PreloaderScene_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(PreloaderScene_obj), false, "scene.impl.PreloaderScene"));
	*(void **)__this = PreloaderScene_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

PreloaderScene_obj::PreloaderScene_obj()
{
}

hx::Val PreloaderScene_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"bgColor") ) { return hx::Val( bgColor ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"loadTime") ) { return hx::Val( loadTime ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val PreloaderScene_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"bgColor") ) { bgColor=inValue.Cast< int >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"loadTime") ) { loadTime=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PreloaderScene_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("bgColor",5e,81,83,f7));
	outFields->push(HX_("loadTime",53,9d,9c,bd));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo PreloaderScene_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(PreloaderScene_obj,bgColor),HX_("bgColor",5e,81,83,f7)},
	{hx::fsFloat,(int)offsetof(PreloaderScene_obj,loadTime),HX_("loadTime",53,9d,9c,bd)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *PreloaderScene_obj_sStaticStorageInfo = 0;
#endif

static ::String PreloaderScene_obj_sMemberFields[] = {
	HX_("bgColor",5e,81,83,f7),
	HX_("draw",04,2c,70,42),
	HX_("loadTime",53,9d,9c,bd),
	HX_("update",09,86,05,87),
	HX_("destroy",fa,2c,86,24),
	::String(null()) };

hx::Class PreloaderScene_obj::__mClass;

void PreloaderScene_obj::__register()
{
	PreloaderScene_obj _hx_dummy;
	PreloaderScene_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("scene.impl.PreloaderScene",c2,5a,a5,77);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(PreloaderScene_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< PreloaderScene_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PreloaderScene_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PreloaderScene_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace scene
} // end namespace impl
